/* Generated by Cython 0.24.1 */

/* BEGIN: Cython Metadata
{
    "distutils": {
        "depends": [
            "/opt/mozilla/hydra/src/MurmurHash3.h", 
            "/opt/mozilla/hydra/src/mmap_writer.h"
        ]
    }, 
    "module_name": "_hydra"
}
END: Cython Metadata */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03020000)
    #error Cython requires Python 2.6+ or Python 3.2+.
#else
#define CYTHON_ABI "0_24_1"
#include <stddef.h>
#ifndef offsetof
  #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
  #define CYTHON_COMPILING_IN_PYPY 1
  #define CYTHON_COMPILING_IN_CPYTHON 0
#else
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_CPYTHON 1
#endif
#if !defined(CYTHON_USE_PYLONG_INTERNALS) && CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x02070000
  #define CYTHON_USE_PYLONG_INTERNALS 1
#endif
#if CYTHON_USE_PYLONG_INTERNALS
  #include "longintrepr.h"
  #undef SHIFT
  #undef BASE
  #undef MASK
#endif
#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
  #define Py_OptimizeFlag 0
#endif
#define __PYX_BUILD_PY_SSIZE_T "n"
#define CYTHON_FORMAT_SSIZE_T "z"
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyType_Type
#endif
#ifndef Py_TPFLAGS_CHECKTYPES
  #define Py_TPFLAGS_CHECKTYPES 0
#endif
#ifndef Py_TPFLAGS_HAVE_INDEX
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#ifndef Py_TPFLAGS_HAVE_NEWBUFFER
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#ifndef Py_TPFLAGS_HAVE_FINALIZE
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
#else
  #define CYTHON_PEP393_ENABLED 0
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
  #define PyObject_Malloc(s)   PyMem_Malloc(s)
  #define PyObject_Free(p)     PyMem_Free(p)
  #define PyObject_Realloc(p)  PyMem_Realloc(p)
#endif
#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION < 3 && !defined(PyObject_ASCII)
  #define PyObject_ASCII(o)            PyObject_Repr(o)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
  #ifndef PyUnicode_InternFromString
    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
  #endif
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
#else
  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
#endif
#if PY_VERSION_HEX >= 0x030500B1
#define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
#define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
#elif CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
typedef struct {
    unaryfunc am_await;
    unaryfunc am_aiter;
    unaryfunc am_anext;
} __Pyx_PyAsyncMethodsStruct;
#define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
#else
#define __Pyx_PyType_AsAsync(obj) NULL
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)

#ifndef CYTHON_INLINE
  #if defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
  #define _USE_MATH_DEFINES
#endif
#include <math.h>
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif
#if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
#define __Pyx_truncl trunc
#else
#define __Pyx_truncl truncl
#endif


#define __PYX_ERR(f_index, lineno, Ln_error) \
{ \
  __pyx_filename = __pyx_f[f_index]; __pyx_lineno = lineno; __pyx_clineno = __LINE__; goto Ln_error; \
}

#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#define __PYX_HAVE___hydra
#define __PYX_HAVE_API___hydra
#include "ctype.h"
#include "stdlib.h"
#include "stdio.h"
#include "mmap_writer.h"
#include "MurmurHash3.h"
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#ifdef PYREX_WITHOUT_ASSERTIONS
#define CYTHON_WITHOUT_ASSERTIONS
#endif

#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
#ifndef CYTHON_NCP_UNUSED
# if CYTHON_COMPILING_IN_CPYTHON
#  define CYTHON_NCP_UNUSED
# else
#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
# endif
#endif
typedef struct {PyObject **p; const char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
#define __PYX_DEFAULT_STRING_ENCODING ""
#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#define __Pyx_uchar_cast(c) ((unsigned char)c)
#define __Pyx_long_cast(x) ((long)x)
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (\
    (sizeof(type) < sizeof(Py_ssize_t))  ||\
    (sizeof(type) > sizeof(Py_ssize_t) &&\
          likely(v < (type)PY_SSIZE_T_MAX ||\
                 v == (type)PY_SSIZE_T_MAX)  &&\
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||\
                                v == (type)PY_SSIZE_T_MIN)))  ||\
    (sizeof(type) == sizeof(Py_ssize_t) &&\
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||\
                               v == (type)PY_SSIZE_T_MAX)))  )
#if defined (__cplusplus) && __cplusplus >= 201103L
    #include <cstdlib>
    #define __Pyx_sst_abs(value) std::abs(value)
#elif SIZEOF_INT >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) abs(value)
#elif SIZEOF_LONG >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) labs(value)
#elif defined (_MSC_VER) && defined (_M_X64)
    #define __Pyx_sst_abs(value) _abs64(value)
#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define __Pyx_sst_abs(value) llabs(value)
#elif defined (__GNUC__)
    #define __Pyx_sst_abs(value) __builtin_llabs(value)
#else
    #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
#endif
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyObject_AsSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
#define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
#define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
#define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
#define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
#if PY_MAJOR_VERSION < 3
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
{
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return (size_t)(u_end - u - 1);
}
#else
#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
#endif
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
#define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
#define __Pyx_PyBool_FromLong(b) ((b) ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False))
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
#if CYTHON_COMPILING_IN_CPYTHON
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
#else
#define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
#endif
#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    const char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    if (strcmp(default_encoding_c, "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (!ascii_chars_u) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
        Py_DECREF(ascii_chars_u);
        Py_DECREF(ascii_chars_b);
    }
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


/* Test for GCC > 2.95 */
#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
  #define likely(x)   __builtin_expect(!!(x), 1)
  #define unlikely(x) __builtin_expect(!!(x), 0)
#else /* !__GNUC__ or GCC < 2.95 */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */

static PyObject *__pyx_m;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static PyObject *__pyx_empty_unicode;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "src/_hydra.pyx",
};

/*--- Type declarations ---*/
struct __pyx_obj_6_hydra_MMapBitField;
struct __pyx_obj_6_hydra_MMapIter;
struct __pyx_obj_6_hydra_BloomCalculations;
struct __pyx_obj_6_hydra_BloomFilter;
struct __pyx_opt_args_6_hydra_12MMapBitField_open_rw_buffer;
struct __pyx_opt_args_6_hydra_12MMapBitField_open_ro_buffer;

/* "_hydra.pyx":66
 *             self.open_rw_buffer(want_lock)
 * 
 *     cdef void open_rw_buffer(self, want_lock=False):             # <<<<<<<<<<<<<<
 *         self._fd = open_mmap_file_rw(self._filename, self._bytesize)
 *         self._buffer = map_file_rw(self._fd, self._bytesize, want_lock)
 */
struct __pyx_opt_args_6_hydra_12MMapBitField_open_rw_buffer {
  int __pyx_n;
  PyObject *want_lock;
};

/* "_hydra.pyx":70
 *         self._buffer = map_file_rw(self._fd, self._bytesize, want_lock)
 * 
 *     cdef void open_ro_buffer(self, want_lock=False):             # <<<<<<<<<<<<<<
 *         self._fd = open_mmap_file_ro(self._filename)
 *         self._buffer = map_file_ro(self._fd, self._bytesize, want_lock)
 */
struct __pyx_opt_args_6_hydra_12MMapBitField_open_ro_buffer {
  int __pyx_n;
  PyObject *want_lock;
};

/* "_hydra.pyx":42
 *     return long(result[0]) << 64 | (long(result[1]) & 0xFFFFFFFFFFFFFFFF)
 * 
 * cdef class MMapBitField:             # <<<<<<<<<<<<<<
 *     cdef char* _filename
 *     cdef int _fd
 */
struct __pyx_obj_6_hydra_MMapBitField {
  PyObject_HEAD
  struct __pyx_vtabstruct_6_hydra_MMapBitField *__pyx_vtab;
  char *_filename;
  int _fd;
  long _bitsize;
  long _bytesize;
  char *_buffer;
  int _read_only;
  int _fdatasync_on_close;
};


/* "_hydra.pyx":140
 * 
 * 
 * cdef class MMapIter:             # <<<<<<<<<<<<<<
 *     cdef size_t _idx
 *     cdef MMapBitField  _bitfield
 */
struct __pyx_obj_6_hydra_MMapIter {
  PyObject_HEAD
  size_t _idx;
  struct __pyx_obj_6_hydra_MMapBitField *_bitfield;
};


/* "_hydra.pyx":173
 *         return c1 and c2
 * 
 * cdef class BloomCalculations:             # <<<<<<<<<<<<<<
 *     """
 *     This calculation class is ported straight from Cassandra.
 */
struct __pyx_obj_6_hydra_BloomCalculations {
  PyObject_HEAD
};


/* "_hydra.pyx":261
 *         return BloomSpecification(K, bucketsPerElement)
 * 
 * cdef class BloomFilter:             # <<<<<<<<<<<<<<
 *     EXCESS = 20
 *     cdef unsigned int _hashCount
 */
struct __pyx_obj_6_hydra_BloomFilter {
  PyObject_HEAD
  struct __pyx_vtabstruct_6_hydra_BloomFilter *__pyx_vtab;
  unsigned int _hashCount;
  struct __pyx_obj_6_hydra_MMapBitField *_bitmap;
  int _ignore_case;
  PyObject *_tempfile;
};



/* "_hydra.pyx":42
 *     return long(result[0]) << 64 | (long(result[1]) & 0xFFFFFFFFFFFFFFFF)
 * 
 * cdef class MMapBitField:             # <<<<<<<<<<<<<<
 *     cdef char* _filename
 *     cdef int _fd
 */

struct __pyx_vtabstruct_6_hydra_MMapBitField {
  void (*open_rw_buffer)(struct __pyx_obj_6_hydra_MMapBitField *, struct __pyx_opt_args_6_hydra_12MMapBitField_open_rw_buffer *__pyx_optional_args);
  void (*open_ro_buffer)(struct __pyx_obj_6_hydra_MMapBitField *, struct __pyx_opt_args_6_hydra_12MMapBitField_open_ro_buffer *__pyx_optional_args);
  PyObject *(*close)(struct __pyx_obj_6_hydra_MMapBitField *, int __pyx_skip_dispatch);
  PyObject *(*fdatasync)(struct __pyx_obj_6_hydra_MMapBitField *, int __pyx_skip_dispatch);
  PyObject *(*size)(struct __pyx_obj_6_hydra_MMapBitField *, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_6_hydra_MMapBitField *__pyx_vtabptr_6_hydra_MMapBitField;


/* "_hydra.pyx":261
 *         return BloomSpecification(K, bucketsPerElement)
 * 
 * cdef class BloomFilter:             # <<<<<<<<<<<<<<
 *     EXCESS = 20
 *     cdef unsigned int _hashCount
 */

struct __pyx_vtabstruct_6_hydra_BloomFilter {
  PyObject *(*close)(struct __pyx_obj_6_hydra_BloomFilter *, int __pyx_skip_dispatch);
  PyObject *(*fdatasync)(struct __pyx_obj_6_hydra_BloomFilter *, int __pyx_skip_dispatch);
  PyObject *(*add)(struct __pyx_obj_6_hydra_BloomFilter *, PyObject *, int __pyx_skip_dispatch);
  PyObject *(*contains)(struct __pyx_obj_6_hydra_BloomFilter *, PyObject *, int __pyx_skip_dispatch);
  PyObject *(*buckets)(struct __pyx_obj_6_hydra_BloomFilter *, int __pyx_skip_dispatch);
  void (*_get_hash_buckets)(struct __pyx_obj_6_hydra_BloomFilter *, PyObject *, unsigned PY_LONG_LONG *, unsigned int, unsigned long);
  void (*_strip_newline)(struct __pyx_obj_6_hydra_BloomFilter *, char *, unsigned int);
};
static struct __pyx_vtabstruct_6_hydra_BloomFilter *__pyx_vtabptr_6_hydra_BloomFilter;

/* --- Runtime support code (head) --- */
/* Refnanny.proto */
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          if (acquire_gil) {\
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
              PyGILState_Release(__pyx_gilstate_save);\
          } else {\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext()\
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif
#define __Pyx_XDECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_XDECREF(tmp);\
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_DECREF(tmp);\
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

/* PyObjectGetAttrStr.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

/* GetBuiltinName.proto */
static PyObject *__Pyx_GetBuiltinName(PyObject *name);

/* RaiseDoubleKeywords.proto */
static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);

/* ParseKeywords.proto */
static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
    const char* function_name);

/* RaiseArgTupleInvalid.proto */
static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);

/* PyObjectCall.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

/* None.proto */
static CYTHON_INLINE long __Pyx_div_long(long, long);

/* PyThreadStateGet.proto */
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
#define __Pyx_PyThreadState_assign  __pyx_tstate = PyThreadState_GET();
#else
#define __Pyx_PyThreadState_declare
#define __Pyx_PyThreadState_assign
#endif

/* PyErrFetchRestore.proto */
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
#endif

/* WriteUnraisableException.proto */
static void __Pyx_WriteUnraisable(const char *name, int clineno,
                                  int lineno, const char *filename,
                                  int full_traceback, int nogil);

/* PyObjectCallMethO.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
#endif

/* PyObjectCallOneArg.proto */
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);

/* PyObjectCallNoArg.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
#else
#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
#endif

/* RaiseException.proto */
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);

/* ExtTypeTest.proto */
static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);

/* GetItemInt.proto */
#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                     int is_list, int wraparound, int boundscheck);

/* PyObjectSetAttrStr.proto */
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o,n,NULL)
static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_setattro))
        return tp->tp_setattro(obj, attr_name, value);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_setattr))
        return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
#endif
    return PyObject_SetAttr(obj, attr_name, value);
}
#else
#define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
#define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
#endif

/* GetAttr.proto */
static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *, PyObject *);

/* GetAttr3.proto */
static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *, PyObject *, PyObject *);

/* GetModuleGlobalName.proto */
static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name);

/* PyIntBinop.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, long intval, int inplace);
#else
#define __Pyx_PyInt_AddObjC(op1, op2, intval, inplace)\
    (inplace ? PyNumber_InPlaceAdd(op1, op2) : PyNumber_Add(op1, op2))
#endif

/* PyIntBinop.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx_PyInt_SubtractObjC(PyObject *op1, PyObject *op2, long intval, int inplace);
#else
#define __Pyx_PyInt_SubtractObjC(op1, op2, intval, inplace)\
    (inplace ? PyNumber_InPlaceSubtract(op1, op2) : PyNumber_Subtract(op1, op2))
#endif

/* ArgTypeTest.proto */
static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact);

/* KeywordStringCheck.proto */
static CYTHON_INLINE int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed);

/* dict_getitem_default.proto */
static PyObject* __Pyx_PyDict_GetItemDefault(PyObject* d, PyObject* key, PyObject* default_value);

/* None.proto */
static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname);

/* SetItemInt.proto */
#define __Pyx_SetItemInt(o, i, v, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_SetItemInt_Fast(o, (Py_ssize_t)i, v, is_list, wraparound, boundscheck) :\
    (is_list ? (PyErr_SetString(PyExc_IndexError, "list assignment index out of range"), -1) :\
               __Pyx_SetItemInt_Generic(o, to_py_func(i), v)))
static CYTHON_INLINE int __Pyx_SetItemInt_Generic(PyObject *o, PyObject *j, PyObject *v);
static CYTHON_INLINE int __Pyx_SetItemInt_Fast(PyObject *o, Py_ssize_t i, PyObject *v,
                                               int is_list, int wraparound, int boundscheck);

/* ListAppend.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
#endif

/* IncludeStringH.proto */
#include <string.h>

/* SetVTable.proto */
static int __Pyx_SetVtable(PyObject *dict, void *vtable);

/* Import.proto */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);

/* CalculateMetaclass.proto */
static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases);

/* Py3ClassCreate.proto */
static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name, PyObject *qualname,
                                           PyObject *mkw, PyObject *modname, PyObject *doc);
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases, PyObject *dict,
                                      PyObject *mkw, int calculate_metaclass, int allow_py2_metaclass);

/* FetchCommonType.proto */
static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);

/* CythonFunction.proto */
#define __Pyx_CyFunction_USED 1
#include <structmember.h>
#define __Pyx_CYFUNCTION_STATICMETHOD  0x01
#define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
#define __Pyx_CYFUNCTION_CCLASS        0x04
#define __Pyx_CyFunction_GetClosure(f)\
    (((__pyx_CyFunctionObject *) (f))->func_closure)
#define __Pyx_CyFunction_GetClassObj(f)\
    (((__pyx_CyFunctionObject *) (f))->func_classobj)
#define __Pyx_CyFunction_Defaults(type, f)\
    ((type *)(((__pyx_CyFunctionObject *) (f))->defaults))
#define __Pyx_CyFunction_SetDefaultsGetter(f, g)\
    ((__pyx_CyFunctionObject *) (f))->defaults_getter = (g)
typedef struct {
    PyCFunctionObject func;
#if PY_VERSION_HEX < 0x030500A0
    PyObject *func_weakreflist;
#endif
    PyObject *func_dict;
    PyObject *func_name;
    PyObject *func_qualname;
    PyObject *func_doc;
    PyObject *func_globals;
    PyObject *func_code;
    PyObject *func_closure;
    PyObject *func_classobj;
    void *defaults;
    int defaults_pyobjects;
    int flags;
    PyObject *defaults_tuple;
    PyObject *defaults_kwdict;
    PyObject *(*defaults_getter)(PyObject *);
    PyObject *func_annotations;
} __pyx_CyFunctionObject;
static PyTypeObject *__pyx_CyFunctionType = 0;
#define __Pyx_CyFunction_NewEx(ml, flags, qualname, self, module, globals, code)\
    __Pyx_CyFunction_New(__pyx_CyFunctionType, ml, flags, qualname, self, module, globals, code)
static PyObject *__Pyx_CyFunction_New(PyTypeObject *, PyMethodDef *ml,
                                      int flags, PyObject* qualname,
                                      PyObject *self,
                                      PyObject *module, PyObject *globals,
                                      PyObject* code);
static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *m,
                                                         size_t size,
                                                         int pyobjects);
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *m,
                                                            PyObject *tuple);
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *m,
                                                             PyObject *dict);
static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *m,
                                                              PyObject *dict);
static int __pyx_CyFunction_init(void);

/* GetNameInClass.proto */
static PyObject *__Pyx_GetNameInClass(PyObject *nmspace, PyObject *name);

/* ListCompAppend.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len)) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
#endif

/* CodeObjectCache.proto */
typedef struct {
    PyCodeObject* code_object;
    int code_line;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

/* AddTraceback.proto */
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);

/* None.proto */
static CYTHON_INLINE size_t __Pyx_pow_size_t(size_t, size_t);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_int(unsigned int value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_PY_LONG_LONG(unsigned PY_LONG_LONG value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_long(unsigned long value);

/* ClassMethod.proto */
#include "descrobject.h"
static PyObject* __Pyx_Method_ClassMethod(PyObject *method);

/* CIntFromPy.proto */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE unsigned int __Pyx_PyInt_As_unsigned_int(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_As_unsigned_PY_LONG_LONG(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE unsigned long __Pyx_PyInt_As_unsigned_long(PyObject *);

/* CheckBinaryVersion.proto */
static int __Pyx_check_binary_version(void);

/* InitStrings.proto */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);

static void __pyx_f_6_hydra_12MMapBitField_open_rw_buffer(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, struct __pyx_opt_args_6_hydra_12MMapBitField_open_rw_buffer *__pyx_optional_args); /* proto*/
static void __pyx_f_6_hydra_12MMapBitField_open_ro_buffer(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, struct __pyx_opt_args_6_hydra_12MMapBitField_open_ro_buffer *__pyx_optional_args); /* proto*/
static PyObject *__pyx_f_6_hydra_12MMapBitField_close(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static PyObject *__pyx_f_6_hydra_12MMapBitField_fdatasync(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static PyObject *__pyx_f_6_hydra_12MMapBitField_size(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static PyObject *__pyx_f_6_hydra_11BloomFilter_close(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static PyObject *__pyx_f_6_hydra_11BloomFilter_fdatasync(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static PyObject *__pyx_f_6_hydra_11BloomFilter_add(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_ustring, int __pyx_skip_dispatch); /* proto*/
static PyObject *__pyx_f_6_hydra_11BloomFilter_contains(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_ustring, int __pyx_skip_dispatch); /* proto*/
static PyObject *__pyx_f_6_hydra_11BloomFilter_buckets(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static void __pyx_f_6_hydra_11BloomFilter__get_hash_buckets(CYTHON_UNUSED struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_key, unsigned PY_LONG_LONG *__pyx_v__bucket_indexes, unsigned int __pyx_v_hashCount, unsigned long __pyx_v_max); /* proto*/
static void __pyx_f_6_hydra_11BloomFilter__strip_newline(CYTHON_UNUSED struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, char *__pyx_v_buffer, unsigned int __pyx_v_size); /* proto*/

/* Module declarations from 'cython' */

/* Module declarations from '_hydra' */
static PyTypeObject *__pyx_ptype_6_hydra_MMapBitField = 0;
static PyTypeObject *__pyx_ptype_6_hydra_MMapIter = 0;
static PyTypeObject *__pyx_ptype_6_hydra_BloomCalculations = 0;
static PyTypeObject *__pyx_ptype_6_hydra_BloomFilter = 0;
static void __pyx_f_6_hydra_c_lcase(char *); /*proto*/
#define __Pyx_MODULE_NAME "_hydra"
int __pyx_module_is_main__hydra = 0;

/* Implementation of '_hydra' */
static PyObject *__pyx_builtin_Exception;
static PyObject *__pyx_builtin_min;
static PyObject *__pyx_builtin_enumerate;
static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_StopIteration;
static PyObject *__pyx_builtin_RuntimeError;
static PyObject *__pyx_builtin_range;
static const char __pyx_k_K[] = "K";
static const char __pyx_k_k[] = "k";
static const char __pyx_k_c1[] = "c1";
static const char __pyx_k_c2[] = "c2";
static const char __pyx_k_eq[] = "__eq__";
static const char __pyx_k_os[] = "os";
static const char __pyx_k_add[] = "add";
static const char __pyx_k_doc[] = "__doc__";
static const char __pyx_k_get[] = "get";
static const char __pyx_k_key[] = "key";
static const char __pyx_k_max[] = "max";
static const char __pyx_k_min[] = "min";
static const char __pyx_k_sys[] = "sys";
static const char __pyx_k_file[] = "file";
static const char __pyx_k_hash[] = "hash";
static const char __pyx_k_init[] = "__init__";
static const char __pyx_k_main[] = "__main__";
static const char __pyx_k_minK[] = "minK";
static const char __pyx_k_name[] = "name";
static const char __pyx_k_seed[] = "seed";
static const char __pyx_k_self[] = "self";
static const char __pyx_k_size[] = "size";
static const char __pyx_k_test[] = "__test__";
static const char __pyx_k_utf8[] = "utf8";
static const char __pyx_k_PROBS[] = "PROBS";
static const char __pyx_k_close[] = "close";
static const char __pyx_k_hydra[] = "_hydra";
static const char __pyx_k_other[] = "other";
static const char __pyx_k_probs[] = "probs";
static const char __pyx_k_range[] = "range";
static const char __pyx_k_EXCESS[] = "EXCESS";
static const char __pyx_k_bitmap[] = "bitmap";
static const char __pyx_k_delete[] = "delete";
static const char __pyx_k_encode[] = "encode";
static const char __pyx_k_hashes[] = "hashes";
static const char __pyx_k_import[] = "__import__";
static const char __pyx_k_module[] = "__module__";
static const char __pyx_k_result[] = "result";
static const char __pyx_k_bitsize[] = "bitsize";
static const char __pyx_k_buckets[] = "buckets";
static const char __pyx_k_maxsize[] = "maxsize";
static const char __pyx_k_prepare[] = "__prepare__";
static const char __pyx_k_ustring[] = "ustring";
static const char __pyx_k_bitfield[] = "bitfield";
static const char __pyx_k_contains[] = "contains";
static const char __pyx_k_filename[] = "filename";
static const char __pyx_k_operator[] = "operator";
static const char __pyx_k_qualname[] = "__qualname__";
static const char __pyx_k_tempfile[] = "tempfile";
static const char __pyx_k_Exception[] = "Exception";
static const char __pyx_k_enumerate[] = "enumerate";
static const char __pyx_k_fdatasync[] = "fdatasync";
static const char __pyx_k_getFilter[] = "getFilter";
static const char __pyx_k_hashCount[] = "hashCount";
static const char __pyx_k_metaclass[] = "__metaclass__";
static const char __pyx_k_read_only[] = "read_only";
static const char __pyx_k_want_lock[] = "want_lock";
static const char __pyx_k_ValueError[] = "ValueError";
static const char __pyx_k_bucketsFor[] = "_bucketsFor";
static const char __pyx_k_bucketsPer[] = "bucketsPer";
static const char __pyx_k_itemgetter[] = "itemgetter";
static const char __pyx_k_minBuckets[] = "minBuckets";
static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
static const char __pyx_k_ignore_case[] = "ignore_case";
static const char __pyx_k_numElements[] = "numElements";
static const char __pyx_k_RuntimeError[] = "RuntimeError";
static const char __pyx_k_StopIteration[] = "StopIteration";
static const char __pyx_k_optKPerBuckets[] = "optKPerBuckets";
static const char __pyx_k_maxFalsePosProb[] = "maxFalsePosProb";
static const char __pyx_k_bucketsPerElement[] = "bucketsPerElement";
static const char __pyx_k_computeBloomSpec1[] = "computeBloomSpec1";
static const char __pyx_k_computeBloomSpec2[] = "computeBloomSpec2";
static const char __pyx_k_BloomSpecification[] = "BloomSpecification";
static const char __pyx_k_NamedTemporaryFile[] = "NamedTemporaryFile";
static const char __pyx_k_fdatasync_on_close[] = "fdatasync_on_close";
static const char __pyx_k_Invalid_probability[] = "Invalid probability";
static const char __pyx_k_Unexpected_kwargs_s[] = "Unexpected kwargs: %s";
static const char __pyx_k_maxBucketsPerElement[] = "maxBucketsPerElement";
static const char __pyx_k_bit_field_is_read_only[] = "bit field is read only";
static const char __pyx_k_maxBucketsPerElement_2[] = "_maxBucketsPerElement";
static const char __pyx_k_maxFalsePosProbability[] = "maxFalsePosProbability";
static const char __pyx_k_BloomSpecification___eq[] = "BloomSpecification.__eq__";
static const char __pyx_k_BloomSpecification___init[] = "BloomSpecification.__init__";
static const char __pyx_k_I_O_operation_on_closed_file[] = "I/O operation on closed file";
static const char __pyx_k_UnsupportedOperationException[] = "UnsupportedOperationException";
static const char __pyx_k_A_wrapper_class_that_holds_two[] = "\n    A wrapper class that holds two key parameters for a Bloom Filter: the\n    number of hash functions used, and the number of buckets per element used.\n    ";
static const char __pyx_k_opt_mozilla_hydra_src__hydra_py[] = "/opt/mozilla/hydra/src/_hydra.pyx";
static const char __pyx_k_Cannot_compute_probabilities_for[] = "Cannot compute probabilities for %s elements.";
static const char __pyx_k_Unable_to_satisfy_s_with_s_bucke[] = "Unable to satisfy %s with %s buckets per element";
static PyObject *__pyx_kp_s_A_wrapper_class_that_holds_two;
static PyObject *__pyx_n_s_BloomSpecification;
static PyObject *__pyx_n_s_BloomSpecification___eq;
static PyObject *__pyx_n_s_BloomSpecification___init;
static PyObject *__pyx_kp_s_Cannot_compute_probabilities_for;
static PyObject *__pyx_n_s_EXCESS;
static PyObject *__pyx_n_s_Exception;
static PyObject *__pyx_kp_s_I_O_operation_on_closed_file;
static PyObject *__pyx_kp_s_Invalid_probability;
static PyObject *__pyx_n_s_K;
static PyObject *__pyx_n_s_NamedTemporaryFile;
static PyObject *__pyx_n_s_PROBS;
static PyObject *__pyx_n_s_RuntimeError;
static PyObject *__pyx_n_s_StopIteration;
static PyObject *__pyx_kp_s_Unable_to_satisfy_s_with_s_bucke;
static PyObject *__pyx_kp_s_Unexpected_kwargs_s;
static PyObject *__pyx_n_s_UnsupportedOperationException;
static PyObject *__pyx_n_s_ValueError;
static PyObject *__pyx_n_s_add;
static PyObject *__pyx_kp_s_bit_field_is_read_only;
static PyObject *__pyx_n_s_bitfield;
static PyObject *__pyx_n_s_bitmap;
static PyObject *__pyx_n_s_bitsize;
static PyObject *__pyx_n_s_buckets;
static PyObject *__pyx_n_s_bucketsFor;
static PyObject *__pyx_n_s_bucketsPer;
static PyObject *__pyx_n_s_bucketsPerElement;
static PyObject *__pyx_n_s_c1;
static PyObject *__pyx_n_s_c2;
static PyObject *__pyx_n_s_close;
static PyObject *__pyx_n_s_computeBloomSpec1;
static PyObject *__pyx_n_s_computeBloomSpec2;
static PyObject *__pyx_n_s_contains;
static PyObject *__pyx_n_s_delete;
static PyObject *__pyx_n_s_doc;
static PyObject *__pyx_n_s_encode;
static PyObject *__pyx_n_s_enumerate;
static PyObject *__pyx_n_s_eq;
static PyObject *__pyx_n_s_fdatasync;
static PyObject *__pyx_n_s_fdatasync_on_close;
static PyObject *__pyx_n_s_file;
static PyObject *__pyx_n_s_filename;
static PyObject *__pyx_n_s_get;
static PyObject *__pyx_n_s_getFilter;
static PyObject *__pyx_n_s_hash;
static PyObject *__pyx_n_s_hashCount;
static PyObject *__pyx_n_s_hashes;
static PyObject *__pyx_n_s_hydra;
static PyObject *__pyx_n_s_ignore_case;
static PyObject *__pyx_n_s_import;
static PyObject *__pyx_n_s_init;
static PyObject *__pyx_n_s_itemgetter;
static PyObject *__pyx_n_s_k;
static PyObject *__pyx_n_s_key;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_n_s_max;
static PyObject *__pyx_n_s_maxBucketsPerElement;
static PyObject *__pyx_n_s_maxBucketsPerElement_2;
static PyObject *__pyx_n_s_maxFalsePosProb;
static PyObject *__pyx_n_s_maxFalsePosProbability;
static PyObject *__pyx_n_s_maxsize;
static PyObject *__pyx_n_s_metaclass;
static PyObject *__pyx_n_s_min;
static PyObject *__pyx_n_s_minBuckets;
static PyObject *__pyx_n_s_minK;
static PyObject *__pyx_n_s_module;
static PyObject *__pyx_n_s_name;
static PyObject *__pyx_n_s_numElements;
static PyObject *__pyx_n_s_operator;
static PyObject *__pyx_n_s_optKPerBuckets;
static PyObject *__pyx_kp_s_opt_mozilla_hydra_src__hydra_py;
static PyObject *__pyx_n_s_os;
static PyObject *__pyx_n_s_other;
static PyObject *__pyx_n_s_prepare;
static PyObject *__pyx_n_s_probs;
static PyObject *__pyx_n_s_pyx_vtable;
static PyObject *__pyx_n_s_qualname;
static PyObject *__pyx_n_s_range;
static PyObject *__pyx_n_s_read_only;
static PyObject *__pyx_n_s_result;
static PyObject *__pyx_n_s_seed;
static PyObject *__pyx_n_s_self;
static PyObject *__pyx_n_s_size;
static PyObject *__pyx_n_s_sys;
static PyObject *__pyx_n_s_tempfile;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_n_s_ustring;
static PyObject *__pyx_n_s_utf8;
static PyObject *__pyx_n_s_want_lock;
static PyObject *__pyx_pf_6_hydra_hash(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_key, int __pyx_v_seed); /* proto */
static int __pyx_pf_6_hydra_12MMapBitField___cinit__(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, PyObject *__pyx_v_filename, long __pyx_v_bitsize, int __pyx_v_read_only, int __pyx_v_want_lock, int __pyx_v_fdatasync_on_close); /* proto */
static void __pyx_pf_6_hydra_12MMapBitField_2__dealloc__(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6_hydra_12MMapBitField_4close(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6_hydra_12MMapBitField_6fdatasync(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self); /* proto */
static int __pyx_pf_6_hydra_12MMapBitField_8__setitem__(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, size_t __pyx_v_key, int __pyx_v_value); /* proto */
static PyObject *__pyx_pf_6_hydra_12MMapBitField_10__getitem__(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, size_t __pyx_v_key); /* proto */
static PyObject *__pyx_pf_6_hydra_12MMapBitField_12__iter__(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self); /* proto */
static Py_ssize_t __pyx_pf_6_hydra_12MMapBitField_14__len__(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6_hydra_12MMapBitField_16size(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self); /* proto */
static int __pyx_pf_6_hydra_8MMapIter___cinit__(struct __pyx_obj_6_hydra_MMapIter *__pyx_v_self, PyObject *__pyx_v_bitfield); /* proto */
static PyObject *__pyx_pf_6_hydra_8MMapIter_2__next__(struct __pyx_obj_6_hydra_MMapIter *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6_hydra_18BloomSpecification___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_k, PyObject *__pyx_v_bucketsPerElement); /* proto */
static PyObject *__pyx_pf_6_hydra_18BloomSpecification_2__eq__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_other); /* proto */
static PyObject *__pyx_pf_6_hydra_17BloomCalculations_computeBloomSpec1(PyTypeObject *__pyx_v_cls, PyObject *__pyx_v_bucketsPerElement); /* proto */
static PyObject *__pyx_pf_6_hydra_17BloomCalculations_2computeBloomSpec2(PyTypeObject *__pyx_v_cls, PyObject *__pyx_v_maxBucketsPerElement, PyObject *__pyx_v_maxFalsePosProb); /* proto */
static int __pyx_pf_6_hydra_11BloomFilter___cinit__(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, unsigned int __pyx_v_hashes, struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_bitmap, int __pyx_v_ignore_case); /* proto */
static PyObject *__pyx_pf_6_hydra_11BloomFilter_2__enter__(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6_hydra_11BloomFilter_4__exit__(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_excinfo); /* proto */
static PyObject *__pyx_pf_6_hydra_11BloomFilter_6close(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6_hydra_11BloomFilter_8fdatasync(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6_hydra_11BloomFilter_10filename(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6_hydra_11BloomFilter_12_maxBucketsPerElement(PyTypeObject *__pyx_v_cls, PyObject *__pyx_v_numElements); /* proto */
static PyObject *__pyx_pf_6_hydra_11BloomFilter_14_bucketsFor(PyTypeObject *__pyx_v_cls, PyObject *__pyx_v_numElements, PyObject *__pyx_v_bucketsPer, PyObject *__pyx_v_filename, PyObject *__pyx_v_read_only, PyObject *__pyx_v_want_lock, PyObject *__pyx_v_fdatasync_on_close); /* proto */
static PyObject *__pyx_pf_6_hydra_11BloomFilter_16getFilter(PyTypeObject *__pyx_v_cls, PyObject *__pyx_v_numElements, PyObject *__pyx_v_maxFalsePosProbability, PyObject *__pyx_v_kwargs); /* proto */
static int __pyx_pf_6_hydra_11BloomFilter_18__setitem__(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_key, CYTHON_UNUSED int __pyx_v_ignored); /* proto */
static PyObject *__pyx_pf_6_hydra_11BloomFilter_20__getitem__(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_key); /* proto */
static int __pyx_pf_6_hydra_11BloomFilter_22__contains__(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_ustring); /* proto */
static PyObject *__pyx_pf_6_hydra_11BloomFilter_24add(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_ustring); /* proto */
static PyObject *__pyx_pf_6_hydra_11BloomFilter_26contains(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_ustring); /* proto */
static PyObject *__pyx_pf_6_hydra_11BloomFilter_28buckets(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6_hydra_11BloomFilter_30getHashBuckets(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_ustring, unsigned int __pyx_v_hashCount, unsigned PY_LONG_LONG __pyx_v_max); /* proto */
static PyObject *__pyx_pf_6_hydra_11BloomFilter_32bulkload_text(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, char *__pyx_v_filename); /* proto */
static PyObject *__pyx_tp_new_6_hydra_MMapBitField(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_6_hydra_MMapIter(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_6_hydra_BloomCalculations(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_6_hydra_BloomFilter(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_float_1_0;
static PyObject *__pyx_float_0_08;
static PyObject *__pyx_float_0_001;
static PyObject *__pyx_float_0_003;
static PyObject *__pyx_float_0_005;
static PyObject *__pyx_float_0_024;
static PyObject *__pyx_float_0_054;
static PyObject *__pyx_float_0_074;
static PyObject *__pyx_float_0_092;
static PyObject *__pyx_float_0_101;
static PyObject *__pyx_float_0_105;
static PyObject *__pyx_float_0_109;
static PyObject *__pyx_float_0_118;
static PyObject *__pyx_float_0_133;
static PyObject *__pyx_float_0_147;
static PyObject *__pyx_float_0_154;
static PyObject *__pyx_float_0_155;
static PyObject *__pyx_float_0_160;
static PyObject *__pyx_float_0_181;
static PyObject *__pyx_float_0_221;
static PyObject *__pyx_float_0_237;
static PyObject *__pyx_float_0_253;
static PyObject *__pyx_float_0_283;
static PyObject *__pyx_float_0_393;
static PyObject *__pyx_float_0_400;
static PyObject *__pyx_float_0_0012;
static PyObject *__pyx_float_0_0013;
static PyObject *__pyx_float_0_0027;
static PyObject *__pyx_float_0_0065;
static PyObject *__pyx_float_0_0108;
static PyObject *__pyx_float_0_0111;
static PyObject *__pyx_float_0_0118;
static PyObject *__pyx_float_0_0123;
static PyObject *__pyx_float_0_0133;
static PyObject *__pyx_float_0_0135;
static PyObject *__pyx_float_0_0136;
static PyObject *__pyx_float_0_0138;
static PyObject *__pyx_float_0_0141;
static PyObject *__pyx_float_0_0145;
static PyObject *__pyx_float_0_0156;
static PyObject *__pyx_float_0_0166;
static PyObject *__pyx_float_0_0174;
static PyObject *__pyx_float_0_0177;
static PyObject *__pyx_float_0_0203;
static PyObject *__pyx_float_0_0216;
static PyObject *__pyx_float_0_0217;
static PyObject *__pyx_float_0_0228;
static PyObject *__pyx_float_0_0229;
static PyObject *__pyx_float_0_0236;
static PyObject *__pyx_float_0_0276;
static PyObject *__pyx_float_0_0306;
static PyObject *__pyx_float_0_0329;
static PyObject *__pyx_float_0_0347;
static PyObject *__pyx_float_0_0359;
static PyObject *__pyx_float_0_0364;
static PyObject *__pyx_float_0_0397;
static PyObject *__pyx_float_0_0423;
static PyObject *__pyx_float_0_0488;
static PyObject *__pyx_float_0_0489;
static PyObject *__pyx_float_0_0513;
static PyObject *__pyx_float_0_0561;
static PyObject *__pyx_float_0_0571;
static PyObject *__pyx_float_0_0578;
static PyObject *__pyx_float_0_0606;
static PyObject *__pyx_float_0_0609;
static PyObject *__pyx_float_0_0618;
static PyObject *__pyx_float_0_0638;
static PyObject *__pyx_float_0_0645;
static PyObject *__pyx_float_0_0689;
static PyObject *__pyx_float_0_0804;
static PyObject *__pyx_float_0_0869;
static PyObject *__pyx_float_0_0952;
static PyObject *__pyx_float_0_00014;
static PyObject *__pyx_float_0_00036;
static PyObject *__pyx_float_0_00047;
static PyObject *__pyx_float_0_00053;
static PyObject *__pyx_float_0_00107;
static PyObject *__pyx_float_0_00108;
static PyObject *__pyx_float_0_00121;
static PyObject *__pyx_float_0_00128;
static PyObject *__pyx_float_0_00129;
static PyObject *__pyx_float_0_00139;
static PyObject *__pyx_float_0_00146;
static PyObject *__pyx_float_0_00158;
static PyObject *__pyx_float_0_00179;
static PyObject *__pyx_float_0_00183;
static PyObject *__pyx_float_0_00193;
static PyObject *__pyx_float_0_00194;
static PyObject *__pyx_float_0_00199;
static PyObject *__pyx_float_0_00217;
static PyObject *__pyx_float_0_00239;
static PyObject *__pyx_float_0_00244;
static PyObject *__pyx_float_0_00255;
static PyObject *__pyx_float_0_00312;
static PyObject *__pyx_float_0_00314;
static PyObject *__pyx_float_0_00329;
static PyObject *__pyx_float_0_00332;
static PyObject *__pyx_float_0_00362;
static PyObject *__pyx_float_0_00371;
static PyObject *__pyx_float_0_00381;
static PyObject *__pyx_float_0_00423;
static PyObject *__pyx_float_0_00459;
static PyObject *__pyx_float_0_00492;
static PyObject *__pyx_float_0_00509;
static PyObject *__pyx_float_0_00513;
static PyObject *__pyx_float_0_00552;
static PyObject *__pyx_float_0_00596;
static PyObject *__pyx_float_0_00646;
static PyObject *__pyx_float_0_00718;
static PyObject *__pyx_float_0_00819;
static PyObject *__pyx_float_0_00844;
static PyObject *__pyx_float_0_00846;
static PyObject *__pyx_float_0_00864;
static PyObject *__pyx_float_0_00875;
static PyObject *__pyx_float_0_00906;
static PyObject *__pyx_float_0_00943;
static PyObject *__pyx_float_0_00998;
static PyObject *__pyx_float_0_000108;
static PyObject *__pyx_float_0_000109;
static PyObject *__pyx_float_0_000111;
static PyObject *__pyx_float_0_000118;
static PyObject *__pyx_float_0_000132;
static PyObject *__pyx_float_0_000155;
static PyObject *__pyx_float_0_000176;
static PyObject *__pyx_float_0_000183;
static PyObject *__pyx_float_0_000194;
static PyObject *__pyx_float_0_000196;
static PyObject *__pyx_float_0_000198;
static PyObject *__pyx_float_0_000226;
static PyObject *__pyx_float_0_000264;
static PyObject *__pyx_float_0_000275;
static PyObject *__pyx_float_0_000284;
static PyObject *__pyx_float_0_000287;
static PyObject *__pyx_float_0_000302;
static PyObject *__pyx_float_0_000303;
static PyObject *__pyx_float_0_000335;
static PyObject *__pyx_float_0_000394;
static PyObject *__pyx_float_0_000459;
static PyObject *__pyx_float_0_000499;
static PyObject *__pyx_float_0_000505;
static PyObject *__pyx_float_0_000519;
static PyObject *__pyx_float_0_000574;
static PyObject *__pyx_float_0_000663;
static PyObject *__pyx_float_0_000692;
static PyObject *__pyx_float_0_000702;
static PyObject *__pyx_float_0_000744;
static PyObject *__pyx_float_0_000775;
static PyObject *__pyx_float_0_000839;
static PyObject *__pyx_float_0_000852;
static PyObject *__pyx_float_0_000935;
static PyObject *__pyx_float_6_71eneg_05;
static PyObject *__pyx_float_6_79eneg_05;
static PyObject *__pyx_float_7_12eneg_05;
static PyObject *__pyx_float_7_77eneg_05;
static PyObject *__pyx_float_8_89eneg_05;
static PyObject *__pyx_int_0;
static PyObject *__pyx_int_1;
static PyObject *__pyx_int_2;
static PyObject *__pyx_int_20;
static PyObject *__pyx_int_64;
static PyObject *__pyx_int_4294967295;
static PyObject *__pyx_int_18446744073709551615;
static PyObject *__pyx_tuple_;
static PyObject *__pyx_tuple__2;
static PyObject *__pyx_tuple__3;
static PyObject *__pyx_tuple__4;
static PyObject *__pyx_tuple__5;
static PyObject *__pyx_tuple__6;
static PyObject *__pyx_tuple__7;
static PyObject *__pyx_tuple__8;
static PyObject *__pyx_tuple__9;
static PyObject *__pyx_tuple__10;
static PyObject *__pyx_tuple__11;
static PyObject *__pyx_tuple__12;
static PyObject *__pyx_tuple__13;
static PyObject *__pyx_tuple__14;
static PyObject *__pyx_tuple__16;
static PyObject *__pyx_tuple__18;
static PyObject *__pyx_tuple__20;
static PyObject *__pyx_codeobj__15;
static PyObject *__pyx_codeobj__17;
static PyObject *__pyx_codeobj__19;

/* "_hydra.pyx":34
 *     void MurmurHash3_x64_128 (void * key, int len, unsigned int seed, void * out)
 * 
 * def hash(key, int seed=0):             # <<<<<<<<<<<<<<
 *     """ This function hashes a string using the Murmur3 hash algorithm"""
 *     cdef long result[2]
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_1hash(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6_hydra_hash[] = " This function hashes a string using the Murmur3 hash algorithm";
static PyMethodDef __pyx_mdef_6_hydra_1hash = {"hash", (PyCFunction)__pyx_pw_6_hydra_1hash, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6_hydra_hash};
static PyObject *__pyx_pw_6_hydra_1hash(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_key = 0;
  int __pyx_v_seed;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hash (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_key,&__pyx_n_s_seed,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_key)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_seed);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "hash") < 0)) __PYX_ERR(0, 34, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_key = values[0];
    if (values[1]) {
      __pyx_v_seed = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_seed == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 34, __pyx_L3_error)
    } else {
      __pyx_v_seed = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("hash", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 34, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_hydra.hash", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6_hydra_hash(__pyx_self, __pyx_v_key, __pyx_v_seed);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_hash(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_key, int __pyx_v_seed) {
  long __pyx_v_result[2];
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  char *__pyx_t_5;
  Py_ssize_t __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  __Pyx_RefNannySetupContext("hash", 0);
  __Pyx_INCREF(__pyx_v_key);

  /* "_hydra.pyx":37
 *     """ This function hashes a string using the Murmur3 hash algorithm"""
 *     cdef long result[2]
 *     if isinstance(key, unicode):             # <<<<<<<<<<<<<<
 *         key = key.encode('utf8')
 *     MurmurHash3_x64_128(<char*>key, len(key), seed, result)
 */
  __pyx_t_1 = PyUnicode_Check(__pyx_v_key); 
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "_hydra.pyx":38
 *     cdef long result[2]
 *     if isinstance(key, unicode):
 *         key = key.encode('utf8')             # <<<<<<<<<<<<<<
 *     MurmurHash3_x64_128(<char*>key, len(key), seed, result)
 *     return long(result[0]) << 64 | (long(result[1]) & 0xFFFFFFFFFFFFFFFF)
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_key, __pyx_n_s_encode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 38, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 38, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF_SET(__pyx_v_key, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "_hydra.pyx":37
 *     """ This function hashes a string using the Murmur3 hash algorithm"""
 *     cdef long result[2]
 *     if isinstance(key, unicode):             # <<<<<<<<<<<<<<
 *         key = key.encode('utf8')
 *     MurmurHash3_x64_128(<char*>key, len(key), seed, result)
 */
  }

  /* "_hydra.pyx":39
 *     if isinstance(key, unicode):
 *         key = key.encode('utf8')
 *     MurmurHash3_x64_128(<char*>key, len(key), seed, result)             # <<<<<<<<<<<<<<
 *     return long(result[0]) << 64 | (long(result[1]) & 0xFFFFFFFFFFFFFFFF)
 * 
 */
  __pyx_t_5 = __Pyx_PyObject_AsString(__pyx_v_key); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 39, __pyx_L1_error)
  __pyx_t_6 = PyObject_Length(__pyx_v_key); if (unlikely(__pyx_t_6 == -1)) __PYX_ERR(0, 39, __pyx_L1_error)
  MurmurHash3_x64_128(((char *)__pyx_t_5), __pyx_t_6, __pyx_v_seed, __pyx_v_result);

  /* "_hydra.pyx":40
 *         key = key.encode('utf8')
 *     MurmurHash3_x64_128(<char*>key, len(key), seed, result)
 *     return long(result[0]) << 64 | (long(result[1]) & 0xFFFFFFFFFFFFFFFF)             # <<<<<<<<<<<<<<
 * 
 * cdef class MMapBitField:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_4 = __Pyx_PyInt_From_long((__pyx_v_result[0])); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 40, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
  __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)(&PyLong_Type)), __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = PyNumber_Lshift(__pyx_t_4, __pyx_int_64); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 40, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyInt_From_long((__pyx_v_result[1])); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 40, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4);
  __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)(&PyLong_Type)), __pyx_t_7, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_7 = PyNumber_And(__pyx_t_4, __pyx_int_18446744073709551615); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 40, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = PyNumber_Or(__pyx_t_3, __pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "_hydra.pyx":34
 *     void MurmurHash3_x64_128 (void * key, int len, unsigned int seed, void * out)
 * 
 * def hash(key, int seed=0):             # <<<<<<<<<<<<<<
 *     """ This function hashes a string using the Murmur3 hash algorithm"""
 *     cdef long result[2]
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("_hydra.hash", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_key);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":51
 *     cdef int _fdatasync_on_close
 * 
 *     def __cinit__(self, filename, long bitsize, int read_only, int want_lock=False, int fdatasync_on_close=True):             # <<<<<<<<<<<<<<
 *         if isinstance(filename, unicode):
 *             filename = filename.encode('utf8')
 */

/* Python wrapper */
static int __pyx_pw_6_hydra_12MMapBitField_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_6_hydra_12MMapBitField_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_filename = 0;
  long __pyx_v_bitsize;
  int __pyx_v_read_only;
  int __pyx_v_want_lock;
  int __pyx_v_fdatasync_on_close;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_filename,&__pyx_n_s_bitsize,&__pyx_n_s_read_only,&__pyx_n_s_want_lock,&__pyx_n_s_fdatasync_on_close,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_filename)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_bitsize)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 1); __PYX_ERR(0, 51, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_read_only)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 2); __PYX_ERR(0, 51, __pyx_L3_error)
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_want_lock);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_fdatasync_on_close);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 51, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_filename = values[0];
    __pyx_v_bitsize = __Pyx_PyInt_As_long(values[1]); if (unlikely((__pyx_v_bitsize == (long)-1) && PyErr_Occurred())) __PYX_ERR(0, 51, __pyx_L3_error)
    __pyx_v_read_only = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_read_only == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 51, __pyx_L3_error)
    if (values[3]) {
      __pyx_v_want_lock = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_want_lock == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 51, __pyx_L3_error)
    } else {
      __pyx_v_want_lock = ((int)0);
    }
    if (values[4]) {
      __pyx_v_fdatasync_on_close = __Pyx_PyInt_As_int(values[4]); if (unlikely((__pyx_v_fdatasync_on_close == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 51, __pyx_L3_error)
    } else {
      __pyx_v_fdatasync_on_close = ((int)1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 51, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_hydra.MMapBitField.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6_hydra_12MMapBitField___cinit__(((struct __pyx_obj_6_hydra_MMapBitField *)__pyx_v_self), __pyx_v_filename, __pyx_v_bitsize, __pyx_v_read_only, __pyx_v_want_lock, __pyx_v_fdatasync_on_close);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_6_hydra_12MMapBitField___cinit__(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, PyObject *__pyx_v_filename, long __pyx_v_bitsize, int __pyx_v_read_only, int __pyx_v_want_lock, int __pyx_v_fdatasync_on_close) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  char *__pyx_t_5;
  struct __pyx_opt_args_6_hydra_12MMapBitField_open_ro_buffer __pyx_t_6;
  struct __pyx_opt_args_6_hydra_12MMapBitField_open_rw_buffer __pyx_t_7;
  __Pyx_RefNannySetupContext("__cinit__", 0);
  __Pyx_INCREF(__pyx_v_filename);

  /* "_hydra.pyx":52
 * 
 *     def __cinit__(self, filename, long bitsize, int read_only, int want_lock=False, int fdatasync_on_close=True):
 *         if isinstance(filename, unicode):             # <<<<<<<<<<<<<<
 *             filename = filename.encode('utf8')
 *         self._filename = filename
 */
  __pyx_t_1 = PyUnicode_Check(__pyx_v_filename); 
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "_hydra.pyx":53
 *     def __cinit__(self, filename, long bitsize, int read_only, int want_lock=False, int fdatasync_on_close=True):
 *         if isinstance(filename, unicode):
 *             filename = filename.encode('utf8')             # <<<<<<<<<<<<<<
 *         self._filename = filename
 *         self._bitsize = bitsize
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_filename, __pyx_n_s_encode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 53, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 53, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF_SET(__pyx_v_filename, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "_hydra.pyx":52
 * 
 *     def __cinit__(self, filename, long bitsize, int read_only, int want_lock=False, int fdatasync_on_close=True):
 *         if isinstance(filename, unicode):             # <<<<<<<<<<<<<<
 *             filename = filename.encode('utf8')
 *         self._filename = filename
 */
  }

  /* "_hydra.pyx":54
 *         if isinstance(filename, unicode):
 *             filename = filename.encode('utf8')
 *         self._filename = filename             # <<<<<<<<<<<<<<
 *         self._bitsize = bitsize
 *         self._bytesize = (bitsize / 8) + 2
 */
  __pyx_t_5 = __Pyx_PyObject_AsString(__pyx_v_filename); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 54, __pyx_L1_error)
  __pyx_v_self->_filename = __pyx_t_5;

  /* "_hydra.pyx":55
 *             filename = filename.encode('utf8')
 *         self._filename = filename
 *         self._bitsize = bitsize             # <<<<<<<<<<<<<<
 *         self._bytesize = (bitsize / 8) + 2
 *         self._read_only = read_only
 */
  __pyx_v_self->_bitsize = __pyx_v_bitsize;

  /* "_hydra.pyx":56
 *         self._filename = filename
 *         self._bitsize = bitsize
 *         self._bytesize = (bitsize / 8) + 2             # <<<<<<<<<<<<<<
 *         self._read_only = read_only
 *         self._fdatasync_on_close = fdatasync_on_close
 */
  __pyx_v_self->_bytesize = (__Pyx_div_long(__pyx_v_bitsize, 8) + 2);

  /* "_hydra.pyx":57
 *         self._bitsize = bitsize
 *         self._bytesize = (bitsize / 8) + 2
 *         self._read_only = read_only             # <<<<<<<<<<<<<<
 *         self._fdatasync_on_close = fdatasync_on_close
 * 
 */
  __pyx_v_self->_read_only = __pyx_v_read_only;

  /* "_hydra.pyx":58
 *         self._bytesize = (bitsize / 8) + 2
 *         self._read_only = read_only
 *         self._fdatasync_on_close = fdatasync_on_close             # <<<<<<<<<<<<<<
 * 
 *         # Now setup the file and mmap
 */
  __pyx_v_self->_fdatasync_on_close = __pyx_v_fdatasync_on_close;

  /* "_hydra.pyx":61
 * 
 *         # Now setup the file and mmap
 *         if read_only:             # <<<<<<<<<<<<<<
 *             self.open_ro_buffer(want_lock)
 *         else:
 */
  __pyx_t_2 = (__pyx_v_read_only != 0);
  if (__pyx_t_2) {

    /* "_hydra.pyx":62
 *         # Now setup the file and mmap
 *         if read_only:
 *             self.open_ro_buffer(want_lock)             # <<<<<<<<<<<<<<
 *         else:
 *             self.open_rw_buffer(want_lock)
 */
    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_want_lock); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 62, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6.__pyx_n = 1;
    __pyx_t_6.want_lock = __pyx_t_4;
    ((struct __pyx_vtabstruct_6_hydra_MMapBitField *)__pyx_v_self->__pyx_vtab)->open_ro_buffer(__pyx_v_self, &__pyx_t_6); 
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "_hydra.pyx":61
 * 
 *         # Now setup the file and mmap
 *         if read_only:             # <<<<<<<<<<<<<<
 *             self.open_ro_buffer(want_lock)
 *         else:
 */
    goto __pyx_L4;
  }

  /* "_hydra.pyx":64
 *             self.open_ro_buffer(want_lock)
 *         else:
 *             self.open_rw_buffer(want_lock)             # <<<<<<<<<<<<<<
 * 
 *     cdef void open_rw_buffer(self, want_lock=False):
 */
  /*else*/ {
    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_want_lock); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 64, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7.__pyx_n = 1;
    __pyx_t_7.want_lock = __pyx_t_4;
    ((struct __pyx_vtabstruct_6_hydra_MMapBitField *)__pyx_v_self->__pyx_vtab)->open_rw_buffer(__pyx_v_self, &__pyx_t_7); 
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }
  __pyx_L4:;

  /* "_hydra.pyx":51
 *     cdef int _fdatasync_on_close
 * 
 *     def __cinit__(self, filename, long bitsize, int read_only, int want_lock=False, int fdatasync_on_close=True):             # <<<<<<<<<<<<<<
 *         if isinstance(filename, unicode):
 *             filename = filename.encode('utf8')
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_hydra.MMapBitField.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_filename);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":66
 *             self.open_rw_buffer(want_lock)
 * 
 *     cdef void open_rw_buffer(self, want_lock=False):             # <<<<<<<<<<<<<<
 *         self._fd = open_mmap_file_rw(self._filename, self._bytesize)
 *         self._buffer = map_file_rw(self._fd, self._bytesize, want_lock)
 */

static void __pyx_f_6_hydra_12MMapBitField_open_rw_buffer(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, struct __pyx_opt_args_6_hydra_12MMapBitField_open_rw_buffer *__pyx_optional_args) {
  PyObject *__pyx_v_want_lock = ((PyObject *)Py_False);
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  char *__pyx_t_2;
  __Pyx_RefNannySetupContext("open_rw_buffer", 0);
  if (__pyx_optional_args) {
    if (__pyx_optional_args->__pyx_n > 0) {
      __pyx_v_want_lock = __pyx_optional_args->want_lock;
    }
  }

  /* "_hydra.pyx":67
 * 
 *     cdef void open_rw_buffer(self, want_lock=False):
 *         self._fd = open_mmap_file_rw(self._filename, self._bytesize)             # <<<<<<<<<<<<<<
 *         self._buffer = map_file_rw(self._fd, self._bytesize, want_lock)
 * 
 */
  __pyx_t_1 = open_mmap_file_rw(__pyx_v_self->_filename, __pyx_v_self->_bytesize); if (unlikely(__pyx_t_1 == -1)) __PYX_ERR(0, 67, __pyx_L1_error)
  __pyx_v_self->_fd = __pyx_t_1;

  /* "_hydra.pyx":68
 *     cdef void open_rw_buffer(self, want_lock=False):
 *         self._fd = open_mmap_file_rw(self._filename, self._bytesize)
 *         self._buffer = map_file_rw(self._fd, self._bytesize, want_lock)             # <<<<<<<<<<<<<<
 * 
 *     cdef void open_ro_buffer(self, want_lock=False):
 */
  __pyx_t_1 = __Pyx_PyInt_As_int(__pyx_v_want_lock); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 68, __pyx_L1_error)
  __pyx_t_2 = map_file_rw(__pyx_v_self->_fd, __pyx_v_self->_bytesize, __pyx_t_1); if (unlikely(__pyx_t_2 == NULL)) __PYX_ERR(0, 68, __pyx_L1_error)
  __pyx_v_self->_buffer = __pyx_t_2;

  /* "_hydra.pyx":66
 *             self.open_rw_buffer(want_lock)
 * 
 *     cdef void open_rw_buffer(self, want_lock=False):             # <<<<<<<<<<<<<<
 *         self._fd = open_mmap_file_rw(self._filename, self._bytesize)
 *         self._buffer = map_file_rw(self._fd, self._bytesize, want_lock)
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("_hydra.MMapBitField.open_rw_buffer", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
}

/* "_hydra.pyx":70
 *         self._buffer = map_file_rw(self._fd, self._bytesize, want_lock)
 * 
 *     cdef void open_ro_buffer(self, want_lock=False):             # <<<<<<<<<<<<<<
 *         self._fd = open_mmap_file_ro(self._filename)
 *         self._buffer = map_file_ro(self._fd, self._bytesize, want_lock)
 */

static void __pyx_f_6_hydra_12MMapBitField_open_ro_buffer(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, struct __pyx_opt_args_6_hydra_12MMapBitField_open_ro_buffer *__pyx_optional_args) {
  PyObject *__pyx_v_want_lock = ((PyObject *)Py_False);
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  char *__pyx_t_2;
  __Pyx_RefNannySetupContext("open_ro_buffer", 0);
  if (__pyx_optional_args) {
    if (__pyx_optional_args->__pyx_n > 0) {
      __pyx_v_want_lock = __pyx_optional_args->want_lock;
    }
  }

  /* "_hydra.pyx":71
 * 
 *     cdef void open_ro_buffer(self, want_lock=False):
 *         self._fd = open_mmap_file_ro(self._filename)             # <<<<<<<<<<<<<<
 *         self._buffer = map_file_ro(self._fd, self._bytesize, want_lock)
 * 
 */
  __pyx_t_1 = open_mmap_file_ro(__pyx_v_self->_filename); if (unlikely(__pyx_t_1 == -1)) __PYX_ERR(0, 71, __pyx_L1_error)
  __pyx_v_self->_fd = __pyx_t_1;

  /* "_hydra.pyx":72
 *     cdef void open_ro_buffer(self, want_lock=False):
 *         self._fd = open_mmap_file_ro(self._filename)
 *         self._buffer = map_file_ro(self._fd, self._bytesize, want_lock)             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_t_1 = __Pyx_PyInt_As_int(__pyx_v_want_lock); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 72, __pyx_L1_error)
  __pyx_t_2 = map_file_ro(__pyx_v_self->_fd, __pyx_v_self->_bytesize, __pyx_t_1); if (unlikely(__pyx_t_2 == NULL)) __PYX_ERR(0, 72, __pyx_L1_error)
  __pyx_v_self->_buffer = __pyx_t_2;

  /* "_hydra.pyx":70
 *         self._buffer = map_file_rw(self._fd, self._bytesize, want_lock)
 * 
 *     cdef void open_ro_buffer(self, want_lock=False):             # <<<<<<<<<<<<<<
 *         self._fd = open_mmap_file_ro(self._filename)
 *         self._buffer = map_file_ro(self._fd, self._bytesize, want_lock)
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("_hydra.MMapBitField.open_ro_buffer", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
}

/* "_hydra.pyx":74
 *         self._buffer = map_file_ro(self._fd, self._bytesize, want_lock)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         self.close()
 * 
 */

/* Python wrapper */
static void __pyx_pw_6_hydra_12MMapBitField_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_6_hydra_12MMapBitField_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_6_hydra_12MMapBitField_2__dealloc__(((struct __pyx_obj_6_hydra_MMapBitField *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_6_hydra_12MMapBitField_2__dealloc__(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "_hydra.pyx":75
 * 
 *     def __dealloc__(self):
 *         self.close()             # <<<<<<<<<<<<<<
 * 
 *     cpdef close(self):
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_6_hydra_MMapBitField *)__pyx_v_self->__pyx_vtab)->close(__pyx_v_self, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 75, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_hydra.pyx":74
 *         self._buffer = map_file_ro(self._fd, self._bytesize, want_lock)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         self.close()
 * 
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_WriteUnraisable("_hydra.MMapBitField.__dealloc__", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
}

/* "_hydra.pyx":77
 *         self.close()
 * 
 *     cpdef close(self):             # <<<<<<<<<<<<<<
 *         if self._fd >= 0 and self._buffer:
 *             if not self._read_only and self._fdatasync_on_close:
 */

static PyObject *__pyx_pw_6_hydra_12MMapBitField_5close(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_6_hydra_12MMapBitField_close(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  __Pyx_RefNannySetupContext("close", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_close); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 77, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_6_hydra_12MMapBitField_5close)) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 77, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 77, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "_hydra.pyx":78
 * 
 *     cpdef close(self):
 *         if self._fd >= 0 and self._buffer:             # <<<<<<<<<<<<<<
 *             if not self._read_only and self._fdatasync_on_close:
 *                 flush_to_disk(self._fd)
 */
  __pyx_t_6 = ((__pyx_v_self->_fd >= 0) != 0);
  if (__pyx_t_6) {
  } else {
    __pyx_t_5 = __pyx_t_6;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_6 = (__pyx_v_self->_buffer != 0);
  __pyx_t_5 = __pyx_t_6;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_5) {

    /* "_hydra.pyx":79
 *     cpdef close(self):
 *         if self._fd >= 0 and self._buffer:
 *             if not self._read_only and self._fdatasync_on_close:             # <<<<<<<<<<<<<<
 *                 flush_to_disk(self._fd)
 *             unmap_file(self._buffer, self._bytesize)
 */
    __pyx_t_6 = ((!(__pyx_v_self->_read_only != 0)) != 0);
    if (__pyx_t_6) {
    } else {
      __pyx_t_5 = __pyx_t_6;
      goto __pyx_L7_bool_binop_done;
    }
    __pyx_t_6 = (__pyx_v_self->_fdatasync_on_close != 0);
    __pyx_t_5 = __pyx_t_6;
    __pyx_L7_bool_binop_done:;
    if (__pyx_t_5) {

      /* "_hydra.pyx":80
 *         if self._fd >= 0 and self._buffer:
 *             if not self._read_only and self._fdatasync_on_close:
 *                 flush_to_disk(self._fd)             # <<<<<<<<<<<<<<
 *             unmap_file(self._buffer, self._bytesize)
 *             close_file(self._fd)
 */
      __pyx_t_7 = flush_to_disk(__pyx_v_self->_fd); if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 80, __pyx_L1_error)

      /* "_hydra.pyx":79
 *     cpdef close(self):
 *         if self._fd >= 0 and self._buffer:
 *             if not self._read_only and self._fdatasync_on_close:             # <<<<<<<<<<<<<<
 *                 flush_to_disk(self._fd)
 *             unmap_file(self._buffer, self._bytesize)
 */
    }

    /* "_hydra.pyx":81
 *             if not self._read_only and self._fdatasync_on_close:
 *                 flush_to_disk(self._fd)
 *             unmap_file(self._buffer, self._bytesize)             # <<<<<<<<<<<<<<
 *             close_file(self._fd)
 *             self._fd = -1
 */
    __pyx_t_7 = unmap_file(__pyx_v_self->_buffer, __pyx_v_self->_bytesize); if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 81, __pyx_L1_error)

    /* "_hydra.pyx":82
 *                 flush_to_disk(self._fd)
 *             unmap_file(self._buffer, self._bytesize)
 *             close_file(self._fd)             # <<<<<<<<<<<<<<
 *             self._fd = -1
 *             self._buffer = NULL
 */
    __pyx_t_7 = close_file(__pyx_v_self->_fd); if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 82, __pyx_L1_error)

    /* "_hydra.pyx":83
 *             unmap_file(self._buffer, self._bytesize)
 *             close_file(self._fd)
 *             self._fd = -1             # <<<<<<<<<<<<<<
 *             self._buffer = NULL
 * 
 */
    __pyx_v_self->_fd = -1;

    /* "_hydra.pyx":84
 *             close_file(self._fd)
 *             self._fd = -1
 *             self._buffer = NULL             # <<<<<<<<<<<<<<
 * 
 *     cpdef fdatasync(self):
 */
    __pyx_v_self->_buffer = NULL;

    /* "_hydra.pyx":78
 * 
 *     cpdef close(self):
 *         if self._fd >= 0 and self._buffer:             # <<<<<<<<<<<<<<
 *             if not self._read_only and self._fdatasync_on_close:
 *                 flush_to_disk(self._fd)
 */
  }

  /* "_hydra.pyx":77
 *         self.close()
 * 
 *     cpdef close(self):             # <<<<<<<<<<<<<<
 *         if self._fd >= 0 and self._buffer:
 *             if not self._read_only and self._fdatasync_on_close:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_hydra.MMapBitField.close", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_12MMapBitField_5close(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_6_hydra_12MMapBitField_5close(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("close (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_12MMapBitField_4close(((struct __pyx_obj_6_hydra_MMapBitField *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_12MMapBitField_4close(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("close", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_6_hydra_12MMapBitField_close(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 77, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.MMapBitField.close", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":86
 *             self._buffer = NULL
 * 
 *     cpdef fdatasync(self):             # <<<<<<<<<<<<<<
 *         """ Flush everything to disk """
 *         if self._fd < 0 or not self._buffer:
 */

static PyObject *__pyx_pw_6_hydra_12MMapBitField_7fdatasync(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_6_hydra_12MMapBitField_fdatasync(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  __Pyx_RefNannySetupContext("fdatasync", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_fdatasync); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 86, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_6_hydra_12MMapBitField_7fdatasync)) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 86, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 86, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "_hydra.pyx":88
 *     cpdef fdatasync(self):
 *         """ Flush everything to disk """
 *         if self._fd < 0 or not self._buffer:             # <<<<<<<<<<<<<<
 *             raise ValueError('I/O operation on closed file')
 * 
 */
  __pyx_t_6 = ((__pyx_v_self->_fd < 0) != 0);
  if (!__pyx_t_6) {
  } else {
    __pyx_t_5 = __pyx_t_6;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_6 = ((!(__pyx_v_self->_buffer != 0)) != 0);
  __pyx_t_5 = __pyx_t_6;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_5) {

    /* "_hydra.pyx":89
 *         """ Flush everything to disk """
 *         if self._fd < 0 or not self._buffer:
 *             raise ValueError('I/O operation on closed file')             # <<<<<<<<<<<<<<
 * 
 *         if self._read_only:
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 89, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 89, __pyx_L1_error)

    /* "_hydra.pyx":88
 *     cpdef fdatasync(self):
 *         """ Flush everything to disk """
 *         if self._fd < 0 or not self._buffer:             # <<<<<<<<<<<<<<
 *             raise ValueError('I/O operation on closed file')
 * 
 */
  }

  /* "_hydra.pyx":91
 *             raise ValueError('I/O operation on closed file')
 * 
 *         if self._read_only:             # <<<<<<<<<<<<<<
 *             raise ValueError('bit field is read only')
 * 
 */
  __pyx_t_5 = (__pyx_v_self->_read_only != 0);
  if (__pyx_t_5) {

    /* "_hydra.pyx":92
 * 
 *         if self._read_only:
 *             raise ValueError('bit field is read only')             # <<<<<<<<<<<<<<
 * 
 *         flush_to_disk(self._fd)
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 92, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 92, __pyx_L1_error)

    /* "_hydra.pyx":91
 *             raise ValueError('I/O operation on closed file')
 * 
 *         if self._read_only:             # <<<<<<<<<<<<<<
 *             raise ValueError('bit field is read only')
 * 
 */
  }

  /* "_hydra.pyx":94
 *             raise ValueError('bit field is read only')
 * 
 *         flush_to_disk(self._fd)             # <<<<<<<<<<<<<<
 * 
 *     def __setitem__(self, size_t key, int value):
 */
  __pyx_t_7 = flush_to_disk(__pyx_v_self->_fd); if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 94, __pyx_L1_error)

  /* "_hydra.pyx":86
 *             self._buffer = NULL
 * 
 *     cpdef fdatasync(self):             # <<<<<<<<<<<<<<
 *         """ Flush everything to disk """
 *         if self._fd < 0 or not self._buffer:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_hydra.MMapBitField.fdatasync", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_12MMapBitField_7fdatasync(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_6_hydra_12MMapBitField_6fdatasync[] = " Flush everything to disk ";
static PyObject *__pyx_pw_6_hydra_12MMapBitField_7fdatasync(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fdatasync (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_12MMapBitField_6fdatasync(((struct __pyx_obj_6_hydra_MMapBitField *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_12MMapBitField_6fdatasync(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("fdatasync", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_6_hydra_12MMapBitField_fdatasync(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 86, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.MMapBitField.fdatasync", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":96
 *         flush_to_disk(self._fd)
 * 
 *     def __setitem__(self, size_t key, int value):             # <<<<<<<<<<<<<<
 *         cdef size_t byte_offset = key / 8
 *         cdef char bitmask
 */

/* Python wrapper */
static int __pyx_pw_6_hydra_12MMapBitField_9__setitem__(PyObject *__pyx_v_self, PyObject *__pyx_arg_key, PyObject *__pyx_arg_value); /*proto*/
static int __pyx_pw_6_hydra_12MMapBitField_9__setitem__(PyObject *__pyx_v_self, PyObject *__pyx_arg_key, PyObject *__pyx_arg_value) {
  size_t __pyx_v_key;
  int __pyx_v_value;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setitem__ (wrapper)", 0);
  assert(__pyx_arg_key); {
    __pyx_v_key = __Pyx_PyInt_As_size_t(__pyx_arg_key); if (unlikely((__pyx_v_key == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 96, __pyx_L3_error)
  }
  assert(__pyx_arg_value); {
    __pyx_v_value = __Pyx_PyInt_As_int(__pyx_arg_value); if (unlikely((__pyx_v_value == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 96, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("_hydra.MMapBitField.__setitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6_hydra_12MMapBitField_8__setitem__(((struct __pyx_obj_6_hydra_MMapBitField *)__pyx_v_self), ((size_t)__pyx_v_key), ((int)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_6_hydra_12MMapBitField_8__setitem__(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, size_t __pyx_v_key, int __pyx_v_value) {
  size_t __pyx_v_byte_offset;
  char __pyx_v_bitmask;
  char __pyx_v_bitval;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("__setitem__", 0);

  /* "_hydra.pyx":97
 * 
 *     def __setitem__(self, size_t key, int value):
 *         cdef size_t byte_offset = key / 8             # <<<<<<<<<<<<<<
 *         cdef char bitmask
 *         cdef char bitval
 */
  __pyx_v_byte_offset = (__pyx_v_key / 8);

  /* "_hydra.pyx":101
 *         cdef char bitval
 * 
 *         if self._fd < 0 or not self._buffer:             # <<<<<<<<<<<<<<
 *             raise ValueError('I/O operation on closed file')
 * 
 */
  __pyx_t_2 = ((__pyx_v_self->_fd < 0) != 0);
  if (!__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_2 = ((!(__pyx_v_self->_buffer != 0)) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_1) {

    /* "_hydra.pyx":102
 * 
 *         if self._fd < 0 or not self._buffer:
 *             raise ValueError('I/O operation on closed file')             # <<<<<<<<<<<<<<
 * 
 *         if self._read_only:
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 102, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 102, __pyx_L1_error)

    /* "_hydra.pyx":101
 *         cdef char bitval
 * 
 *         if self._fd < 0 or not self._buffer:             # <<<<<<<<<<<<<<
 *             raise ValueError('I/O operation on closed file')
 * 
 */
  }

  /* "_hydra.pyx":104
 *             raise ValueError('I/O operation on closed file')
 * 
 *         if self._read_only:             # <<<<<<<<<<<<<<
 *             raise ValueError('bit field is read only')
 * 
 */
  __pyx_t_1 = (__pyx_v_self->_read_only != 0);
  if (__pyx_t_1) {

    /* "_hydra.pyx":105
 * 
 *         if self._read_only:
 *             raise ValueError('bit field is read only')             # <<<<<<<<<<<<<<
 * 
 *         bitmask = 2 ** (key % 8)
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 105, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 105, __pyx_L1_error)

    /* "_hydra.pyx":104
 *             raise ValueError('I/O operation on closed file')
 * 
 *         if self._read_only:             # <<<<<<<<<<<<<<
 *             raise ValueError('bit field is read only')
 * 
 */
  }

  /* "_hydra.pyx":107
 *             raise ValueError('bit field is read only')
 * 
 *         bitmask = 2 ** (key % 8)             # <<<<<<<<<<<<<<
 *         if value:
 *             bitval = self._buffer[byte_offset] | bitmask
 */
  __pyx_v_bitmask = __Pyx_pow_size_t(2, (__pyx_v_key % 8));

  /* "_hydra.pyx":108
 * 
 *         bitmask = 2 ** (key % 8)
 *         if value:             # <<<<<<<<<<<<<<
 *             bitval = self._buffer[byte_offset] | bitmask
 *         else:
 */
  __pyx_t_1 = (__pyx_v_value != 0);
  if (__pyx_t_1) {

    /* "_hydra.pyx":109
 *         bitmask = 2 ** (key % 8)
 *         if value:
 *             bitval = self._buffer[byte_offset] | bitmask             # <<<<<<<<<<<<<<
 *         else:
 *             bitval = self._buffer[byte_offset] & ~bitmask
 */
    __pyx_v_bitval = ((__pyx_v_self->_buffer[__pyx_v_byte_offset]) | __pyx_v_bitmask);

    /* "_hydra.pyx":108
 * 
 *         bitmask = 2 ** (key % 8)
 *         if value:             # <<<<<<<<<<<<<<
 *             bitval = self._buffer[byte_offset] | bitmask
 *         else:
 */
    goto __pyx_L7;
  }

  /* "_hydra.pyx":111
 *             bitval = self._buffer[byte_offset] | bitmask
 *         else:
 *             bitval = self._buffer[byte_offset] & ~bitmask             # <<<<<<<<<<<<<<
 *         if bitval != self._buffer[byte_offset]:
 *             self._buffer[byte_offset] = bitval
 */
  /*else*/ {
    __pyx_v_bitval = ((__pyx_v_self->_buffer[__pyx_v_byte_offset]) & (~__pyx_v_bitmask));
  }
  __pyx_L7:;

  /* "_hydra.pyx":112
 *         else:
 *             bitval = self._buffer[byte_offset] & ~bitmask
 *         if bitval != self._buffer[byte_offset]:             # <<<<<<<<<<<<<<
 *             self._buffer[byte_offset] = bitval
 * 
 */
  __pyx_t_1 = ((__pyx_v_bitval != (__pyx_v_self->_buffer[__pyx_v_byte_offset])) != 0);
  if (__pyx_t_1) {

    /* "_hydra.pyx":113
 *             bitval = self._buffer[byte_offset] & ~bitmask
 *         if bitval != self._buffer[byte_offset]:
 *             self._buffer[byte_offset] = bitval             # <<<<<<<<<<<<<<
 * 
 *     def __getitem__(self, size_t key):
 */
    (__pyx_v_self->_buffer[__pyx_v_byte_offset]) = __pyx_v_bitval;

    /* "_hydra.pyx":112
 *         else:
 *             bitval = self._buffer[byte_offset] & ~bitmask
 *         if bitval != self._buffer[byte_offset]:             # <<<<<<<<<<<<<<
 *             self._buffer[byte_offset] = bitval
 * 
 */
  }

  /* "_hydra.pyx":96
 *         flush_to_disk(self._fd)
 * 
 *     def __setitem__(self, size_t key, int value):             # <<<<<<<<<<<<<<
 *         cdef size_t byte_offset = key / 8
 *         cdef char bitmask
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("_hydra.MMapBitField.__setitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":115
 *             self._buffer[byte_offset] = bitval
 * 
 *     def __getitem__(self, size_t key):             # <<<<<<<<<<<<<<
 *         cdef size_t byte_offset = key / 8
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_12MMapBitField_11__getitem__(PyObject *__pyx_v_self, PyObject *__pyx_arg_key); /*proto*/
static PyObject *__pyx_pw_6_hydra_12MMapBitField_11__getitem__(PyObject *__pyx_v_self, PyObject *__pyx_arg_key) {
  size_t __pyx_v_key;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__getitem__ (wrapper)", 0);
  assert(__pyx_arg_key); {
    __pyx_v_key = __Pyx_PyInt_As_size_t(__pyx_arg_key); if (unlikely((__pyx_v_key == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 115, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("_hydra.MMapBitField.__getitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6_hydra_12MMapBitField_10__getitem__(((struct __pyx_obj_6_hydra_MMapBitField *)__pyx_v_self), ((size_t)__pyx_v_key));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_12MMapBitField_10__getitem__(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, size_t __pyx_v_key) {
  size_t __pyx_v_byte_offset;
  char __pyx_v_old_bitmask;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("__getitem__", 0);

  /* "_hydra.pyx":116
 * 
 *     def __getitem__(self, size_t key):
 *         cdef size_t byte_offset = key / 8             # <<<<<<<<<<<<<<
 * 
 *         if self._fd < 0 or not self._buffer:
 */
  __pyx_v_byte_offset = (__pyx_v_key / 8);

  /* "_hydra.pyx":118
 *         cdef size_t byte_offset = key / 8
 * 
 *         if self._fd < 0 or not self._buffer:             # <<<<<<<<<<<<<<
 *             raise ValueError('I/O operation on closed file')
 * 
 */
  __pyx_t_2 = ((__pyx_v_self->_fd < 0) != 0);
  if (!__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_2 = ((!(__pyx_v_self->_buffer != 0)) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_1) {

    /* "_hydra.pyx":119
 * 
 *         if self._fd < 0 or not self._buffer:
 *             raise ValueError('I/O operation on closed file')             # <<<<<<<<<<<<<<
 * 
 *         cdef char old_bitmask = self._buffer[byte_offset]
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 119, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 119, __pyx_L1_error)

    /* "_hydra.pyx":118
 *         cdef size_t byte_offset = key / 8
 * 
 *         if self._fd < 0 or not self._buffer:             # <<<<<<<<<<<<<<
 *             raise ValueError('I/O operation on closed file')
 * 
 */
  }

  /* "_hydra.pyx":121
 *             raise ValueError('I/O operation on closed file')
 * 
 *         cdef char old_bitmask = self._buffer[byte_offset]             # <<<<<<<<<<<<<<
 *         return <int> (old_bitmask & <char> (2 ** (key % 8)))
 * 
 */
  __pyx_v_old_bitmask = (__pyx_v_self->_buffer[__pyx_v_byte_offset]);

  /* "_hydra.pyx":122
 * 
 *         cdef char old_bitmask = self._buffer[byte_offset]
 *         return <int> (old_bitmask & <char> (2 ** (key % 8)))             # <<<<<<<<<<<<<<
 * 
 *     def __iter__(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyInt_From_int(((int)(__pyx_v_old_bitmask & ((char)__Pyx_pow_size_t(2, (__pyx_v_key % 8)))))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 122, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "_hydra.pyx":115
 *             self._buffer[byte_offset] = bitval
 * 
 *     def __getitem__(self, size_t key):             # <<<<<<<<<<<<<<
 *         cdef size_t byte_offset = key / 8
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("_hydra.MMapBitField.__getitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":124
 *         return <int> (old_bitmask & <char> (2 ** (key % 8)))
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         if self._fd < 0 or not self._buffer:
 *             raise ValueError('I/O operation on closed file')
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_12MMapBitField_13__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_6_hydra_12MMapBitField_13__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_12MMapBitField_12__iter__(((struct __pyx_obj_6_hydra_MMapBitField *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_12MMapBitField_12__iter__(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("__iter__", 0);

  /* "_hydra.pyx":125
 * 
 *     def __iter__(self):
 *         if self._fd < 0 or not self._buffer:             # <<<<<<<<<<<<<<
 *             raise ValueError('I/O operation on closed file')
 * 
 */
  __pyx_t_2 = ((__pyx_v_self->_fd < 0) != 0);
  if (!__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_2 = ((!(__pyx_v_self->_buffer != 0)) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_1) {

    /* "_hydra.pyx":126
 *     def __iter__(self):
 *         if self._fd < 0 or not self._buffer:
 *             raise ValueError('I/O operation on closed file')             # <<<<<<<<<<<<<<
 * 
 *         return MMapIter(self)
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 126, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 126, __pyx_L1_error)

    /* "_hydra.pyx":125
 * 
 *     def __iter__(self):
 *         if self._fd < 0 or not self._buffer:             # <<<<<<<<<<<<<<
 *             raise ValueError('I/O operation on closed file')
 * 
 */
  }

  /* "_hydra.pyx":128
 *             raise ValueError('I/O operation on closed file')
 * 
 *         return MMapIter(self)             # <<<<<<<<<<<<<<
 * 
 *     def __len__(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 128, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_self));
  __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_6_hydra_MMapIter), __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 128, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "_hydra.pyx":124
 *         return <int> (old_bitmask & <char> (2 ** (key % 8)))
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         if self._fd < 0 or not self._buffer:
 *             raise ValueError('I/O operation on closed file')
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_hydra.MMapBitField.__iter__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":130
 *         return MMapIter(self)
 * 
 *     def __len__(self):             # <<<<<<<<<<<<<<
 *         return self.size()
 * 
 */

/* Python wrapper */
static Py_ssize_t __pyx_pw_6_hydra_12MMapBitField_15__len__(PyObject *__pyx_v_self); /*proto*/
static Py_ssize_t __pyx_pw_6_hydra_12MMapBitField_15__len__(PyObject *__pyx_v_self) {
  Py_ssize_t __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__len__ (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_12MMapBitField_14__len__(((struct __pyx_obj_6_hydra_MMapBitField *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static Py_ssize_t __pyx_pf_6_hydra_12MMapBitField_14__len__(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self) {
  Py_ssize_t __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  __Pyx_RefNannySetupContext("__len__", 0);

  /* "_hydra.pyx":131
 * 
 *     def __len__(self):
 *         return self.size()             # <<<<<<<<<<<<<<
 * 
 *     cpdef size(self):
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_6_hydra_MMapBitField *)__pyx_v_self->__pyx_vtab)->size(__pyx_v_self, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 131, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_2 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 131, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  goto __pyx_L0;

  /* "_hydra.pyx":130
 *         return MMapIter(self)
 * 
 *     def __len__(self):             # <<<<<<<<<<<<<<
 *         return self.size()
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.MMapBitField.__len__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":133
 *         return self.size()
 * 
 *     cpdef size(self):             # <<<<<<<<<<<<<<
 *         if self._fd < 0 or not self._buffer:
 *             raise ValueError('I/O operation on closed file')
 */

static PyObject *__pyx_pw_6_hydra_12MMapBitField_17size(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_6_hydra_12MMapBitField_size(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  __Pyx_RefNannySetupContext("size", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 133, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_6_hydra_12MMapBitField_17size)) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 133, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 133, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "_hydra.pyx":134
 * 
 *     cpdef size(self):
 *         if self._fd < 0 or not self._buffer:             # <<<<<<<<<<<<<<
 *             raise ValueError('I/O operation on closed file')
 * 
 */
  __pyx_t_6 = ((__pyx_v_self->_fd < 0) != 0);
  if (!__pyx_t_6) {
  } else {
    __pyx_t_5 = __pyx_t_6;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_6 = ((!(__pyx_v_self->_buffer != 0)) != 0);
  __pyx_t_5 = __pyx_t_6;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_5) {

    /* "_hydra.pyx":135
 *     cpdef size(self):
 *         if self._fd < 0 or not self._buffer:
 *             raise ValueError('I/O operation on closed file')             # <<<<<<<<<<<<<<
 * 
 *         return self._bitsize
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 135, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 135, __pyx_L1_error)

    /* "_hydra.pyx":134
 * 
 *     cpdef size(self):
 *         if self._fd < 0 or not self._buffer:             # <<<<<<<<<<<<<<
 *             raise ValueError('I/O operation on closed file')
 * 
 */
  }

  /* "_hydra.pyx":137
 *             raise ValueError('I/O operation on closed file')
 * 
 *         return self._bitsize             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v_self->_bitsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 137, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "_hydra.pyx":133
 *         return self.size()
 * 
 *     cpdef size(self):             # <<<<<<<<<<<<<<
 *         if self._fd < 0 or not self._buffer:
 *             raise ValueError('I/O operation on closed file')
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_hydra.MMapBitField.size", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_12MMapBitField_17size(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_6_hydra_12MMapBitField_17size(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("size (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_12MMapBitField_16size(((struct __pyx_obj_6_hydra_MMapBitField *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_12MMapBitField_16size(struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("size", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_6_hydra_12MMapBitField_size(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 133, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.MMapBitField.size", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":143
 *     cdef size_t _idx
 *     cdef MMapBitField  _bitfield
 *     def __cinit__(self, bitfield):             # <<<<<<<<<<<<<<
 *         self._bitfield = bitfield
 *         self._idx = 0
 */

/* Python wrapper */
static int __pyx_pw_6_hydra_8MMapIter_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_6_hydra_8MMapIter_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_bitfield = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_bitfield,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_bitfield)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 143, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_bitfield = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 143, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_hydra.MMapIter.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6_hydra_8MMapIter___cinit__(((struct __pyx_obj_6_hydra_MMapIter *)__pyx_v_self), __pyx_v_bitfield);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_6_hydra_8MMapIter___cinit__(struct __pyx_obj_6_hydra_MMapIter *__pyx_v_self, PyObject *__pyx_v_bitfield) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "_hydra.pyx":144
 *     cdef MMapBitField  _bitfield
 *     def __cinit__(self, bitfield):
 *         self._bitfield = bitfield             # <<<<<<<<<<<<<<
 *         self._idx = 0
 * 
 */
  if (!(likely(((__pyx_v_bitfield) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_bitfield, __pyx_ptype_6_hydra_MMapBitField))))) __PYX_ERR(0, 144, __pyx_L1_error)
  __pyx_t_1 = __pyx_v_bitfield;
  __Pyx_INCREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(__pyx_v_self->_bitfield);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->_bitfield));
  __pyx_v_self->_bitfield = ((struct __pyx_obj_6_hydra_MMapBitField *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "_hydra.pyx":145
 *     def __cinit__(self, bitfield):
 *         self._bitfield = bitfield
 *         self._idx = 0             # <<<<<<<<<<<<<<
 * 
 *     def __next__(self):
 */
  __pyx_v_self->_idx = 0;

  /* "_hydra.pyx":143
 *     cdef size_t _idx
 *     cdef MMapBitField  _bitfield
 *     def __cinit__(self, bitfield):             # <<<<<<<<<<<<<<
 *         self._bitfield = bitfield
 *         self._idx = 0
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.MMapIter.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":147
 *         self._idx = 0
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         cdef int result
 *         if self._idx < len(self._bitfield):
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_8MMapIter_3__next__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_6_hydra_8MMapIter_3__next__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__next__ (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_8MMapIter_2__next__(((struct __pyx_obj_6_hydra_MMapIter *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_8MMapIter_2__next__(struct __pyx_obj_6_hydra_MMapIter *__pyx_v_self) {
  int __pyx_v_result;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  __Pyx_RefNannySetupContext("__next__", 0);

  /* "_hydra.pyx":149
 *     def __next__(self):
 *         cdef int result
 *         if self._idx < len(self._bitfield):             # <<<<<<<<<<<<<<
 *             result = self._bitfield[self._idx]
 *             self._idx +=1
 */
  __pyx_t_1 = ((PyObject *)__pyx_v_self->_bitfield);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_t_2 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_2 == -1)) __PYX_ERR(0, 149, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = ((__pyx_v_self->_idx < __pyx_t_2) != 0);
  if (__pyx_t_3) {

    /* "_hydra.pyx":150
 *         cdef int result
 *         if self._idx < len(self._bitfield):
 *             result = self._bitfield[self._idx]             # <<<<<<<<<<<<<<
 *             self._idx +=1
 *             return result
 */
    __pyx_t_1 = __Pyx_GetItemInt(((PyObject *)__pyx_v_self->_bitfield), __pyx_v_self->_idx, size_t, 0, __Pyx_PyInt_FromSize_t, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 150, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 150, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_result = __pyx_t_4;

    /* "_hydra.pyx":151
 *         if self._idx < len(self._bitfield):
 *             result = self._bitfield[self._idx]
 *             self._idx +=1             # <<<<<<<<<<<<<<
 *             return result
 *         raise StopIteration
 */
    __pyx_v_self->_idx = (__pyx_v_self->_idx + 1);

    /* "_hydra.pyx":152
 *             result = self._bitfield[self._idx]
 *             self._idx +=1
 *             return result             # <<<<<<<<<<<<<<
 *         raise StopIteration
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_result); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 152, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "_hydra.pyx":149
 *     def __next__(self):
 *         cdef int result
 *         if self._idx < len(self._bitfield):             # <<<<<<<<<<<<<<
 *             result = self._bitfield[self._idx]
 *             self._idx +=1
 */
  }

  /* "_hydra.pyx":153
 *             self._idx +=1
 *             return result
 *         raise StopIteration             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0, 0);
  __PYX_ERR(0, 153, __pyx_L1_error)

  /* "_hydra.pyx":147
 *         self._idx = 0
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         cdef int result
 *         if self._idx < len(self._bitfield):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.MMapIter.__next__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":164
 *     """
 * 
 *     def __init__(self, k, bucketsPerElement):             # <<<<<<<<<<<<<<
 *         self.K = k
 *         self.bucketsPerElement = bucketsPerElement
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_18BloomSpecification_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_6_hydra_18BloomSpecification_1__init__ = {"__init__", (PyCFunction)__pyx_pw_6_hydra_18BloomSpecification_1__init__, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_6_hydra_18BloomSpecification_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_k = 0;
  PyObject *__pyx_v_bucketsPerElement = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_k,&__pyx_n_s_bucketsPerElement,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_k)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 1); __PYX_ERR(0, 164, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_bucketsPerElement)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 2); __PYX_ERR(0, 164, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 164, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_self = values[0];
    __pyx_v_k = values[1];
    __pyx_v_bucketsPerElement = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 164, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_hydra.BloomSpecification.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6_hydra_18BloomSpecification___init__(__pyx_self, __pyx_v_self, __pyx_v_k, __pyx_v_bucketsPerElement);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_18BloomSpecification___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_k, PyObject *__pyx_v_bucketsPerElement) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "_hydra.pyx":165
 * 
 *     def __init__(self, k, bucketsPerElement):
 *         self.K = k             # <<<<<<<<<<<<<<
 *         self.bucketsPerElement = bucketsPerElement
 * 
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_K, __pyx_v_k) < 0) __PYX_ERR(0, 165, __pyx_L1_error)

  /* "_hydra.pyx":166
 *     def __init__(self, k, bucketsPerElement):
 *         self.K = k
 *         self.bucketsPerElement = bucketsPerElement             # <<<<<<<<<<<<<<
 * 
 *     def __eq__(self, other):
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_bucketsPerElement, __pyx_v_bucketsPerElement) < 0) __PYX_ERR(0, 166, __pyx_L1_error)

  /* "_hydra.pyx":164
 *     """
 * 
 *     def __init__(self, k, bucketsPerElement):             # <<<<<<<<<<<<<<
 *         self.K = k
 *         self.bucketsPerElement = bucketsPerElement
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("_hydra.BloomSpecification.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":168
 *         self.bucketsPerElement = bucketsPerElement
 * 
 *     def __eq__(self, other):             # <<<<<<<<<<<<<<
 *         c1 = getattr(other, 'K', None) == self.K
 *         c2 = getattr(other, 'bucketsPerElement', None) == self.bucketsPerElement
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_18BloomSpecification_3__eq__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_6_hydra_18BloomSpecification_3__eq__ = {"__eq__", (PyCFunction)__pyx_pw_6_hydra_18BloomSpecification_3__eq__, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_6_hydra_18BloomSpecification_3__eq__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_other = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__eq__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_other,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_other)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__eq__", 1, 2, 2, 1); __PYX_ERR(0, 168, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__eq__") < 0)) __PYX_ERR(0, 168, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_other = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__eq__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 168, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_hydra.BloomSpecification.__eq__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6_hydra_18BloomSpecification_2__eq__(__pyx_self, __pyx_v_self, __pyx_v_other);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_18BloomSpecification_2__eq__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_other) {
  PyObject *__pyx_v_c1 = NULL;
  PyObject *__pyx_v_c2 = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  __Pyx_RefNannySetupContext("__eq__", 0);

  /* "_hydra.pyx":169
 * 
 *     def __eq__(self, other):
 *         c1 = getattr(other, 'K', None) == self.K             # <<<<<<<<<<<<<<
 *         c2 = getattr(other, 'bucketsPerElement', None) == self.bucketsPerElement
 *         return c1 and c2
 */
  __pyx_t_1 = __Pyx_GetAttr3(__pyx_v_other, __pyx_n_s_K, Py_None); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 169, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_K); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 169, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyObject_RichCompare(__pyx_t_1, __pyx_t_2, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 169, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_c1 = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "_hydra.pyx":170
 *     def __eq__(self, other):
 *         c1 = getattr(other, 'K', None) == self.K
 *         c2 = getattr(other, 'bucketsPerElement', None) == self.bucketsPerElement             # <<<<<<<<<<<<<<
 *         return c1 and c2
 * 
 */
  __pyx_t_3 = __Pyx_GetAttr3(__pyx_v_other, __pyx_n_s_bucketsPerElement, Py_None); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 170, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_bucketsPerElement); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 170, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = PyObject_RichCompare(__pyx_t_3, __pyx_t_2, Py_EQ); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 170, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_c2 = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "_hydra.pyx":171
 *         c1 = getattr(other, 'K', None) == self.K
 *         c2 = getattr(other, 'bucketsPerElement', None) == self.bucketsPerElement
 *         return c1 and c2             # <<<<<<<<<<<<<<
 * 
 * cdef class BloomCalculations:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_c1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 171, __pyx_L1_error)
  if (__pyx_t_4) {
  } else {
    __Pyx_INCREF(__pyx_v_c1);
    __pyx_t_1 = __pyx_v_c1;
    goto __pyx_L3_bool_binop_done;
  }
  __Pyx_INCREF(__pyx_v_c2);
  __pyx_t_1 = __pyx_v_c2;
  __pyx_L3_bool_binop_done:;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "_hydra.pyx":168
 *         self.bucketsPerElement = bucketsPerElement
 * 
 *     def __eq__(self, other):             # <<<<<<<<<<<<<<
 *         c1 = getattr(other, 'K', None) == self.K
 *         c2 = getattr(other, 'bucketsPerElement', None) == self.bucketsPerElement
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("_hydra.BloomSpecification.__eq__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_c1);
  __Pyx_XDECREF(__pyx_v_c2);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":207
 * 
 *     @classmethod
 *     def computeBloomSpec1(cls, bucketsPerElement):             # <<<<<<<<<<<<<<
 *         """
 *         Given the number of buckets that can be used per element, return a
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_17BloomCalculations_1computeBloomSpec1(PyObject *__pyx_v_cls, PyObject *__pyx_v_bucketsPerElement); /*proto*/
static char __pyx_doc_6_hydra_17BloomCalculations_computeBloomSpec1[] = "\n        Given the number of buckets that can be used per element, return a\n        specification that minimizes the false positive rate.\n\n        @param bucketsPerElement The number of buckets per element for the filter.\n        @return A spec that minimizes the false positive rate.\n        ";
static PyObject *__pyx_pw_6_hydra_17BloomCalculations_1computeBloomSpec1(PyObject *__pyx_v_cls, PyObject *__pyx_v_bucketsPerElement) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("computeBloomSpec1 (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_17BloomCalculations_computeBloomSpec1(((PyTypeObject*)__pyx_v_cls), ((PyObject *)__pyx_v_bucketsPerElement));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_17BloomCalculations_computeBloomSpec1(PyTypeObject *__pyx_v_cls, PyObject *__pyx_v_bucketsPerElement) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  Py_ssize_t __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  __Pyx_RefNannySetupContext("computeBloomSpec1", 0);

  /* "_hydra.pyx":215
 *         @return A spec that minimizes the false positive rate.
 *         """
 *         assert bucketsPerElement >= 1             # <<<<<<<<<<<<<<
 *         assert bucketsPerElement <= len(BloomCalculations.PROBS) - 1
 *         return BloomSpecification(cls.optKPerBuckets[bucketsPerElement], bucketsPerElement)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!Py_OptimizeFlag)) {
    __pyx_t_1 = PyObject_RichCompare(__pyx_v_bucketsPerElement, __pyx_int_1, Py_GE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 215, __pyx_L1_error)
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 215, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_2)) {
      PyErr_SetNone(PyExc_AssertionError);
      __PYX_ERR(0, 215, __pyx_L1_error)
    }
  }
  #endif

  /* "_hydra.pyx":216
 *         """
 *         assert bucketsPerElement >= 1
 *         assert bucketsPerElement <= len(BloomCalculations.PROBS) - 1             # <<<<<<<<<<<<<<
 *         return BloomSpecification(cls.optKPerBuckets[bucketsPerElement], bucketsPerElement)
 * 
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!Py_OptimizeFlag)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_6_hydra_BloomCalculations), __pyx_n_s_PROBS); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 216, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_3 == -1)) __PYX_ERR(0, 216, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = PyInt_FromSsize_t((__pyx_t_3 - 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 216, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = PyObject_RichCompare(__pyx_v_bucketsPerElement, __pyx_t_1, Py_LE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 216, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 216, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_2)) {
      PyErr_SetNone(PyExc_AssertionError);
      __PYX_ERR(0, 216, __pyx_L1_error)
    }
  }
  #endif

  /* "_hydra.pyx":217
 *         assert bucketsPerElement >= 1
 *         assert bucketsPerElement <= len(BloomCalculations.PROBS) - 1
 *         return BloomSpecification(cls.optKPerBuckets[bucketsPerElement], bucketsPerElement)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_BloomSpecification); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 217, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_cls), __pyx_n_s_optKPerBuckets); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 217, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = PyObject_GetItem(__pyx_t_5, __pyx_v_bucketsPerElement); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 217, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = NULL;
  __pyx_t_3 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
      __pyx_t_3 = 1;
    }
  }
  __pyx_t_7 = PyTuple_New(2+__pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 217, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  if (__pyx_t_5) {
    __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __pyx_t_5 = NULL;
  }
  __Pyx_GIVEREF(__pyx_t_6);
  PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_3, __pyx_t_6);
  __Pyx_INCREF(__pyx_v_bucketsPerElement);
  __Pyx_GIVEREF(__pyx_v_bucketsPerElement);
  PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_3, __pyx_v_bucketsPerElement);
  __pyx_t_6 = 0;
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_7, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 217, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "_hydra.pyx":207
 * 
 *     @classmethod
 *     def computeBloomSpec1(cls, bucketsPerElement):             # <<<<<<<<<<<<<<
 *         """
 *         Given the number of buckets that can be used per element, return a
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("_hydra.BloomCalculations.computeBloomSpec1", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":221
 * 
 *     @classmethod
 *     def computeBloomSpec2(cls, maxBucketsPerElement, maxFalsePosProb):             # <<<<<<<<<<<<<<
 *         """
 *         Given a maximum tolerable false positive probability, compute a Bloom
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_17BloomCalculations_3computeBloomSpec2(PyObject *__pyx_v_cls, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6_hydra_17BloomCalculations_2computeBloomSpec2[] = "\n        Given a maximum tolerable false positive probability, compute a Bloom\n        specification which will give less than the specified false positive rate,\n        but minimize the number of buckets per element and the number of hash\n        functions used.  Because bandwidth (and therefore total bitvector size)\n        is considered more expensive than computing power, preference is given\n        to minimizing buckets per element rather than number of hash functions.\n\n        @param maxBucketsPerElement The maximum number of buckets available for the filter.\n        @param maxFalsePosProb The maximum tolerable false positive rate.\n        @return A Bloom Specification which would result in a false positive rate\n        less than specified by the function call\n        @throws UnsupportedOperationException if a filter satisfying the parameters cannot be met\n        ";
static PyObject *__pyx_pw_6_hydra_17BloomCalculations_3computeBloomSpec2(PyObject *__pyx_v_cls, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_maxBucketsPerElement = 0;
  PyObject *__pyx_v_maxFalsePosProb = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("computeBloomSpec2 (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_maxBucketsPerElement,&__pyx_n_s_maxFalsePosProb,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_maxBucketsPerElement)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_maxFalsePosProb)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("computeBloomSpec2", 1, 2, 2, 1); __PYX_ERR(0, 221, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "computeBloomSpec2") < 0)) __PYX_ERR(0, 221, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_maxBucketsPerElement = values[0];
    __pyx_v_maxFalsePosProb = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("computeBloomSpec2", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 221, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_hydra.BloomCalculations.computeBloomSpec2", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6_hydra_17BloomCalculations_2computeBloomSpec2(((PyTypeObject*)__pyx_v_cls), __pyx_v_maxBucketsPerElement, __pyx_v_maxFalsePosProb);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_17BloomCalculations_2computeBloomSpec2(PyTypeObject *__pyx_v_cls, PyObject *__pyx_v_maxBucketsPerElement, PyObject *__pyx_v_maxFalsePosProb) {
  Py_ssize_t __pyx_v_maxK;
  PyObject *__pyx_v_msg = NULL;
  PyObject *__pyx_v_bucketsPerElement = NULL;
  PyObject *__pyx_v_K = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  Py_ssize_t __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  __Pyx_RefNannySetupContext("computeBloomSpec2", 0);

  /* "_hydra.pyx":236
 *         @throws UnsupportedOperationException if a filter satisfying the parameters cannot be met
 *         """
 *         assert maxBucketsPerElement >= 1             # <<<<<<<<<<<<<<
 *         assert maxBucketsPerElement <= len(BloomCalculations.PROBS) - 1
 *         maxK = len(BloomCalculations.PROBS[maxBucketsPerElement]) - 1
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!Py_OptimizeFlag)) {
    __pyx_t_1 = PyObject_RichCompare(__pyx_v_maxBucketsPerElement, __pyx_int_1, Py_GE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 236, __pyx_L1_error)
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 236, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_2)) {
      PyErr_SetNone(PyExc_AssertionError);
      __PYX_ERR(0, 236, __pyx_L1_error)
    }
  }
  #endif

  /* "_hydra.pyx":237
 *         """
 *         assert maxBucketsPerElement >= 1
 *         assert maxBucketsPerElement <= len(BloomCalculations.PROBS) - 1             # <<<<<<<<<<<<<<
 *         maxK = len(BloomCalculations.PROBS[maxBucketsPerElement]) - 1
 * 
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!Py_OptimizeFlag)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_6_hydra_BloomCalculations), __pyx_n_s_PROBS); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 237, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_3 == -1)) __PYX_ERR(0, 237, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = PyInt_FromSsize_t((__pyx_t_3 - 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 237, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = PyObject_RichCompare(__pyx_v_maxBucketsPerElement, __pyx_t_1, Py_LE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 237, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 237, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_2)) {
      PyErr_SetNone(PyExc_AssertionError);
      __PYX_ERR(0, 237, __pyx_L1_error)
    }
  }
  #endif

  /* "_hydra.pyx":238
 *         assert maxBucketsPerElement >= 1
 *         assert maxBucketsPerElement <= len(BloomCalculations.PROBS) - 1
 *         maxK = len(BloomCalculations.PROBS[maxBucketsPerElement]) - 1             # <<<<<<<<<<<<<<
 * 
 *         # Handle the trivial cases
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_6_hydra_BloomCalculations), __pyx_n_s_PROBS); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 238, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_1 = PyObject_GetItem(__pyx_t_4, __pyx_v_maxBucketsPerElement); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 238, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_3 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_3 == -1)) __PYX_ERR(0, 238, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_maxK = (__pyx_t_3 - 1);

  /* "_hydra.pyx":241
 * 
 *         # Handle the trivial cases
 *         if maxFalsePosProb >= BloomCalculations.PROBS[cls.minBuckets][cls.minK]:             # <<<<<<<<<<<<<<
 *             return BloomSpecification(2, cls.optKPerBuckets[2])
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_6_hydra_BloomCalculations), __pyx_n_s_PROBS); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_cls), __pyx_n_s_minBuckets); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = PyObject_GetItem(__pyx_t_1, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_cls), __pyx_n_s_minK); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_1 = PyObject_GetItem(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = PyObject_RichCompare(__pyx_v_maxFalsePosProb, __pyx_t_1, Py_GE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__pyx_t_2) {

    /* "_hydra.pyx":242
 *         # Handle the trivial cases
 *         if maxFalsePosProb >= BloomCalculations.PROBS[cls.minBuckets][cls.minK]:
 *             return BloomSpecification(2, cls.optKPerBuckets[2])             # <<<<<<<<<<<<<<
 * 
 *         if maxFalsePosProb < BloomCalculations.PROBS[maxBucketsPerElement][maxK]:
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_BloomSpecification); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 242, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_cls), __pyx_n_s_optKPerBuckets); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 242, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = __Pyx_GetItemInt(__pyx_t_5, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 242, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = NULL;
    __pyx_t_3 = 0;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
        __pyx_t_3 = 1;
      }
    }
    __pyx_t_7 = PyTuple_New(2+__pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 242, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    if (__pyx_t_5) {
      __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __pyx_t_5 = NULL;
    }
    __Pyx_INCREF(__pyx_int_2);
    __Pyx_GIVEREF(__pyx_int_2);
    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_3, __pyx_int_2);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_3, __pyx_t_6);
    __pyx_t_6 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_7, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 242, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "_hydra.pyx":241
 * 
 *         # Handle the trivial cases
 *         if maxFalsePosProb >= BloomCalculations.PROBS[cls.minBuckets][cls.minK]:             # <<<<<<<<<<<<<<
 *             return BloomSpecification(2, cls.optKPerBuckets[2])
 * 
 */
  }

  /* "_hydra.pyx":244
 *             return BloomSpecification(2, cls.optKPerBuckets[2])
 * 
 *         if maxFalsePosProb < BloomCalculations.PROBS[maxBucketsPerElement][maxK]:             # <<<<<<<<<<<<<<
 *             msg = "Unable to satisfy %s with %s buckets per element"
 *             raise  UnsupportedOperationException(msg % (maxFalsePosProb, maxBucketsPerElement))
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_6_hydra_BloomCalculations), __pyx_n_s_PROBS); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 244, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_1 = PyObject_GetItem(__pyx_t_4, __pyx_v_maxBucketsPerElement); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 244, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_1, __pyx_v_maxK, Py_ssize_t, 1, PyInt_FromSsize_t, 0, 1, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 244, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyObject_RichCompare(__pyx_v_maxFalsePosProb, __pyx_t_4, Py_LT); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 244, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 244, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_2) {

    /* "_hydra.pyx":245
 * 
 *         if maxFalsePosProb < BloomCalculations.PROBS[maxBucketsPerElement][maxK]:
 *             msg = "Unable to satisfy %s with %s buckets per element"             # <<<<<<<<<<<<<<
 *             raise  UnsupportedOperationException(msg % (maxFalsePosProb, maxBucketsPerElement))
 * 
 */
    __Pyx_INCREF(__pyx_kp_s_Unable_to_satisfy_s_with_s_bucke);
    __pyx_v_msg = __pyx_kp_s_Unable_to_satisfy_s_with_s_bucke;

    /* "_hydra.pyx":246
 *         if maxFalsePosProb < BloomCalculations.PROBS[maxBucketsPerElement][maxK]:
 *             msg = "Unable to satisfy %s with %s buckets per element"
 *             raise  UnsupportedOperationException(msg % (maxFalsePosProb, maxBucketsPerElement))             # <<<<<<<<<<<<<<
 * 
 *         # First find the minimal required number of buckets:
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_UnsupportedOperationException); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 246, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 246, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_INCREF(__pyx_v_maxFalsePosProb);
    __Pyx_GIVEREF(__pyx_v_maxFalsePosProb);
    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_v_maxFalsePosProb);
    __Pyx_INCREF(__pyx_v_maxBucketsPerElement);
    __Pyx_GIVEREF(__pyx_v_maxBucketsPerElement);
    PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_v_maxBucketsPerElement);
    __pyx_t_6 = PyNumber_Remainder(__pyx_v_msg, __pyx_t_7); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 246, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_7) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 246, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 246, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_7); __pyx_t_7 = NULL;
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_6);
      __pyx_t_6 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 246, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 246, __pyx_L1_error)

    /* "_hydra.pyx":244
 *             return BloomSpecification(2, cls.optKPerBuckets[2])
 * 
 *         if maxFalsePosProb < BloomCalculations.PROBS[maxBucketsPerElement][maxK]:             # <<<<<<<<<<<<<<
 *             msg = "Unable to satisfy %s with %s buckets per element"
 *             raise  UnsupportedOperationException(msg % (maxFalsePosProb, maxBucketsPerElement))
 */
  }

  /* "_hydra.pyx":249
 * 
 *         # First find the minimal required number of buckets:
 *         bucketsPerElement = 2             # <<<<<<<<<<<<<<
 *         K = cls.optKPerBuckets[2]
 *         while(BloomCalculations.PROBS[bucketsPerElement][K] > maxFalsePosProb):
 */
  __Pyx_INCREF(__pyx_int_2);
  __pyx_v_bucketsPerElement = __pyx_int_2;

  /* "_hydra.pyx":250
 *         # First find the minimal required number of buckets:
 *         bucketsPerElement = 2
 *         K = cls.optKPerBuckets[2]             # <<<<<<<<<<<<<<
 *         while(BloomCalculations.PROBS[bucketsPerElement][K] > maxFalsePosProb):
 *             bucketsPerElement += 1
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_cls), __pyx_n_s_optKPerBuckets); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 250, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_1, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 250, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_K = __pyx_t_4;
  __pyx_t_4 = 0;

  /* "_hydra.pyx":251
 *         bucketsPerElement = 2
 *         K = cls.optKPerBuckets[2]
 *         while(BloomCalculations.PROBS[bucketsPerElement][K] > maxFalsePosProb):             # <<<<<<<<<<<<<<
 *             bucketsPerElement += 1
 *             K = cls.optKPerBuckets[bucketsPerElement]
 */
  while (1) {
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_6_hydra_BloomCalculations), __pyx_n_s_PROBS); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 251, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_1 = PyObject_GetItem(__pyx_t_4, __pyx_v_bucketsPerElement); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 251, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyObject_GetItem(__pyx_t_1, __pyx_v_K); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 251, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = PyObject_RichCompare(__pyx_t_4, __pyx_v_maxFalsePosProb, Py_GT); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 251, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 251, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (!__pyx_t_2) break;

    /* "_hydra.pyx":252
 *         K = cls.optKPerBuckets[2]
 *         while(BloomCalculations.PROBS[bucketsPerElement][K] > maxFalsePosProb):
 *             bucketsPerElement += 1             # <<<<<<<<<<<<<<
 *             K = cls.optKPerBuckets[bucketsPerElement]
 *         # Now that the number of buckets is sufficient, see if we can relax K
 */
    __pyx_t_1 = __Pyx_PyInt_AddObjC(__pyx_v_bucketsPerElement, __pyx_int_1, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 252, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF_SET(__pyx_v_bucketsPerElement, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "_hydra.pyx":253
 *         while(BloomCalculations.PROBS[bucketsPerElement][K] > maxFalsePosProb):
 *             bucketsPerElement += 1
 *             K = cls.optKPerBuckets[bucketsPerElement]             # <<<<<<<<<<<<<<
 *         # Now that the number of buckets is sufficient, see if we can relax K
 *         # without losing too much precision.
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_cls), __pyx_n_s_optKPerBuckets); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 253, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = PyObject_GetItem(__pyx_t_1, __pyx_v_bucketsPerElement); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 253, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF_SET(__pyx_v_K, __pyx_t_4);
    __pyx_t_4 = 0;
  }

  /* "_hydra.pyx":256
 *         # Now that the number of buckets is sufficient, see if we can relax K
 *         # without losing too much precision.
 *         while BloomCalculations.PROBS[bucketsPerElement][K - 1] <= maxFalsePosProb:             # <<<<<<<<<<<<<<
 *             K -= 1
 * 
 */
  while (1) {
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_6_hydra_BloomCalculations), __pyx_n_s_PROBS); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 256, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_1 = PyObject_GetItem(__pyx_t_4, __pyx_v_bucketsPerElement); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 256, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyInt_SubtractObjC(__pyx_v_K, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 256, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = PyObject_GetItem(__pyx_t_1, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 256, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyObject_RichCompare(__pyx_t_5, __pyx_v_maxFalsePosProb, Py_LE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 256, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 256, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (!__pyx_t_2) break;

    /* "_hydra.pyx":257
 *         # without losing too much precision.
 *         while BloomCalculations.PROBS[bucketsPerElement][K - 1] <= maxFalsePosProb:
 *             K -= 1             # <<<<<<<<<<<<<<
 * 
 *         return BloomSpecification(K, bucketsPerElement)
 */
    __pyx_t_4 = __Pyx_PyInt_SubtractObjC(__pyx_v_K, __pyx_int_1, 1, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 257, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF_SET(__pyx_v_K, __pyx_t_4);
    __pyx_t_4 = 0;
  }

  /* "_hydra.pyx":259
 *             K -= 1
 * 
 *         return BloomSpecification(K, bucketsPerElement)             # <<<<<<<<<<<<<<
 * 
 * cdef class BloomFilter:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_BloomSpecification); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_1 = NULL;
  __pyx_t_3 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
      __pyx_t_3 = 1;
    }
  }
  __pyx_t_6 = PyTuple_New(2+__pyx_t_3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  if (__pyx_t_1) {
    __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_1); __pyx_t_1 = NULL;
  }
  __Pyx_INCREF(__pyx_v_K);
  __Pyx_GIVEREF(__pyx_v_K);
  PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_3, __pyx_v_K);
  __Pyx_INCREF(__pyx_v_bucketsPerElement);
  __Pyx_GIVEREF(__pyx_v_bucketsPerElement);
  PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_3, __pyx_v_bucketsPerElement);
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "_hydra.pyx":221
 * 
 *     @classmethod
 *     def computeBloomSpec2(cls, maxBucketsPerElement, maxFalsePosProb):             # <<<<<<<<<<<<<<
 *         """
 *         Given a maximum tolerable false positive probability, compute a Bloom
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("_hydra.BloomCalculations.computeBloomSpec2", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_msg);
  __Pyx_XDECREF(__pyx_v_bucketsPerElement);
  __Pyx_XDECREF(__pyx_v_K);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":268
 *     cdef object _tempfile
 * 
 *     def __cinit__(self, unsigned int hashes, MMapBitField bitmap, int ignore_case):             # <<<<<<<<<<<<<<
 *         cdef int i
 * 
 */

/* Python wrapper */
static int __pyx_pw_6_hydra_11BloomFilter_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_6_hydra_11BloomFilter_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  unsigned int __pyx_v_hashes;
  struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_bitmap = 0;
  int __pyx_v_ignore_case;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_hashes,&__pyx_n_s_bitmap,&__pyx_n_s_ignore_case,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_hashes)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_bitmap)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, 1); __PYX_ERR(0, 268, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ignore_case)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, 2); __PYX_ERR(0, 268, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 268, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_hashes = __Pyx_PyInt_As_unsigned_int(values[0]); if (unlikely((__pyx_v_hashes == (unsigned int)-1) && PyErr_Occurred())) __PYX_ERR(0, 268, __pyx_L3_error)
    __pyx_v_bitmap = ((struct __pyx_obj_6_hydra_MMapBitField *)values[1]);
    __pyx_v_ignore_case = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_ignore_case == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 268, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 268, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_hydra.BloomFilter.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_bitmap), __pyx_ptype_6_hydra_MMapBitField, 1, "bitmap", 0))) __PYX_ERR(0, 268, __pyx_L1_error)
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter___cinit__(((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_v_self), __pyx_v_hashes, __pyx_v_bitmap, __pyx_v_ignore_case);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_6_hydra_11BloomFilter___cinit__(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, unsigned int __pyx_v_hashes, struct __pyx_obj_6_hydra_MMapBitField *__pyx_v_bitmap, int __pyx_v_ignore_case) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "_hydra.pyx":271
 *         cdef int i
 * 
 *         self._hashCount = hashes             # <<<<<<<<<<<<<<
 *         self._bitmap = bitmap
 *         self._ignore_case = ignore_case
 */
  __pyx_v_self->_hashCount = __pyx_v_hashes;

  /* "_hydra.pyx":272
 * 
 *         self._hashCount = hashes
 *         self._bitmap = bitmap             # <<<<<<<<<<<<<<
 *         self._ignore_case = ignore_case
 * 
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_bitmap));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_bitmap));
  __Pyx_GOTREF(__pyx_v_self->_bitmap);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->_bitmap));
  __pyx_v_self->_bitmap = __pyx_v_bitmap;

  /* "_hydra.pyx":273
 *         self._hashCount = hashes
 *         self._bitmap = bitmap
 *         self._ignore_case = ignore_case             # <<<<<<<<<<<<<<
 * 
 *     def __enter__(self):
 */
  __pyx_v_self->_ignore_case = __pyx_v_ignore_case;

  /* "_hydra.pyx":268
 *     cdef object _tempfile
 * 
 *     def __cinit__(self, unsigned int hashes, MMapBitField bitmap, int ignore_case):             # <<<<<<<<<<<<<<
 *         cdef int i
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":275
 *         self._ignore_case = ignore_case
 * 
 *     def __enter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_11BloomFilter_3__enter__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_6_hydra_11BloomFilter_3__enter__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__enter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_2__enter__(((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_11BloomFilter_2__enter__(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__enter__", 0);

  /* "_hydra.pyx":276
 * 
 *     def __enter__(self):
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     def __exit__(self, *excinfo):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __pyx_r = ((PyObject *)__pyx_v_self);
  goto __pyx_L0;

  /* "_hydra.pyx":275
 *         self._ignore_case = ignore_case
 * 
 *     def __enter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":278
 *         return self
 * 
 *     def __exit__(self, *excinfo):             # <<<<<<<<<<<<<<
 *         self.close()
 *         return None
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_11BloomFilter_5__exit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyObject *__pyx_pw_6_hydra_11BloomFilter_5__exit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_excinfo = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__exit__ (wrapper)", 0);
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__exit__", 0))) return NULL;
  __Pyx_INCREF(__pyx_args);
  __pyx_v_excinfo = __pyx_args;
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_4__exit__(((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_v_self), __pyx_v_excinfo);

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_excinfo);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_11BloomFilter_4__exit__(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_excinfo) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__exit__", 0);

  /* "_hydra.pyx":279
 * 
 *     def __exit__(self, *excinfo):
 *         self.close()             # <<<<<<<<<<<<<<
 *         return None
 * 
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_6_hydra_BloomFilter *)__pyx_v_self->__pyx_vtab)->close(__pyx_v_self, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_hydra.pyx":280
 *     def __exit__(self, *excinfo):
 *         self.close()
 *         return None             # <<<<<<<<<<<<<<
 * 
 *     cpdef close(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_None);
  __pyx_r = Py_None;
  goto __pyx_L0;

  /* "_hydra.pyx":278
 *         return self
 * 
 *     def __exit__(self, *excinfo):             # <<<<<<<<<<<<<<
 *         self.close()
 *         return None
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.BloomFilter.__exit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":282
 *         return None
 * 
 *     cpdef close(self):             # <<<<<<<<<<<<<<
 *         self._bitmap.close()
 * 
 */

static PyObject *__pyx_pw_6_hydra_11BloomFilter_7close(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_6_hydra_11BloomFilter_close(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("close", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_close); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 282, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_7close)) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 282, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 282, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "_hydra.pyx":283
 * 
 *     cpdef close(self):
 *         self._bitmap.close()             # <<<<<<<<<<<<<<
 * 
 *     cpdef fdatasync(self):
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_6_hydra_MMapBitField *)__pyx_v_self->_bitmap->__pyx_vtab)->close(__pyx_v_self->_bitmap, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 283, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_hydra.pyx":282
 *         return None
 * 
 *     cpdef close(self):             # <<<<<<<<<<<<<<
 *         self._bitmap.close()
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_hydra.BloomFilter.close", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_11BloomFilter_7close(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_6_hydra_11BloomFilter_7close(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("close (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_6close(((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_11BloomFilter_6close(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("close", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_6_hydra_11BloomFilter_close(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.BloomFilter.close", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":285
 *         self._bitmap.close()
 * 
 *     cpdef fdatasync(self):             # <<<<<<<<<<<<<<
 *         """ Flush everything to disk """
 *         self._bitmap.fdatasync()
 */

static PyObject *__pyx_pw_6_hydra_11BloomFilter_9fdatasync(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_6_hydra_11BloomFilter_fdatasync(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("fdatasync", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_fdatasync); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 285, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_9fdatasync)) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 285, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 285, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "_hydra.pyx":287
 *     cpdef fdatasync(self):
 *         """ Flush everything to disk """
 *         self._bitmap.fdatasync()             # <<<<<<<<<<<<<<
 * 
 *     def filename(self):
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_6_hydra_MMapBitField *)__pyx_v_self->_bitmap->__pyx_vtab)->fdatasync(__pyx_v_self->_bitmap, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 287, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_hydra.pyx":285
 *         self._bitmap.close()
 * 
 *     cpdef fdatasync(self):             # <<<<<<<<<<<<<<
 *         """ Flush everything to disk """
 *         self._bitmap.fdatasync()
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_hydra.BloomFilter.fdatasync", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_11BloomFilter_9fdatasync(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_6_hydra_11BloomFilter_8fdatasync[] = " Flush everything to disk ";
static PyObject *__pyx_pw_6_hydra_11BloomFilter_9fdatasync(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fdatasync (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_8fdatasync(((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_11BloomFilter_8fdatasync(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("fdatasync", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_6_hydra_11BloomFilter_fdatasync(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 285, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.BloomFilter.fdatasync", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":289
 *         self._bitmap.fdatasync()
 * 
 *     def filename(self):             # <<<<<<<<<<<<<<
 *         """
 *         Filename of the MMAP file
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_11BloomFilter_11filename(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_6_hydra_11BloomFilter_10filename[] = "\n        Filename of the MMAP file\n        ";
static PyObject *__pyx_pw_6_hydra_11BloomFilter_11filename(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("filename (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_10filename(((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_11BloomFilter_10filename(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("filename", 0);

  /* "_hydra.pyx":293
 *         Filename of the MMAP file
 *         """
 *         return self._bitmap._filename             # <<<<<<<<<<<<<<
 * 
 *     @classmethod
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->_bitmap->_filename); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 293, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "_hydra.pyx":289
 *         self._bitmap.fdatasync()
 * 
 *     def filename(self):             # <<<<<<<<<<<<<<
 *         """
 *         Filename of the MMAP file
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.BloomFilter.filename", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":296
 * 
 *     @classmethod
 *     def _maxBucketsPerElement(cls, numElements):             # <<<<<<<<<<<<<<
 *         numElements = max(1, numElements)
 *         v = (sys.maxsize - cls.EXCESS) / float(numElements)
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_11BloomFilter_13_maxBucketsPerElement(PyObject *__pyx_v_cls, PyObject *__pyx_v_numElements); /*proto*/
static PyObject *__pyx_pw_6_hydra_11BloomFilter_13_maxBucketsPerElement(PyObject *__pyx_v_cls, PyObject *__pyx_v_numElements) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_maxBucketsPerElement (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_12_maxBucketsPerElement(((PyTypeObject*)__pyx_v_cls), ((PyObject *)__pyx_v_numElements));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_11BloomFilter_12_maxBucketsPerElement(PyTypeObject *__pyx_v_cls, PyObject *__pyx_v_numElements) {
  PyObject *__pyx_v_v = NULL;
  PyObject *__pyx_v_msg = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  long __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  Py_ssize_t __pyx_t_7;
  Py_ssize_t __pyx_t_8;
  __Pyx_RefNannySetupContext("_maxBucketsPerElement", 0);
  __Pyx_INCREF(__pyx_v_numElements);

  /* "_hydra.pyx":297
 *     @classmethod
 *     def _maxBucketsPerElement(cls, numElements):
 *         numElements = max(1, numElements)             # <<<<<<<<<<<<<<
 *         v = (sys.maxsize - cls.EXCESS) / float(numElements)
 *         if v < 1.0:
 */
  __Pyx_INCREF(__pyx_v_numElements);
  __pyx_t_1 = __pyx_v_numElements;
  __pyx_t_2 = 1;
  __pyx_t_4 = __Pyx_PyInt_From_long(__pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 297, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = PyObject_RichCompare(__pyx_t_1, __pyx_t_4, Py_GT); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 297, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 297, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (__pyx_t_6) {
    __Pyx_INCREF(__pyx_t_1);
    __pyx_t_3 = __pyx_t_1;
  } else {
    __pyx_t_5 = __Pyx_PyInt_From_long(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 297, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_3 = __pyx_t_5;
    __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __pyx_t_3;
  __Pyx_INCREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF_SET(__pyx_v_numElements, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "_hydra.pyx":298
 *     def _maxBucketsPerElement(cls, numElements):
 *         numElements = max(1, numElements)
 *         v = (sys.maxsize - cls.EXCESS) / float(numElements)             # <<<<<<<<<<<<<<
 *         if v < 1.0:
 *             msg = "Cannot compute probabilities for %s elements."
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_sys); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 298, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_maxsize); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 298, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_cls), __pyx_n_s_EXCESS); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 298, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_5 = PyNumber_Subtract(__pyx_t_3, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 298, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyNumber_Float(__pyx_v_numElements); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 298, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyNumber_Divide(__pyx_t_5, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 298, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_v = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "_hydra.pyx":299
 *         numElements = max(1, numElements)
 *         v = (sys.maxsize - cls.EXCESS) / float(numElements)
 *         if v < 1.0:             # <<<<<<<<<<<<<<
 *             msg = "Cannot compute probabilities for %s elements."
 *             raise UnsupportedOperationException, msg % numElements
 */
  __pyx_t_3 = PyObject_RichCompare(__pyx_v_v, __pyx_float_1_0, Py_LT); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 299, __pyx_L1_error)
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 299, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_6) {

    /* "_hydra.pyx":300
 *         v = (sys.maxsize - cls.EXCESS) / float(numElements)
 *         if v < 1.0:
 *             msg = "Cannot compute probabilities for %s elements."             # <<<<<<<<<<<<<<
 *             raise UnsupportedOperationException, msg % numElements
 *         return min(len(BloomCalculations.PROBS) - 1, int(v))
 */
    __Pyx_INCREF(__pyx_kp_s_Cannot_compute_probabilities_for);
    __pyx_v_msg = __pyx_kp_s_Cannot_compute_probabilities_for;

    /* "_hydra.pyx":301
 *         if v < 1.0:
 *             msg = "Cannot compute probabilities for %s elements."
 *             raise UnsupportedOperationException, msg % numElements             # <<<<<<<<<<<<<<
 *         return min(len(BloomCalculations.PROBS) - 1, int(v))
 * 
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_UnsupportedOperationException); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 301, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = PyNumber_Remainder(__pyx_v_msg, __pyx_v_numElements); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 301, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_3, __pyx_t_1, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 301, __pyx_L1_error)

    /* "_hydra.pyx":299
 *         numElements = max(1, numElements)
 *         v = (sys.maxsize - cls.EXCESS) / float(numElements)
 *         if v < 1.0:             # <<<<<<<<<<<<<<
 *             msg = "Cannot compute probabilities for %s elements."
 *             raise UnsupportedOperationException, msg % numElements
 */
  }

  /* "_hydra.pyx":302
 *             msg = "Cannot compute probabilities for %s elements."
 *             raise UnsupportedOperationException, msg % numElements
 *         return min(len(BloomCalculations.PROBS) - 1, int(v))             # <<<<<<<<<<<<<<
 * 
 *     @classmethod
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_v_v); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 302, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_6_hydra_BloomCalculations), __pyx_n_s_PROBS); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 302, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_7 = PyObject_Length(__pyx_t_3); if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 302, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_8 = (__pyx_t_7 - 1);
  __pyx_t_5 = PyInt_FromSsize_t(__pyx_t_8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 302, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_4 = PyObject_RichCompare(__pyx_t_1, __pyx_t_5, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 302, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 302, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__pyx_t_6) {
    __Pyx_INCREF(__pyx_t_1);
    __pyx_t_3 = __pyx_t_1;
  } else {
    __pyx_t_4 = PyInt_FromSsize_t(__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 302, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __pyx_t_4;
    __pyx_t_4 = 0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_INCREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "_hydra.pyx":296
 * 
 *     @classmethod
 *     def _maxBucketsPerElement(cls, numElements):             # <<<<<<<<<<<<<<
 *         numElements = max(1, numElements)
 *         v = (sys.maxsize - cls.EXCESS) / float(numElements)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("_hydra.BloomFilter._maxBucketsPerElement", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_v);
  __Pyx_XDECREF(__pyx_v_msg);
  __Pyx_XDECREF(__pyx_v_numElements);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":305
 * 
 *     @classmethod
 *     def _bucketsFor(cls, numElements, bucketsPer, filename, read_only, want_lock=False, fdatasync_on_close=True):             # <<<<<<<<<<<<<<
 *         numBits = numElements * bucketsPer + cls.EXCESS
 *         bf_size = min(sys.maxsize, numBits)
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_11BloomFilter_15_bucketsFor(PyObject *__pyx_v_cls, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyObject *__pyx_pw_6_hydra_11BloomFilter_15_bucketsFor(PyObject *__pyx_v_cls, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_numElements = 0;
  PyObject *__pyx_v_bucketsPer = 0;
  PyObject *__pyx_v_filename = 0;
  PyObject *__pyx_v_read_only = 0;
  PyObject *__pyx_v_want_lock = 0;
  PyObject *__pyx_v_fdatasync_on_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_bucketsFor (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_numElements,&__pyx_n_s_bucketsPer,&__pyx_n_s_filename,&__pyx_n_s_read_only,&__pyx_n_s_want_lock,&__pyx_n_s_fdatasync_on_close,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[4] = ((PyObject *)Py_False);
    values[5] = ((PyObject *)Py_True);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_numElements)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_bucketsPer)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_bucketsFor", 0, 4, 6, 1); __PYX_ERR(0, 305, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_filename)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_bucketsFor", 0, 4, 6, 2); __PYX_ERR(0, 305, __pyx_L3_error)
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_read_only)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_bucketsFor", 0, 4, 6, 3); __PYX_ERR(0, 305, __pyx_L3_error)
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_want_lock);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_fdatasync_on_close);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_bucketsFor") < 0)) __PYX_ERR(0, 305, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_numElements = values[0];
    __pyx_v_bucketsPer = values[1];
    __pyx_v_filename = values[2];
    __pyx_v_read_only = values[3];
    __pyx_v_want_lock = values[4];
    __pyx_v_fdatasync_on_close = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_bucketsFor", 0, 4, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 305, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_hydra.BloomFilter._bucketsFor", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_14_bucketsFor(((PyTypeObject*)__pyx_v_cls), __pyx_v_numElements, __pyx_v_bucketsPer, __pyx_v_filename, __pyx_v_read_only, __pyx_v_want_lock, __pyx_v_fdatasync_on_close);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_11BloomFilter_14_bucketsFor(PyTypeObject *__pyx_v_cls, PyObject *__pyx_v_numElements, PyObject *__pyx_v_bucketsPer, PyObject *__pyx_v_filename, PyObject *__pyx_v_read_only, PyObject *__pyx_v_want_lock, PyObject *__pyx_v_fdatasync_on_close) {
  PyObject *__pyx_v_numBits = NULL;
  PyObject *__pyx_v_bf_size = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("_bucketsFor", 0);

  /* "_hydra.pyx":306
 *     @classmethod
 *     def _bucketsFor(cls, numElements, bucketsPer, filename, read_only, want_lock=False, fdatasync_on_close=True):
 *         numBits = numElements * bucketsPer + cls.EXCESS             # <<<<<<<<<<<<<<
 *         bf_size = min(sys.maxsize, numBits)
 *         return MMapBitField(filename, bf_size, read_only,
 */
  __pyx_t_1 = PyNumber_Multiply(__pyx_v_numElements, __pyx_v_bucketsPer); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 306, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_cls), __pyx_n_s_EXCESS); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 306, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 306, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_numBits = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "_hydra.pyx":307
 *     def _bucketsFor(cls, numElements, bucketsPer, filename, read_only, want_lock=False, fdatasync_on_close=True):
 *         numBits = numElements * bucketsPer + cls.EXCESS
 *         bf_size = min(sys.maxsize, numBits)             # <<<<<<<<<<<<<<
 *         return MMapBitField(filename, bf_size, read_only,
 *                             want_lock=want_lock,
 */
  __Pyx_INCREF(__pyx_v_numBits);
  __pyx_t_3 = __pyx_v_numBits;
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_sys); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 307, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_maxsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 307, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = PyObject_RichCompare(__pyx_t_3, __pyx_t_1, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 307, __pyx_L1_error)
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 307, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__pyx_t_5) {
    __Pyx_INCREF(__pyx_t_3);
    __pyx_t_2 = __pyx_t_3;
  } else {
    __Pyx_INCREF(__pyx_t_1);
    __pyx_t_2 = __pyx_t_1;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __pyx_t_2;
  __Pyx_INCREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_bf_size = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "_hydra.pyx":308
 *         numBits = numElements * bucketsPer + cls.EXCESS
 *         bf_size = min(sys.maxsize, numBits)
 *         return MMapBitField(filename, bf_size, read_only,             # <<<<<<<<<<<<<<
 *                             want_lock=want_lock,
 *                             fdatasync_on_close=fdatasync_on_close)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 308, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_filename);
  __Pyx_GIVEREF(__pyx_v_filename);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_filename);
  __Pyx_INCREF(__pyx_v_bf_size);
  __Pyx_GIVEREF(__pyx_v_bf_size);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_bf_size);
  __Pyx_INCREF(__pyx_v_read_only);
  __Pyx_GIVEREF(__pyx_v_read_only);
  PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_v_read_only);

  /* "_hydra.pyx":309
 *         bf_size = min(sys.maxsize, numBits)
 *         return MMapBitField(filename, bf_size, read_only,
 *                             want_lock=want_lock,             # <<<<<<<<<<<<<<
 *                             fdatasync_on_close=fdatasync_on_close)
 * 
 */
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 309, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_want_lock, __pyx_v_want_lock) < 0) __PYX_ERR(0, 309, __pyx_L1_error)

  /* "_hydra.pyx":310
 *         return MMapBitField(filename, bf_size, read_only,
 *                             want_lock=want_lock,
 *                             fdatasync_on_close=fdatasync_on_close)             # <<<<<<<<<<<<<<
 * 
 *     @classmethod
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_fdatasync_on_close, __pyx_v_fdatasync_on_close) < 0) __PYX_ERR(0, 309, __pyx_L1_error)

  /* "_hydra.pyx":308
 *         numBits = numElements * bucketsPer + cls.EXCESS
 *         bf_size = min(sys.maxsize, numBits)
 *         return MMapBitField(filename, bf_size, read_only,             # <<<<<<<<<<<<<<
 *                             want_lock=want_lock,
 *                             fdatasync_on_close=fdatasync_on_close)
 */
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_6_hydra_MMapBitField), __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 308, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "_hydra.pyx":305
 * 
 *     @classmethod
 *     def _bucketsFor(cls, numElements, bucketsPer, filename, read_only, want_lock=False, fdatasync_on_close=True):             # <<<<<<<<<<<<<<
 *         numBits = numElements * bucketsPer + cls.EXCESS
 *         bf_size = min(sys.maxsize, numBits)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_hydra.BloomFilter._bucketsFor", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_numBits);
  __Pyx_XDECREF(__pyx_v_bf_size);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":313
 * 
 *     @classmethod
 *     def getFilter(cls, numElements, maxFalsePosProbability, **kwargs):             # <<<<<<<<<<<<<<
 *         """
 *         Create a bloom filter.
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_11BloomFilter_17getFilter(PyObject *__pyx_v_cls, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6_hydra_11BloomFilter_16getFilter[] = "\n        Create a bloom filter.\n\n        numElements and maxFalsePosProbability are taken to form a\n        speciification for the Bloom Filter.  The filter is designed\n        to hold a maximum of numElements entries and will have an\n        upper bound false positive error rate of\n        maxFalsePosProbability.\n\n        Optional **kwargs:\n\n        filename: The filepath of the mmap io file.  If set to None - a file\n                  will be created in temporary storage. Default: None\n\n        ignore_case: All strings will be forced into lower case for\n                     both add and search functions. Default: False\n\n        read_only: The file will be opened in read-only mode and the\n                   memory map will be setup in read only mode. Default False\n\n        ";
static PyObject *__pyx_pw_6_hydra_11BloomFilter_17getFilter(PyObject *__pyx_v_cls, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_numElements = 0;
  PyObject *__pyx_v_maxFalsePosProbability = 0;
  PyObject *__pyx_v_kwargs = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getFilter (wrapper)", 0);
  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
  __Pyx_GOTREF(__pyx_v_kwargs);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_numElements,&__pyx_n_s_maxFalsePosProbability,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_numElements)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_maxFalsePosProbability)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getFilter", 1, 2, 2, 1); __PYX_ERR(0, 313, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "getFilter") < 0)) __PYX_ERR(0, 313, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_numElements = values[0];
    __pyx_v_maxFalsePosProbability = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getFilter", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 313, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
  __Pyx_AddTraceback("_hydra.BloomFilter.getFilter", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_16getFilter(((PyTypeObject*)__pyx_v_cls), __pyx_v_numElements, __pyx_v_maxFalsePosProbability, __pyx_v_kwargs);

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_kwargs);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_11BloomFilter_16getFilter(PyTypeObject *__pyx_v_cls, PyObject *__pyx_v_numElements, PyObject *__pyx_v_maxFalsePosProbability, PyObject *__pyx_v_kwargs) {
  PyObject *__pyx_v_filename = NULL;
  PyObject *__pyx_v_ignore_case = NULL;
  PyObject *__pyx_v_read_only = NULL;
  PyObject *__pyx_v_want_lock = NULL;
  PyObject *__pyx_v_fdatasync_on_close = NULL;
  PyObject *__pyx_v_k = NULL;
  PyObject *__pyx_v_fileobj = NULL;
  PyObject *__pyx_v_bucketsPerElement = NULL;
  PyObject *__pyx_v_spec = NULL;
  PyObject *__pyx_v_bitmap = NULL;
  struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_bf = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  __Pyx_RefNannySetupContext("getFilter", 0);

  /* "_hydra.pyx":335
 * 
 *         """
 *         filename = kwargs.get('filename', None)             # <<<<<<<<<<<<<<
 *         ignore_case = kwargs.get('ignore_case', 0)
 *         read_only = kwargs.get('read_only', 0)
 */
  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_kwargs, __pyx_n_s_filename, Py_None); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 335, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_filename = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "_hydra.pyx":336
 *         """
 *         filename = kwargs.get('filename', None)
 *         ignore_case = kwargs.get('ignore_case', 0)             # <<<<<<<<<<<<<<
 *         read_only = kwargs.get('read_only', 0)
 *         want_lock = kwargs.get('want_lock', False)
 */
  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_kwargs, __pyx_n_s_ignore_case, __pyx_int_0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 336, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_ignore_case = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "_hydra.pyx":337
 *         filename = kwargs.get('filename', None)
 *         ignore_case = kwargs.get('ignore_case', 0)
 *         read_only = kwargs.get('read_only', 0)             # <<<<<<<<<<<<<<
 *         want_lock = kwargs.get('want_lock', False)
 *         fdatasync_on_close = kwargs.get('fdatasync_on_close', True)
 */
  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_kwargs, __pyx_n_s_read_only, __pyx_int_0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 337, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_read_only = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "_hydra.pyx":338
 *         ignore_case = kwargs.get('ignore_case', 0)
 *         read_only = kwargs.get('read_only', 0)
 *         want_lock = kwargs.get('want_lock', False)             # <<<<<<<<<<<<<<
 *         fdatasync_on_close = kwargs.get('fdatasync_on_close', True)
 * 
 */
  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_kwargs, __pyx_n_s_want_lock, Py_False); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 338, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_want_lock = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "_hydra.pyx":339
 *         read_only = kwargs.get('read_only', 0)
 *         want_lock = kwargs.get('want_lock', False)
 *         fdatasync_on_close = kwargs.get('fdatasync_on_close', True)             # <<<<<<<<<<<<<<
 * 
 *         for k in ['filename', 'ignore_case', 'read_only', 'want_lock', 'fdatasync_on_close']:
 */
  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_kwargs, __pyx_n_s_fdatasync_on_close, Py_True); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 339, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_fdatasync_on_close = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "_hydra.pyx":341
 *         fdatasync_on_close = kwargs.get('fdatasync_on_close', True)
 * 
 *         for k in ['filename', 'ignore_case', 'read_only', 'want_lock', 'fdatasync_on_close']:             # <<<<<<<<<<<<<<
 *             if kwargs.has_key(k):
 *                 del kwargs[k]
 */
  __pyx_t_1 = __pyx_tuple__10; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
  for (;;) {
    if (__pyx_t_2 >= 5) break;
    #if CYTHON_COMPILING_IN_CPYTHON
    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 341, __pyx_L1_error)
    #else
    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 341, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    #endif
    __Pyx_XDECREF_SET(__pyx_v_k, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "_hydra.pyx":342
 * 
 *         for k in ['filename', 'ignore_case', 'read_only', 'want_lock', 'fdatasync_on_close']:
 *             if kwargs.has_key(k):             # <<<<<<<<<<<<<<
 *                 del kwargs[k]
 *         if kwargs:
 */
    __pyx_t_4 = PyDict_Contains(__pyx_v_kwargs, __pyx_v_k); if (unlikely(__pyx_t_4 == -1)) __PYX_ERR(0, 342, __pyx_L1_error)
    __pyx_t_5 = (__pyx_t_4 != 0);
    if (__pyx_t_5) {

      /* "_hydra.pyx":343
 *         for k in ['filename', 'ignore_case', 'read_only', 'want_lock', 'fdatasync_on_close']:
 *             if kwargs.has_key(k):
 *                 del kwargs[k]             # <<<<<<<<<<<<<<
 *         if kwargs:
 *             raise RuntimeError, "Unexpected kwargs: %s" % str(kwargs)
 */
      if (unlikely(PyDict_DelItem(__pyx_v_kwargs, __pyx_v_k) < 0)) __PYX_ERR(0, 343, __pyx_L1_error)

      /* "_hydra.pyx":342
 * 
 *         for k in ['filename', 'ignore_case', 'read_only', 'want_lock', 'fdatasync_on_close']:
 *             if kwargs.has_key(k):             # <<<<<<<<<<<<<<
 *                 del kwargs[k]
 *         if kwargs:
 */
    }

    /* "_hydra.pyx":341
 *         fdatasync_on_close = kwargs.get('fdatasync_on_close', True)
 * 
 *         for k in ['filename', 'ignore_case', 'read_only', 'want_lock', 'fdatasync_on_close']:             # <<<<<<<<<<<<<<
 *             if kwargs.has_key(k):
 *                 del kwargs[k]
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_hydra.pyx":344
 *             if kwargs.has_key(k):
 *                 del kwargs[k]
 *         if kwargs:             # <<<<<<<<<<<<<<
 *             raise RuntimeError, "Unexpected kwargs: %s" % str(kwargs)
 * 
 */
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_kwargs); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 344, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "_hydra.pyx":345
 *                 del kwargs[k]
 *         if kwargs:
 *             raise RuntimeError, "Unexpected kwargs: %s" % str(kwargs)             # <<<<<<<<<<<<<<
 * 
 *         if not filename:
 */
    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 345, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_v_kwargs);
    __Pyx_GIVEREF(__pyx_v_kwargs);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_kwargs);
    __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)(&PyString_Type)), __pyx_t_1, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 345, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_Unexpected_kwargs_s, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 345, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_builtin_RuntimeError, __pyx_t_1, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 345, __pyx_L1_error)

    /* "_hydra.pyx":344
 *             if kwargs.has_key(k):
 *                 del kwargs[k]
 *         if kwargs:             # <<<<<<<<<<<<<<
 *             raise RuntimeError, "Unexpected kwargs: %s" % str(kwargs)
 * 
 */
  }

  /* "_hydra.pyx":347
 *             raise RuntimeError, "Unexpected kwargs: %s" % str(kwargs)
 * 
 *         if not filename:             # <<<<<<<<<<<<<<
 *             fileobj = tempfile.NamedTemporaryFile(delete=True)
 *             fileobj.file.close()
 */
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_filename); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 347, __pyx_L1_error)
  __pyx_t_4 = ((!__pyx_t_5) != 0);
  if (__pyx_t_4) {

    /* "_hydra.pyx":348
 * 
 *         if not filename:
 *             fileobj = tempfile.NamedTemporaryFile(delete=True)             # <<<<<<<<<<<<<<
 *             fileobj.file.close()
 *             filename = fileobj.name
 */
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_tempfile); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 348, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_NamedTemporaryFile); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 348, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 348, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_delete, Py_True) < 0) __PYX_ERR(0, 348, __pyx_L1_error)
    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 348, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_fileobj = __pyx_t_6;
    __pyx_t_6 = 0;

    /* "_hydra.pyx":349
 *         if not filename:
 *             fileobj = tempfile.NamedTemporaryFile(delete=True)
 *             fileobj.file.close()             # <<<<<<<<<<<<<<
 *             filename = fileobj.name
 * 
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_fileobj, __pyx_n_s_file); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 349, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_close); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 349, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (__pyx_t_1) {
      __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 349, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    } else {
      __pyx_t_6 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 349, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "_hydra.pyx":350
 *             fileobj = tempfile.NamedTemporaryFile(delete=True)
 *             fileobj.file.close()
 *             filename = fileobj.name             # <<<<<<<<<<<<<<
 * 
 *         assert 0 < maxFalsePosProbability <= 1.0, "Invalid probability"
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_fileobj, __pyx_n_s_name); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 350, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF_SET(__pyx_v_filename, __pyx_t_6);
    __pyx_t_6 = 0;

    /* "_hydra.pyx":347
 *             raise RuntimeError, "Unexpected kwargs: %s" % str(kwargs)
 * 
 *         if not filename:             # <<<<<<<<<<<<<<
 *             fileobj = tempfile.NamedTemporaryFile(delete=True)
 *             fileobj.file.close()
 */
  }

  /* "_hydra.pyx":352
 *             filename = fileobj.name
 * 
 *         assert 0 < maxFalsePosProbability <= 1.0, "Invalid probability"             # <<<<<<<<<<<<<<
 *         bucketsPerElement = cls._maxBucketsPerElement(numElements)
 *         spec = BloomCalculations.computeBloomSpec2(bucketsPerElement, maxFalsePosProbability)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!Py_OptimizeFlag)) {
    __pyx_t_6 = PyObject_RichCompare(__pyx_int_0, __pyx_v_maxFalsePosProbability, Py_LT); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 352, __pyx_L1_error)
    if (__Pyx_PyObject_IsTrue(__pyx_t_6)) {
      __Pyx_DECREF(__pyx_t_6);
      __pyx_t_6 = PyObject_RichCompare(__pyx_v_maxFalsePosProbability, __pyx_float_1_0, Py_LE); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 352, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 352, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_4)) {
      PyErr_SetObject(PyExc_AssertionError, __pyx_kp_s_Invalid_probability);
      __PYX_ERR(0, 352, __pyx_L1_error)
    }
  }
  #endif

  /* "_hydra.pyx":353
 * 
 *         assert 0 < maxFalsePosProbability <= 1.0, "Invalid probability"
 *         bucketsPerElement = cls._maxBucketsPerElement(numElements)             # <<<<<<<<<<<<<<
 *         spec = BloomCalculations.computeBloomSpec2(bucketsPerElement, maxFalsePosProbability)
 *         bitmap = cls._bucketsFor(numElements, spec.bucketsPerElement, filename, read_only, want_lock=want_lock, fdatasync_on_close=fdatasync_on_close)
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_cls), __pyx_n_s_maxBucketsPerElement_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 353, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_1 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_1) {
    __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_numElements); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 353, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
  } else {
    __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 353, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_1); __pyx_t_1 = NULL;
    __Pyx_INCREF(__pyx_v_numElements);
    __Pyx_GIVEREF(__pyx_v_numElements);
    PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_v_numElements);
    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 353, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_bucketsPerElement = __pyx_t_6;
  __pyx_t_6 = 0;

  /* "_hydra.pyx":354
 *         assert 0 < maxFalsePosProbability <= 1.0, "Invalid probability"
 *         bucketsPerElement = cls._maxBucketsPerElement(numElements)
 *         spec = BloomCalculations.computeBloomSpec2(bucketsPerElement, maxFalsePosProbability)             # <<<<<<<<<<<<<<
 *         bitmap = cls._bucketsFor(numElements, spec.bucketsPerElement, filename, read_only, want_lock=want_lock, fdatasync_on_close=fdatasync_on_close)
 *         bf = BloomFilter(spec.K, bitmap, ignore_case)
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_6_hydra_BloomCalculations), __pyx_n_s_computeBloomSpec2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 354, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_7 = NULL;
  __pyx_t_2 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_7)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_7);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
      __pyx_t_2 = 1;
    }
  }
  __pyx_t_1 = PyTuple_New(2+__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 354, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (__pyx_t_7) {
    __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_7); __pyx_t_7 = NULL;
  }
  __Pyx_INCREF(__pyx_v_bucketsPerElement);
  __Pyx_GIVEREF(__pyx_v_bucketsPerElement);
  PyTuple_SET_ITEM(__pyx_t_1, 0+__pyx_t_2, __pyx_v_bucketsPerElement);
  __Pyx_INCREF(__pyx_v_maxFalsePosProbability);
  __Pyx_GIVEREF(__pyx_v_maxFalsePosProbability);
  PyTuple_SET_ITEM(__pyx_t_1, 1+__pyx_t_2, __pyx_v_maxFalsePosProbability);
  __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_1, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 354, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_spec = __pyx_t_6;
  __pyx_t_6 = 0;

  /* "_hydra.pyx":355
 *         bucketsPerElement = cls._maxBucketsPerElement(numElements)
 *         spec = BloomCalculations.computeBloomSpec2(bucketsPerElement, maxFalsePosProbability)
 *         bitmap = cls._bucketsFor(numElements, spec.bucketsPerElement, filename, read_only, want_lock=want_lock, fdatasync_on_close=fdatasync_on_close)             # <<<<<<<<<<<<<<
 *         bf = BloomFilter(spec.K, bitmap, ignore_case)
 *         if not filename:
 */
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_cls), __pyx_n_s_bucketsFor); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 355, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_spec, __pyx_n_s_bucketsPerElement); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 355, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_1 = PyTuple_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 355, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_numElements);
  __Pyx_GIVEREF(__pyx_v_numElements);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_numElements);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_3);
  __Pyx_INCREF(__pyx_v_filename);
  __Pyx_GIVEREF(__pyx_v_filename);
  PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_filename);
  __Pyx_INCREF(__pyx_v_read_only);
  __Pyx_GIVEREF(__pyx_v_read_only);
  PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_v_read_only);
  __pyx_t_3 = 0;
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 355, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_want_lock, __pyx_v_want_lock) < 0) __PYX_ERR(0, 355, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_fdatasync_on_close, __pyx_v_fdatasync_on_close) < 0) __PYX_ERR(0, 355, __pyx_L1_error)
  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 355, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_bitmap = __pyx_t_7;
  __pyx_t_7 = 0;

  /* "_hydra.pyx":356
 *         spec = BloomCalculations.computeBloomSpec2(bucketsPerElement, maxFalsePosProbability)
 *         bitmap = cls._bucketsFor(numElements, spec.bucketsPerElement, filename, read_only, want_lock=want_lock, fdatasync_on_close=fdatasync_on_close)
 *         bf = BloomFilter(spec.K, bitmap, ignore_case)             # <<<<<<<<<<<<<<
 *         if not filename:
 *             bf._tempfile = fileobj
 */
  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_spec, __pyx_n_s_K); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 356, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 356, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_7);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_7);
  __Pyx_INCREF(__pyx_v_bitmap);
  __Pyx_GIVEREF(__pyx_v_bitmap);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_bitmap);
  __Pyx_INCREF(__pyx_v_ignore_case);
  __Pyx_GIVEREF(__pyx_v_ignore_case);
  PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_v_ignore_case);
  __pyx_t_7 = 0;
  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_6_hydra_BloomFilter), __pyx_t_3, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 356, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_bf = ((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_t_7);
  __pyx_t_7 = 0;

  /* "_hydra.pyx":357
 *         bitmap = cls._bucketsFor(numElements, spec.bucketsPerElement, filename, read_only, want_lock=want_lock, fdatasync_on_close=fdatasync_on_close)
 *         bf = BloomFilter(spec.K, bitmap, ignore_case)
 *         if not filename:             # <<<<<<<<<<<<<<
 *             bf._tempfile = fileobj
 *         return bf
 */
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_filename); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 357, __pyx_L1_error)
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "_hydra.pyx":358
 *         bf = BloomFilter(spec.K, bitmap, ignore_case)
 *         if not filename:
 *             bf._tempfile = fileobj             # <<<<<<<<<<<<<<
 *         return bf
 * 
 */
    if (unlikely(!__pyx_v_fileobj)) { __Pyx_RaiseUnboundLocalError("fileobj"); __PYX_ERR(0, 358, __pyx_L1_error) }
    __Pyx_INCREF(__pyx_v_fileobj);
    __Pyx_GIVEREF(__pyx_v_fileobj);
    __Pyx_GOTREF(__pyx_v_bf->_tempfile);
    __Pyx_DECREF(__pyx_v_bf->_tempfile);
    __pyx_v_bf->_tempfile = __pyx_v_fileobj;

    /* "_hydra.pyx":357
 *         bitmap = cls._bucketsFor(numElements, spec.bucketsPerElement, filename, read_only, want_lock=want_lock, fdatasync_on_close=fdatasync_on_close)
 *         bf = BloomFilter(spec.K, bitmap, ignore_case)
 *         if not filename:             # <<<<<<<<<<<<<<
 *             bf._tempfile = fileobj
 *         return bf
 */
  }

  /* "_hydra.pyx":359
 *         if not filename:
 *             bf._tempfile = fileobj
 *         return bf             # <<<<<<<<<<<<<<
 * 
 *     def __setitem__(self, key, int ignored):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_bf));
  __pyx_r = ((PyObject *)__pyx_v_bf);
  goto __pyx_L0;

  /* "_hydra.pyx":313
 * 
 *     @classmethod
 *     def getFilter(cls, numElements, maxFalsePosProbability, **kwargs):             # <<<<<<<<<<<<<<
 *         """
 *         Create a bloom filter.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("_hydra.BloomFilter.getFilter", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_filename);
  __Pyx_XDECREF(__pyx_v_ignore_case);
  __Pyx_XDECREF(__pyx_v_read_only);
  __Pyx_XDECREF(__pyx_v_want_lock);
  __Pyx_XDECREF(__pyx_v_fdatasync_on_close);
  __Pyx_XDECREF(__pyx_v_k);
  __Pyx_XDECREF(__pyx_v_fileobj);
  __Pyx_XDECREF(__pyx_v_bucketsPerElement);
  __Pyx_XDECREF(__pyx_v_spec);
  __Pyx_XDECREF(__pyx_v_bitmap);
  __Pyx_XDECREF((PyObject *)__pyx_v_bf);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":361
 *         return bf
 * 
 *     def __setitem__(self, key, int ignored):             # <<<<<<<<<<<<<<
 *         self.add(key)
 * 
 */

/* Python wrapper */
static int __pyx_pw_6_hydra_11BloomFilter_19__setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_key, PyObject *__pyx_arg_ignored); /*proto*/
static int __pyx_pw_6_hydra_11BloomFilter_19__setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_key, PyObject *__pyx_arg_ignored) {
  CYTHON_UNUSED int __pyx_v_ignored;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setitem__ (wrapper)", 0);
  assert(__pyx_arg_ignored); {
    __pyx_v_ignored = __Pyx_PyInt_As_int(__pyx_arg_ignored); if (unlikely((__pyx_v_ignored == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 361, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("_hydra.BloomFilter.__setitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_18__setitem__(((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_v_self), ((PyObject *)__pyx_v_key), ((int)__pyx_v_ignored));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_6_hydra_11BloomFilter_18__setitem__(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_key, CYTHON_UNUSED int __pyx_v_ignored) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setitem__", 0);

  /* "_hydra.pyx":362
 * 
 *     def __setitem__(self, key, int ignored):
 *         self.add(key)             # <<<<<<<<<<<<<<
 * 
 *     def __getitem__(self, key):
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_6_hydra_BloomFilter *)__pyx_v_self->__pyx_vtab)->add(__pyx_v_self, __pyx_v_key, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 362, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_hydra.pyx":361
 *         return bf
 * 
 *     def __setitem__(self, key, int ignored):             # <<<<<<<<<<<<<<
 *         self.add(key)
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.BloomFilter.__setitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":364
 *         self.add(key)
 * 
 *     def __getitem__(self, key):             # <<<<<<<<<<<<<<
 *         return int(self.contains(key))
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_11BloomFilter_21__getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_key); /*proto*/
static PyObject *__pyx_pw_6_hydra_11BloomFilter_21__getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_key) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__getitem__ (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_20__getitem__(((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_v_self), ((PyObject *)__pyx_v_key));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_11BloomFilter_20__getitem__(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_key) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("__getitem__", 0);

  /* "_hydra.pyx":365
 * 
 *     def __getitem__(self, key):
 *         return int(self.contains(key))             # <<<<<<<<<<<<<<
 * 
 *     def __contains__(self, ustring):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_6_hydra_BloomFilter *)__pyx_v_self->__pyx_vtab)->contains(__pyx_v_self, __pyx_v_key, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 365, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyNumber_Int(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 365, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "_hydra.pyx":364
 *         self.add(key)
 * 
 *     def __getitem__(self, key):             # <<<<<<<<<<<<<<
 *         return int(self.contains(key))
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("_hydra.BloomFilter.__getitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":367
 *         return int(self.contains(key))
 * 
 *     def __contains__(self, ustring):             # <<<<<<<<<<<<<<
 *         return self.contains(ustring)
 * 
 */

/* Python wrapper */
static int __pyx_pw_6_hydra_11BloomFilter_23__contains__(PyObject *__pyx_v_self, PyObject *__pyx_v_ustring); /*proto*/
static int __pyx_pw_6_hydra_11BloomFilter_23__contains__(PyObject *__pyx_v_self, PyObject *__pyx_v_ustring) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__contains__ (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_22__contains__(((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_v_self), ((PyObject *)__pyx_v_ustring));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_6_hydra_11BloomFilter_22__contains__(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_ustring) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("__contains__", 0);

  /* "_hydra.pyx":368
 * 
 *     def __contains__(self, ustring):
 *         return self.contains(ustring)             # <<<<<<<<<<<<<<
 * 
 *     @cython.boundscheck(False)
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_6_hydra_BloomFilter *)__pyx_v_self->__pyx_vtab)->contains(__pyx_v_self, __pyx_v_ustring, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 368, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 368, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  goto __pyx_L0;

  /* "_hydra.pyx":367
 *         return int(self.contains(key))
 * 
 *     def __contains__(self, ustring):             # <<<<<<<<<<<<<<
 *         return self.contains(ustring)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.BloomFilter.__contains__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":371
 * 
 *     @cython.boundscheck(False)
 *     cpdef add(self, ustring):             # <<<<<<<<<<<<<<
 *         """ Add a key into the filter.  Just like a set.  """
 *         cdef unsigned long long i
 */

static PyObject *__pyx_pw_6_hydra_11BloomFilter_25add(PyObject *__pyx_v_self, PyObject *__pyx_v_ustring); /*proto*/
static PyObject *__pyx_f_6_hydra_11BloomFilter_add(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_ustring, int __pyx_skip_dispatch) {
  unsigned PY_LONG_LONG __pyx_v_i;
  unsigned PY_LONG_LONG __pyx_v__bucket_indexes[0x3E8];
  PyObject *__pyx_v_key = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  char *__pyx_t_8;
  unsigned long __pyx_t_9;
  unsigned int __pyx_t_10;
  unsigned PY_LONG_LONG __pyx_t_11;
  __Pyx_RefNannySetupContext("add", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_add); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 371, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_25add)) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (!__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_ustring); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 371, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
      } else {
        __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 371, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
        __Pyx_INCREF(__pyx_v_ustring);
        __Pyx_GIVEREF(__pyx_v_ustring);
        PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_v_ustring);
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 371, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "_hydra.pyx":376
 *         cdef unsigned long long _bucket_indexes[1000]
 * 
 *         if isinstance(ustring, unicode):             # <<<<<<<<<<<<<<
 *             key = ustring.encode('utf8')
 *         else:
 */
  __pyx_t_6 = PyUnicode_Check(__pyx_v_ustring); 
  __pyx_t_7 = (__pyx_t_6 != 0);
  if (__pyx_t_7) {

    /* "_hydra.pyx":377
 * 
 *         if isinstance(ustring, unicode):
 *             key = ustring.encode('utf8')             # <<<<<<<<<<<<<<
 *         else:
 *             key = ustring
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_ustring, __pyx_n_s_encode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 377, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 377, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_key = __pyx_t_2;
    __pyx_t_2 = 0;

    /* "_hydra.pyx":376
 *         cdef unsigned long long _bucket_indexes[1000]
 * 
 *         if isinstance(ustring, unicode):             # <<<<<<<<<<<<<<
 *             key = ustring.encode('utf8')
 *         else:
 */
    goto __pyx_L3;
  }

  /* "_hydra.pyx":379
 *             key = ustring.encode('utf8')
 *         else:
 *             key = ustring             # <<<<<<<<<<<<<<
 * 
 *         if self._ignore_case:
 */
  /*else*/ {
    __Pyx_INCREF(__pyx_v_ustring);
    __pyx_v_key = __pyx_v_ustring;
  }
  __pyx_L3:;

  /* "_hydra.pyx":381
 *             key = ustring
 * 
 *         if self._ignore_case:             # <<<<<<<<<<<<<<
 *             c_lcase(key);
 * 
 */
  __pyx_t_7 = (__pyx_v_self->_ignore_case != 0);
  if (__pyx_t_7) {

    /* "_hydra.pyx":382
 * 
 *         if self._ignore_case:
 *             c_lcase(key);             # <<<<<<<<<<<<<<
 * 
 *         self._get_hash_buckets(key, _bucket_indexes, self._hashCount, self.buckets())
 */
    __pyx_t_8 = __Pyx_PyObject_AsString(__pyx_v_key); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) __PYX_ERR(0, 382, __pyx_L1_error)
    __pyx_f_6_hydra_c_lcase(__pyx_t_8);

    /* "_hydra.pyx":381
 *             key = ustring
 * 
 *         if self._ignore_case:             # <<<<<<<<<<<<<<
 *             c_lcase(key);
 * 
 */
  }

  /* "_hydra.pyx":384
 *             c_lcase(key);
 * 
 *         self._get_hash_buckets(key, _bucket_indexes, self._hashCount, self.buckets())             # <<<<<<<<<<<<<<
 *         for i in range(self._hashCount):
 *             self._bitmap[_bucket_indexes[i]] = 1
 */
  if (!(likely(PyBytes_CheckExact(__pyx_v_key))||((__pyx_v_key) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_key)->tp_name), 0))) __PYX_ERR(0, 384, __pyx_L1_error)
  __pyx_t_2 = ((struct __pyx_vtabstruct_6_hydra_BloomFilter *)__pyx_v_self->__pyx_vtab)->buckets(__pyx_v_self, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 384, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_9 = __Pyx_PyInt_As_unsigned_long(__pyx_t_2); if (unlikely((__pyx_t_9 == (unsigned long)-1) && PyErr_Occurred())) __PYX_ERR(0, 384, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  ((struct __pyx_vtabstruct_6_hydra_BloomFilter *)__pyx_v_self->__pyx_vtab)->_get_hash_buckets(__pyx_v_self, ((PyObject*)__pyx_v_key), __pyx_v__bucket_indexes, __pyx_v_self->_hashCount, __pyx_t_9);

  /* "_hydra.pyx":385
 * 
 *         self._get_hash_buckets(key, _bucket_indexes, self._hashCount, self.buckets())
 *         for i in range(self._hashCount):             # <<<<<<<<<<<<<<
 *             self._bitmap[_bucket_indexes[i]] = 1
 * 
 */
  __pyx_t_10 = __pyx_v_self->_hashCount;
  for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_10; __pyx_t_11+=1) {
    __pyx_v_i = __pyx_t_11;

    /* "_hydra.pyx":386
 *         self._get_hash_buckets(key, _bucket_indexes, self._hashCount, self.buckets())
 *         for i in range(self._hashCount):
 *             self._bitmap[_bucket_indexes[i]] = 1             # <<<<<<<<<<<<<<
 * 
 *     @cython.boundscheck(False)
 */
    if (unlikely(__Pyx_SetItemInt(((PyObject *)__pyx_v_self->_bitmap), (__pyx_v__bucket_indexes[__pyx_v_i]), __pyx_int_1, unsigned PY_LONG_LONG, 0, __Pyx_PyInt_From_unsigned_PY_LONG_LONG, 0, 0, 0) < 0)) __PYX_ERR(0, 386, __pyx_L1_error)
  }

  /* "_hydra.pyx":371
 * 
 *     @cython.boundscheck(False)
 *     cpdef add(self, ustring):             # <<<<<<<<<<<<<<
 *         """ Add a key into the filter.  Just like a set.  """
 *         cdef unsigned long long i
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("_hydra.BloomFilter.add", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_key);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_11BloomFilter_25add(PyObject *__pyx_v_self, PyObject *__pyx_v_ustring); /*proto*/
static char __pyx_doc_6_hydra_11BloomFilter_24add[] = " Add a key into the filter.  Just like a set.  ";
static PyObject *__pyx_pw_6_hydra_11BloomFilter_25add(PyObject *__pyx_v_self, PyObject *__pyx_v_ustring) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("add (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_24add(((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_v_self), ((PyObject *)__pyx_v_ustring));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_11BloomFilter_24add(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_ustring) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("add", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_6_hydra_11BloomFilter_add(__pyx_v_self, __pyx_v_ustring, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 371, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.BloomFilter.add", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":389
 * 
 *     @cython.boundscheck(False)
 *     cpdef contains(self, ustring):             # <<<<<<<<<<<<<<
 *         """ Check if a key is in the bloom filter.  May return a false positive. """
 *         cdef unsigned long long _bucket_indexes[1000]
 */

static PyObject *__pyx_pw_6_hydra_11BloomFilter_27contains(PyObject *__pyx_v_self, PyObject *__pyx_v_ustring); /*proto*/
static PyObject *__pyx_f_6_hydra_11BloomFilter_contains(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_ustring, int __pyx_skip_dispatch) {
  unsigned PY_LONG_LONG __pyx_v__bucket_indexes[0x3E8];
  unsigned PY_LONG_LONG __pyx_v_i;
  PyObject *__pyx_v_key = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  char *__pyx_t_8;
  unsigned long __pyx_t_9;
  unsigned int __pyx_t_10;
  unsigned PY_LONG_LONG __pyx_t_11;
  __Pyx_RefNannySetupContext("contains", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_contains); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 389, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_27contains)) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (!__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_ustring); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 389, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
      } else {
        __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 389, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
        __Pyx_INCREF(__pyx_v_ustring);
        __Pyx_GIVEREF(__pyx_v_ustring);
        PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_v_ustring);
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 389, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "_hydra.pyx":394
 *         cdef unsigned long long i
 * 
 *         if isinstance(ustring, unicode):             # <<<<<<<<<<<<<<
 *             key = ustring.encode('utf8')
 *         else:
 */
  __pyx_t_6 = PyUnicode_Check(__pyx_v_ustring); 
  __pyx_t_7 = (__pyx_t_6 != 0);
  if (__pyx_t_7) {

    /* "_hydra.pyx":395
 * 
 *         if isinstance(ustring, unicode):
 *             key = ustring.encode('utf8')             # <<<<<<<<<<<<<<
 *         else:
 *             key = ustring
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_ustring, __pyx_n_s_encode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 395, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 395, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_key = __pyx_t_2;
    __pyx_t_2 = 0;

    /* "_hydra.pyx":394
 *         cdef unsigned long long i
 * 
 *         if isinstance(ustring, unicode):             # <<<<<<<<<<<<<<
 *             key = ustring.encode('utf8')
 *         else:
 */
    goto __pyx_L3;
  }

  /* "_hydra.pyx":397
 *             key = ustring.encode('utf8')
 *         else:
 *             key = ustring             # <<<<<<<<<<<<<<
 * 
 *         if self._ignore_case:
 */
  /*else*/ {
    __Pyx_INCREF(__pyx_v_ustring);
    __pyx_v_key = __pyx_v_ustring;
  }
  __pyx_L3:;

  /* "_hydra.pyx":399
 *             key = ustring
 * 
 *         if self._ignore_case:             # <<<<<<<<<<<<<<
 *             c_lcase(key);
 *         self._get_hash_buckets(key, _bucket_indexes, self._hashCount, self.buckets())
 */
  __pyx_t_7 = (__pyx_v_self->_ignore_case != 0);
  if (__pyx_t_7) {

    /* "_hydra.pyx":400
 * 
 *         if self._ignore_case:
 *             c_lcase(key);             # <<<<<<<<<<<<<<
 *         self._get_hash_buckets(key, _bucket_indexes, self._hashCount, self.buckets())
 *         for i in range(self._hashCount):
 */
    __pyx_t_8 = __Pyx_PyObject_AsString(__pyx_v_key); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) __PYX_ERR(0, 400, __pyx_L1_error)
    __pyx_f_6_hydra_c_lcase(__pyx_t_8);

    /* "_hydra.pyx":399
 *             key = ustring
 * 
 *         if self._ignore_case:             # <<<<<<<<<<<<<<
 *             c_lcase(key);
 *         self._get_hash_buckets(key, _bucket_indexes, self._hashCount, self.buckets())
 */
  }

  /* "_hydra.pyx":401
 *         if self._ignore_case:
 *             c_lcase(key);
 *         self._get_hash_buckets(key, _bucket_indexes, self._hashCount, self.buckets())             # <<<<<<<<<<<<<<
 *         for i in range(self._hashCount):
 *             if not self._bitmap[_bucket_indexes[i]]:
 */
  if (!(likely(PyBytes_CheckExact(__pyx_v_key))||((__pyx_v_key) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_key)->tp_name), 0))) __PYX_ERR(0, 401, __pyx_L1_error)
  __pyx_t_2 = ((struct __pyx_vtabstruct_6_hydra_BloomFilter *)__pyx_v_self->__pyx_vtab)->buckets(__pyx_v_self, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 401, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_9 = __Pyx_PyInt_As_unsigned_long(__pyx_t_2); if (unlikely((__pyx_t_9 == (unsigned long)-1) && PyErr_Occurred())) __PYX_ERR(0, 401, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  ((struct __pyx_vtabstruct_6_hydra_BloomFilter *)__pyx_v_self->__pyx_vtab)->_get_hash_buckets(__pyx_v_self, ((PyObject*)__pyx_v_key), __pyx_v__bucket_indexes, __pyx_v_self->_hashCount, __pyx_t_9);

  /* "_hydra.pyx":402
 *             c_lcase(key);
 *         self._get_hash_buckets(key, _bucket_indexes, self._hashCount, self.buckets())
 *         for i in range(self._hashCount):             # <<<<<<<<<<<<<<
 *             if not self._bitmap[_bucket_indexes[i]]:
 *                 return False
 */
  __pyx_t_10 = __pyx_v_self->_hashCount;
  for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_10; __pyx_t_11+=1) {
    __pyx_v_i = __pyx_t_11;

    /* "_hydra.pyx":403
 *         self._get_hash_buckets(key, _bucket_indexes, self._hashCount, self.buckets())
 *         for i in range(self._hashCount):
 *             if not self._bitmap[_bucket_indexes[i]]:             # <<<<<<<<<<<<<<
 *                 return False
 *         return True
 */
    __pyx_t_2 = __Pyx_GetItemInt(((PyObject *)__pyx_v_self->_bitmap), (__pyx_v__bucket_indexes[__pyx_v_i]), unsigned PY_LONG_LONG, 0, __Pyx_PyInt_From_unsigned_PY_LONG_LONG, 0, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 403, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 403, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_6 = ((!__pyx_t_7) != 0);
    if (__pyx_t_6) {

      /* "_hydra.pyx":404
 *         for i in range(self._hashCount):
 *             if not self._bitmap[_bucket_indexes[i]]:
 *                 return False             # <<<<<<<<<<<<<<
 *         return True
 * 
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      goto __pyx_L0;

      /* "_hydra.pyx":403
 *         self._get_hash_buckets(key, _bucket_indexes, self._hashCount, self.buckets())
 *         for i in range(self._hashCount):
 *             if not self._bitmap[_bucket_indexes[i]]:             # <<<<<<<<<<<<<<
 *                 return False
 *         return True
 */
    }
  }

  /* "_hydra.pyx":405
 *             if not self._bitmap[_bucket_indexes[i]]:
 *                 return False
 *         return True             # <<<<<<<<<<<<<<
 * 
 *     cpdef buckets(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_True);
  __pyx_r = Py_True;
  goto __pyx_L0;

  /* "_hydra.pyx":389
 * 
 *     @cython.boundscheck(False)
 *     cpdef contains(self, ustring):             # <<<<<<<<<<<<<<
 *         """ Check if a key is in the bloom filter.  May return a false positive. """
 *         cdef unsigned long long _bucket_indexes[1000]
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("_hydra.BloomFilter.contains", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_key);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_11BloomFilter_27contains(PyObject *__pyx_v_self, PyObject *__pyx_v_ustring); /*proto*/
static char __pyx_doc_6_hydra_11BloomFilter_26contains[] = " Check if a key is in the bloom filter.  May return a false positive. ";
static PyObject *__pyx_pw_6_hydra_11BloomFilter_27contains(PyObject *__pyx_v_self, PyObject *__pyx_v_ustring) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("contains (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_26contains(((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_v_self), ((PyObject *)__pyx_v_ustring));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_11BloomFilter_26contains(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_ustring) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("contains", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_6_hydra_11BloomFilter_contains(__pyx_v_self, __pyx_v_ustring, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 389, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.BloomFilter.contains", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":407
 *         return True
 * 
 *     cpdef buckets(self):             # <<<<<<<<<<<<<<
 *         """ Return the number of total buckets (bits) in the bloom filter """
 *         return self._bitmap.size()
 */

static PyObject *__pyx_pw_6_hydra_11BloomFilter_29buckets(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_6_hydra_11BloomFilter_buckets(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("buckets", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_buckets); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 407, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_29buckets)) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 407, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 407, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "_hydra.pyx":409
 *     cpdef buckets(self):
 *         """ Return the number of total buckets (bits) in the bloom filter """
 *         return self._bitmap.size()             # <<<<<<<<<<<<<<
 * 
 *     def getHashBuckets(self, ustring, unsigned int hashCount, unsigned long long max):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_6_hydra_MMapBitField *)__pyx_v_self->_bitmap->__pyx_vtab)->size(__pyx_v_self->_bitmap, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 409, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "_hydra.pyx":407
 *         return True
 * 
 *     cpdef buckets(self):             # <<<<<<<<<<<<<<
 *         """ Return the number of total buckets (bits) in the bloom filter """
 *         return self._bitmap.size()
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_hydra.BloomFilter.buckets", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_11BloomFilter_29buckets(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_6_hydra_11BloomFilter_28buckets[] = " Return the number of total buckets (bits) in the bloom filter ";
static PyObject *__pyx_pw_6_hydra_11BloomFilter_29buckets(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("buckets (wrapper)", 0);
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_28buckets(((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_11BloomFilter_28buckets(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("buckets", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_6_hydra_11BloomFilter_buckets(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 407, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_hydra.BloomFilter.buckets", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":411
 *         return self._bitmap.size()
 * 
 *     def getHashBuckets(self, ustring, unsigned int hashCount, unsigned long long max):             # <<<<<<<<<<<<<<
 *         """ This method is just available for test purposes.  Not actually useful for normal users. """
 *         cdef unsigned long long _bucket_indexes[1000]
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_11BloomFilter_31getHashBuckets(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6_hydra_11BloomFilter_30getHashBuckets[] = " This method is just available for test purposes.  Not actually useful for normal users. ";
static PyObject *__pyx_pw_6_hydra_11BloomFilter_31getHashBuckets(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_ustring = 0;
  unsigned int __pyx_v_hashCount;
  unsigned PY_LONG_LONG __pyx_v_max;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getHashBuckets (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ustring,&__pyx_n_s_hashCount,&__pyx_n_s_max,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ustring)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_hashCount)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getHashBuckets", 1, 3, 3, 1); __PYX_ERR(0, 411, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_max)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("getHashBuckets", 1, 3, 3, 2); __PYX_ERR(0, 411, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getHashBuckets") < 0)) __PYX_ERR(0, 411, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_ustring = values[0];
    __pyx_v_hashCount = __Pyx_PyInt_As_unsigned_int(values[1]); if (unlikely((__pyx_v_hashCount == (unsigned int)-1) && PyErr_Occurred())) __PYX_ERR(0, 411, __pyx_L3_error)
    __pyx_v_max = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(values[2]); if (unlikely((__pyx_v_max == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 411, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("getHashBuckets", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 411, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_hydra.BloomFilter.getHashBuckets", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_30getHashBuckets(((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_v_self), __pyx_v_ustring, __pyx_v_hashCount, __pyx_v_max);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_11BloomFilter_30getHashBuckets(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_ustring, unsigned int __pyx_v_hashCount, unsigned PY_LONG_LONG __pyx_v_max) {
  unsigned PY_LONG_LONG __pyx_v__bucket_indexes[0x3E8];
  PyObject *__pyx_v_key = NULL;
  PyObject *__pyx_v_result = NULL;
  unsigned int __pyx_v_i;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  unsigned int __pyx_t_5;
  unsigned int __pyx_t_6;
  int __pyx_t_7;
  __Pyx_RefNannySetupContext("getHashBuckets", 0);

  /* "_hydra.pyx":415
 *         cdef unsigned long long _bucket_indexes[1000]
 * 
 *         if isinstance(ustring, unicode):             # <<<<<<<<<<<<<<
 *             key = ustring.encode('utf8')
 *         else:
 */
  __pyx_t_1 = PyUnicode_Check(__pyx_v_ustring); 
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "_hydra.pyx":416
 * 
 *         if isinstance(ustring, unicode):
 *             key = ustring.encode('utf8')             # <<<<<<<<<<<<<<
 *         else:
 *             key = ustring
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_ustring, __pyx_n_s_encode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 416, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 416, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_v_key = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "_hydra.pyx":415
 *         cdef unsigned long long _bucket_indexes[1000]
 * 
 *         if isinstance(ustring, unicode):             # <<<<<<<<<<<<<<
 *             key = ustring.encode('utf8')
 *         else:
 */
    goto __pyx_L3;
  }

  /* "_hydra.pyx":418
 *             key = ustring.encode('utf8')
 *         else:
 *             key = ustring             # <<<<<<<<<<<<<<
 * 
 *         self._get_hash_buckets(key, _bucket_indexes, hashCount, max)
 */
  /*else*/ {
    __Pyx_INCREF(__pyx_v_ustring);
    __pyx_v_key = __pyx_v_ustring;
  }
  __pyx_L3:;

  /* "_hydra.pyx":420
 *             key = ustring
 * 
 *         self._get_hash_buckets(key, _bucket_indexes, hashCount, max)             # <<<<<<<<<<<<<<
 *         result = []
 *         for i in range(hashCount):
 */
  if (!(likely(PyBytes_CheckExact(__pyx_v_key))||((__pyx_v_key) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_key)->tp_name), 0))) __PYX_ERR(0, 420, __pyx_L1_error)
  ((struct __pyx_vtabstruct_6_hydra_BloomFilter *)__pyx_v_self->__pyx_vtab)->_get_hash_buckets(__pyx_v_self, ((PyObject*)__pyx_v_key), __pyx_v__bucket_indexes, __pyx_v_hashCount, __pyx_v_max);

  /* "_hydra.pyx":421
 * 
 *         self._get_hash_buckets(key, _bucket_indexes, hashCount, max)
 *         result = []             # <<<<<<<<<<<<<<
 *         for i in range(hashCount):
 *             result.append(_bucket_indexes[i])
 */
  __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 421, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_v_result = ((PyObject*)__pyx_t_4);
  __pyx_t_4 = 0;

  /* "_hydra.pyx":422
 *         self._get_hash_buckets(key, _bucket_indexes, hashCount, max)
 *         result = []
 *         for i in range(hashCount):             # <<<<<<<<<<<<<<
 *             result.append(_bucket_indexes[i])
 *         return result
 */
  __pyx_t_5 = __pyx_v_hashCount;
  for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
    __pyx_v_i = __pyx_t_6;

    /* "_hydra.pyx":423
 *         result = []
 *         for i in range(hashCount):
 *             result.append(_bucket_indexes[i])             # <<<<<<<<<<<<<<
 *         return result
 * 
 */
    __pyx_t_4 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG((__pyx_v__bucket_indexes[__pyx_v_i])); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 423, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = __Pyx_PyList_Append(__pyx_v_result, __pyx_t_4); if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 423, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }

  /* "_hydra.pyx":424
 *         for i in range(hashCount):
 *             result.append(_bucket_indexes[i])
 *         return result             # <<<<<<<<<<<<<<
 * 
 *     @cython.boundscheck(False)
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_result);
  __pyx_r = __pyx_v_result;
  goto __pyx_L0;

  /* "_hydra.pyx":411
 *         return self._bitmap.size()
 * 
 *     def getHashBuckets(self, ustring, unsigned int hashCount, unsigned long long max):             # <<<<<<<<<<<<<<
 *         """ This method is just available for test purposes.  Not actually useful for normal users. """
 *         cdef unsigned long long _bucket_indexes[1000]
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_hydra.BloomFilter.getHashBuckets", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_key);
  __Pyx_XDECREF(__pyx_v_result);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":427
 * 
 *     @cython.boundscheck(False)
 *     cdef void _get_hash_buckets(self, bytes key, unsigned long long * _bucket_indexes, unsigned int hashCount, unsigned long max):             # <<<<<<<<<<<<<<
 *         """
 *         Murmur is faster than an SHA-based approach and provides as-good collision
 */

static void __pyx_f_6_hydra_11BloomFilter__get_hash_buckets(CYTHON_UNUSED struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, PyObject *__pyx_v_key, unsigned PY_LONG_LONG *__pyx_v__bucket_indexes, unsigned int __pyx_v_hashCount, unsigned long __pyx_v_max) {
  unsigned long __pyx_v_result[2];
  unsigned long __pyx_v_hash1;
  unsigned long __pyx_v_hash2;
  unsigned long __pyx_v_i;
  __Pyx_RefNannyDeclarations
  char *__pyx_t_1;
  Py_ssize_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  unsigned int __pyx_t_5;
  unsigned long __pyx_t_6;
  unsigned long __pyx_t_7;
  __Pyx_RefNannySetupContext("_get_hash_buckets", 0);

  /* "_hydra.pyx":439
 *         cdef unsigned long i
 * 
 *         MurmurHash3_x64_128(<char*>key, len(key), 0, result)             # <<<<<<<<<<<<<<
 *         hash1 = result[0]
 *         MurmurHash3_x64_128(<char*>key, len(key), result[1] & 0xFFFFFFFF, result)
 */
  __pyx_t_1 = __Pyx_PyObject_AsString(__pyx_v_key); if (unlikely((!__pyx_t_1) && PyErr_Occurred())) __PYX_ERR(0, 439, __pyx_L1_error)
  if (unlikely(__pyx_v_key == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 439, __pyx_L1_error)
  }
  __pyx_t_2 = PyBytes_GET_SIZE(__pyx_v_key); if (unlikely(__pyx_t_2 == -1)) __PYX_ERR(0, 439, __pyx_L1_error)
  MurmurHash3_x64_128(((char *)__pyx_t_1), __pyx_t_2, 0, __pyx_v_result);

  /* "_hydra.pyx":440
 * 
 *         MurmurHash3_x64_128(<char*>key, len(key), 0, result)
 *         hash1 = result[0]             # <<<<<<<<<<<<<<
 *         MurmurHash3_x64_128(<char*>key, len(key), result[1] & 0xFFFFFFFF, result)
 *         hash2 = result[0]
 */
  __pyx_v_hash1 = (__pyx_v_result[0]);

  /* "_hydra.pyx":441
 *         MurmurHash3_x64_128(<char*>key, len(key), 0, result)
 *         hash1 = result[0]
 *         MurmurHash3_x64_128(<char*>key, len(key), result[1] & 0xFFFFFFFF, result)             # <<<<<<<<<<<<<<
 *         hash2 = result[0]
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_AsString(__pyx_v_key); if (unlikely((!__pyx_t_1) && PyErr_Occurred())) __PYX_ERR(0, 441, __pyx_L1_error)
  if (unlikely(__pyx_v_key == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 441, __pyx_L1_error)
  }
  __pyx_t_2 = PyBytes_GET_SIZE(__pyx_v_key); if (unlikely(__pyx_t_2 == -1)) __PYX_ERR(0, 441, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyInt_From_unsigned_long((__pyx_v_result[1])); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 441, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PyNumber_And(__pyx_t_3, __pyx_int_4294967295); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 441, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_5 = __Pyx_PyInt_As_unsigned_int(__pyx_t_4); if (unlikely((__pyx_t_5 == (unsigned int)-1) && PyErr_Occurred())) __PYX_ERR(0, 441, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  MurmurHash3_x64_128(((char *)__pyx_t_1), __pyx_t_2, __pyx_t_5, __pyx_v_result);

  /* "_hydra.pyx":442
 *         hash1 = result[0]
 *         MurmurHash3_x64_128(<char*>key, len(key), result[1] & 0xFFFFFFFF, result)
 *         hash2 = result[0]             # <<<<<<<<<<<<<<
 * 
 *         for i in range(hashCount):
 */
  __pyx_v_hash2 = (__pyx_v_result[0]);

  /* "_hydra.pyx":444
 *         hash2 = result[0]
 * 
 *         for i in range(hashCount):             # <<<<<<<<<<<<<<
 *             _bucket_indexes[i] = llabs((hash1 + i * hash2) % max)
 * 
 */
  __pyx_t_5 = __pyx_v_hashCount;
  for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
    __pyx_v_i = __pyx_t_6;

    /* "_hydra.pyx":445
 * 
 *         for i in range(hashCount):
 *             _bucket_indexes[i] = llabs((hash1 + i * hash2) % max)             # <<<<<<<<<<<<<<
 * 
 *     cdef void _strip_newline(self, char *buffer, unsigned int size):
 */
    __pyx_t_7 = (__pyx_v_hash1 + (__pyx_v_i * __pyx_v_hash2));
    if (unlikely(__pyx_v_max == 0)) {
      PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
      __PYX_ERR(0, 445, __pyx_L1_error)
    }
    (__pyx_v__bucket_indexes[__pyx_v_i]) = llabs((__pyx_t_7 % __pyx_v_max));
  }

  /* "_hydra.pyx":427
 * 
 *     @cython.boundscheck(False)
 *     cdef void _get_hash_buckets(self, bytes key, unsigned long long * _bucket_indexes, unsigned int hashCount, unsigned long max):             # <<<<<<<<<<<<<<
 *         """
 *         Murmur is faster than an SHA-based approach and provides as-good collision
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_hydra.BloomFilter._get_hash_buckets", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
}

/* "_hydra.pyx":447
 *             _bucket_indexes[i] = llabs((hash1 + i * hash2) % max)
 * 
 *     cdef void _strip_newline(self, char *buffer, unsigned int size):             # <<<<<<<<<<<<<<
 *         """
 *         Strip newline by overwriting with a null
 */

static void __pyx_f_6_hydra_11BloomFilter__strip_newline(CYTHON_UNUSED struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, char *__pyx_v_buffer, unsigned int __pyx_v_size) {
  unsigned int __pyx_v_i;
  __Pyx_RefNannyDeclarations
  unsigned int __pyx_t_1;
  unsigned int __pyx_t_2;
  int __pyx_t_3;
  __Pyx_RefNannySetupContext("_strip_newline", 0);

  /* "_hydra.pyx":452
 *         """
 *         cdef unsigned int i
 *         for i in range(size):             # <<<<<<<<<<<<<<
 *             if buffer[i] == '\n':
 *                 buffer[i] = '\x00'
 */
  __pyx_t_1 = __pyx_v_size;
  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=1) {
    __pyx_v_i = __pyx_t_2;

    /* "_hydra.pyx":453
 *         cdef unsigned int i
 *         for i in range(size):
 *             if buffer[i] == '\n':             # <<<<<<<<<<<<<<
 *                 buffer[i] = '\x00'
 *                 return
 */
    __pyx_t_3 = (((__pyx_v_buffer[__pyx_v_i]) == '\n') != 0);
    if (__pyx_t_3) {

      /* "_hydra.pyx":454
 *         for i in range(size):
 *             if buffer[i] == '\n':
 *                 buffer[i] = '\x00'             # <<<<<<<<<<<<<<
 *                 return
 * 
 */
      (__pyx_v_buffer[__pyx_v_i]) = '\x00';

      /* "_hydra.pyx":455
 *             if buffer[i] == '\n':
 *                 buffer[i] = '\x00'
 *                 return             # <<<<<<<<<<<<<<
 * 
 *     def bulkload_text(self, char* filename):
 */
      goto __pyx_L0;

      /* "_hydra.pyx":453
 *         cdef unsigned int i
 *         for i in range(size):
 *             if buffer[i] == '\n':             # <<<<<<<<<<<<<<
 *                 buffer[i] = '\x00'
 *                 return
 */
    }
  }

  /* "_hydra.pyx":447
 *             _bucket_indexes[i] = llabs((hash1 + i * hash2) % max)
 * 
 *     cdef void _strip_newline(self, char *buffer, unsigned int size):             # <<<<<<<<<<<<<<
 *         """
 *         Strip newline by overwriting with a null
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
}

/* "_hydra.pyx":457
 *                 return
 * 
 *     def bulkload_text(self, char* filename):             # <<<<<<<<<<<<<<
 *         cdef FILE* file_in = fopen( filename, "r")
 *         cdef char line[128]
 */

/* Python wrapper */
static PyObject *__pyx_pw_6_hydra_11BloomFilter_33bulkload_text(PyObject *__pyx_v_self, PyObject *__pyx_arg_filename); /*proto*/
static PyObject *__pyx_pw_6_hydra_11BloomFilter_33bulkload_text(PyObject *__pyx_v_self, PyObject *__pyx_arg_filename) {
  char *__pyx_v_filename;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("bulkload_text (wrapper)", 0);
  assert(__pyx_arg_filename); {
    __pyx_v_filename = __Pyx_PyObject_AsString(__pyx_arg_filename); if (unlikely((!__pyx_v_filename) && PyErr_Occurred())) __PYX_ERR(0, 457, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("_hydra.BloomFilter.bulkload_text", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6_hydra_11BloomFilter_32bulkload_text(((struct __pyx_obj_6_hydra_BloomFilter *)__pyx_v_self), ((char *)__pyx_v_filename));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6_hydra_11BloomFilter_32bulkload_text(struct __pyx_obj_6_hydra_BloomFilter *__pyx_v_self, char *__pyx_v_filename) {
  FILE *__pyx_v_file_in;
  char __pyx_v_line[0x80];
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  size_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("bulkload_text", 0);

  /* "_hydra.pyx":458
 * 
 *     def bulkload_text(self, char* filename):
 *         cdef FILE* file_in = fopen( filename, "r")             # <<<<<<<<<<<<<<
 *         cdef char line[128]
 *         if file_in:
 */
  __pyx_v_file_in = fopen(__pyx_v_filename, ((char *)"r"));

  /* "_hydra.pyx":460
 *         cdef FILE* file_in = fopen( filename, "r")
 *         cdef char line[128]
 *         if file_in:             # <<<<<<<<<<<<<<
 *             while fgets(line, 128, file_in):
 *                 self._strip_newline(line, len(line))
 */
  __pyx_t_1 = (__pyx_v_file_in != 0);
  if (__pyx_t_1) {

    /* "_hydra.pyx":461
 *         cdef char line[128]
 *         if file_in:
 *             while fgets(line, 128, file_in):             # <<<<<<<<<<<<<<
 *                 self._strip_newline(line, len(line))
 *                 self.add(line)
 */
    while (1) {
      __pyx_t_1 = (fgets(__pyx_v_line, 0x80, __pyx_v_file_in) != 0);
      if (!__pyx_t_1) break;

      /* "_hydra.pyx":462
 *         if file_in:
 *             while fgets(line, 128, file_in):
 *                 self._strip_newline(line, len(line))             # <<<<<<<<<<<<<<
 *                 self.add(line)
 *             # Yeah, i should check for errors. sosumi.
 */
      __pyx_t_2 = strlen(__pyx_v_line); 
      ((struct __pyx_vtabstruct_6_hydra_BloomFilter *)__pyx_v_self->__pyx_vtab)->_strip_newline(__pyx_v_self, __pyx_v_line, __pyx_t_2);

      /* "_hydra.pyx":463
 *             while fgets(line, 128, file_in):
 *                 self._strip_newline(line, len(line))
 *                 self.add(line)             # <<<<<<<<<<<<<<
 *             # Yeah, i should check for errors. sosumi.
 *             fclose(file_in)
 */
      __pyx_t_3 = __Pyx_PyObject_FromString(__pyx_v_line); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 463, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = ((struct __pyx_vtabstruct_6_hydra_BloomFilter *)__pyx_v_self->__pyx_vtab)->add(__pyx_v_self, __pyx_t_3, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 463, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }

    /* "_hydra.pyx":465
 *                 self.add(line)
 *             # Yeah, i should check for errors. sosumi.
 *             fclose(file_in)             # <<<<<<<<<<<<<<
 * 
 * cdef void c_lcase(char* buffer):
 */
    fclose(__pyx_v_file_in);

    /* "_hydra.pyx":460
 *         cdef FILE* file_in = fopen( filename, "r")
 *         cdef char line[128]
 *         if file_in:             # <<<<<<<<<<<<<<
 *             while fgets(line, 128, file_in):
 *                 self._strip_newline(line, len(line))
 */
  }

  /* "_hydra.pyx":457
 *                 return
 * 
 *     def bulkload_text(self, char* filename):             # <<<<<<<<<<<<<<
 *         cdef FILE* file_in = fopen( filename, "r")
 *         cdef char line[128]
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_hydra.BloomFilter.bulkload_text", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_hydra.pyx":467
 *             fclose(file_in)
 * 
 * cdef void c_lcase(char* buffer):             # <<<<<<<<<<<<<<
 *     """
 *     Force string to lower case
 */

static void __pyx_f_6_hydra_c_lcase(char *__pyx_v_buffer) {
  unsigned int __pyx_v_i;
  __Pyx_RefNannyDeclarations
  size_t __pyx_t_1;
  unsigned int __pyx_t_2;
  __Pyx_RefNannySetupContext("c_lcase", 0);

  /* "_hydra.pyx":472
 *     """
 *     cdef unsigned int i
 *     for i in range(len(buffer)):             # <<<<<<<<<<<<<<
 *         buffer[i] = <char> tolower(buffer[i])
 */
  __pyx_t_1 = strlen(__pyx_v_buffer); 
  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=1) {
    __pyx_v_i = __pyx_t_2;

    /* "_hydra.pyx":473
 *     cdef unsigned int i
 *     for i in range(len(buffer)):
 *         buffer[i] = <char> tolower(buffer[i])             # <<<<<<<<<<<<<<
 */
    (__pyx_v_buffer[__pyx_v_i]) = ((char)tolower((__pyx_v_buffer[__pyx_v_i])));
  }

  /* "_hydra.pyx":467
 *             fclose(file_in)
 * 
 * cdef void c_lcase(char* buffer):             # <<<<<<<<<<<<<<
 *     """
 *     Force string to lower case
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}
static struct __pyx_vtabstruct_6_hydra_MMapBitField __pyx_vtable_6_hydra_MMapBitField;

static PyObject *__pyx_tp_new_6_hydra_MMapBitField(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_6_hydra_MMapBitField *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_6_hydra_MMapBitField *)o);
  p->__pyx_vtab = __pyx_vtabptr_6_hydra_MMapBitField;
  if (unlikely(__pyx_pw_6_hydra_12MMapBitField_1__cinit__(o, a, k) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_6_hydra_MMapBitField(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_6_hydra_12MMapBitField_3__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  (*Py_TYPE(o)->tp_free)(o);
}
static PyObject *__pyx_sq_item_6_hydra_MMapBitField(PyObject *o, Py_ssize_t i) {
  PyObject *r;
  PyObject *x = PyInt_FromSsize_t(i); if(!x) return 0;
  r = Py_TYPE(o)->tp_as_mapping->mp_subscript(o, x);
  Py_DECREF(x);
  return r;
}

static int __pyx_mp_ass_subscript_6_hydra_MMapBitField(PyObject *o, PyObject *i, PyObject *v) {
  if (v) {
    return __pyx_pw_6_hydra_12MMapBitField_9__setitem__(o, i, v);
  }
  else {
    PyErr_Format(PyExc_NotImplementedError,
      "Subscript deletion not supported by %.200s", Py_TYPE(o)->tp_name);
    return -1;
  }
}

static PyMethodDef __pyx_methods_6_hydra_MMapBitField[] = {
  {"close", (PyCFunction)__pyx_pw_6_hydra_12MMapBitField_5close, METH_NOARGS, 0},
  {"fdatasync", (PyCFunction)__pyx_pw_6_hydra_12MMapBitField_7fdatasync, METH_NOARGS, __pyx_doc_6_hydra_12MMapBitField_6fdatasync},
  {"size", (PyCFunction)__pyx_pw_6_hydra_12MMapBitField_17size, METH_NOARGS, 0},
  {0, 0, 0, 0}
};

static PySequenceMethods __pyx_tp_as_sequence_MMapBitField = {
  __pyx_pw_6_hydra_12MMapBitField_15__len__, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  __pyx_sq_item_6_hydra_MMapBitField, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_MMapBitField = {
  __pyx_pw_6_hydra_12MMapBitField_15__len__, /*mp_length*/
  __pyx_pw_6_hydra_12MMapBitField_11__getitem__, /*mp_subscript*/
  __pyx_mp_ass_subscript_6_hydra_MMapBitField, /*mp_ass_subscript*/
};

static PyTypeObject __pyx_type_6_hydra_MMapBitField = {
  PyVarObject_HEAD_INIT(0, 0)
  "_hydra.MMapBitField", /*tp_name*/
  sizeof(struct __pyx_obj_6_hydra_MMapBitField), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_6_hydra_MMapBitField, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  &__pyx_tp_as_sequence_MMapBitField, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_MMapBitField, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  0, /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_6_hydra_12MMapBitField_13__iter__, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_6_hydra_MMapBitField, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_6_hydra_MMapBitField, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_6_hydra_MMapIter(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_6_hydra_MMapIter *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_6_hydra_MMapIter *)o);
  p->_bitfield = ((struct __pyx_obj_6_hydra_MMapBitField *)Py_None); Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_6_hydra_8MMapIter_1__cinit__(o, a, k) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_6_hydra_MMapIter(PyObject *o) {
  struct __pyx_obj_6_hydra_MMapIter *p = (struct __pyx_obj_6_hydra_MMapIter *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->_bitfield);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_6_hydra_MMapIter(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_6_hydra_MMapIter *p = (struct __pyx_obj_6_hydra_MMapIter *)o;
  if (p->_bitfield) {
    e = (*v)(((PyObject*)p->_bitfield), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_6_hydra_MMapIter(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_6_hydra_MMapIter *p = (struct __pyx_obj_6_hydra_MMapIter *)o;
  tmp = ((PyObject*)p->_bitfield);
  p->_bitfield = ((struct __pyx_obj_6_hydra_MMapBitField *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_6_hydra_MMapIter[] = {
  {"__next__", (PyCFunction)__pyx_pw_6_hydra_8MMapIter_3__next__, METH_NOARGS|METH_COEXIST, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_6_hydra_MMapIter = {
  PyVarObject_HEAD_INIT(0, 0)
  "_hydra.MMapIter", /*tp_name*/
  sizeof(struct __pyx_obj_6_hydra_MMapIter), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_6_hydra_MMapIter, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_6_hydra_MMapIter, /*tp_traverse*/
  __pyx_tp_clear_6_hydra_MMapIter, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  __pyx_pw_6_hydra_8MMapIter_3__next__, /*tp_iternext*/
  __pyx_methods_6_hydra_MMapIter, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_6_hydra_MMapIter, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_6_hydra_BloomCalculations(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  return o;
}

static void __pyx_tp_dealloc_6_hydra_BloomCalculations(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_6_hydra_BloomCalculations[] = {
  {"computeBloomSpec1", (PyCFunction)__pyx_pw_6_hydra_17BloomCalculations_1computeBloomSpec1, METH_O, __pyx_doc_6_hydra_17BloomCalculations_computeBloomSpec1},
  {"computeBloomSpec2", (PyCFunction)__pyx_pw_6_hydra_17BloomCalculations_3computeBloomSpec2, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6_hydra_17BloomCalculations_2computeBloomSpec2},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_6_hydra_BloomCalculations = {
  PyVarObject_HEAD_INIT(0, 0)
  "_hydra.BloomCalculations", /*tp_name*/
  sizeof(struct __pyx_obj_6_hydra_BloomCalculations), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_6_hydra_BloomCalculations, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n    This calculation class is ported straight from Cassandra.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_6_hydra_BloomCalculations, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_6_hydra_BloomCalculations, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_6_hydra_BloomFilter __pyx_vtable_6_hydra_BloomFilter;

static PyObject *__pyx_tp_new_6_hydra_BloomFilter(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_6_hydra_BloomFilter *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_6_hydra_BloomFilter *)o);
  p->__pyx_vtab = __pyx_vtabptr_6_hydra_BloomFilter;
  p->_bitmap = ((struct __pyx_obj_6_hydra_MMapBitField *)Py_None); Py_INCREF(Py_None);
  p->_tempfile = Py_None; Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_6_hydra_11BloomFilter_1__cinit__(o, a, k) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_6_hydra_BloomFilter(PyObject *o) {
  struct __pyx_obj_6_hydra_BloomFilter *p = (struct __pyx_obj_6_hydra_BloomFilter *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->_bitmap);
  Py_CLEAR(p->_tempfile);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_6_hydra_BloomFilter(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_6_hydra_BloomFilter *p = (struct __pyx_obj_6_hydra_BloomFilter *)o;
  if (p->_bitmap) {
    e = (*v)(((PyObject*)p->_bitmap), a); if (e) return e;
  }
  if (p->_tempfile) {
    e = (*v)(p->_tempfile, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_6_hydra_BloomFilter(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_6_hydra_BloomFilter *p = (struct __pyx_obj_6_hydra_BloomFilter *)o;
  tmp = ((PyObject*)p->_bitmap);
  p->_bitmap = ((struct __pyx_obj_6_hydra_MMapBitField *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->_tempfile);
  p->_tempfile = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}
static PyObject *__pyx_sq_item_6_hydra_BloomFilter(PyObject *o, Py_ssize_t i) {
  PyObject *r;
  PyObject *x = PyInt_FromSsize_t(i); if(!x) return 0;
  r = Py_TYPE(o)->tp_as_mapping->mp_subscript(o, x);
  Py_DECREF(x);
  return r;
}

static int __pyx_mp_ass_subscript_6_hydra_BloomFilter(PyObject *o, PyObject *i, PyObject *v) {
  if (v) {
    return __pyx_pw_6_hydra_11BloomFilter_19__setitem__(o, i, v);
  }
  else {
    PyErr_Format(PyExc_NotImplementedError,
      "Subscript deletion not supported by %.200s", Py_TYPE(o)->tp_name);
    return -1;
  }
}

static PyMethodDef __pyx_methods_6_hydra_BloomFilter[] = {
  {"__enter__", (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_3__enter__, METH_NOARGS, 0},
  {"__exit__", (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_5__exit__, METH_VARARGS|METH_KEYWORDS, 0},
  {"close", (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_7close, METH_NOARGS, 0},
  {"fdatasync", (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_9fdatasync, METH_NOARGS, __pyx_doc_6_hydra_11BloomFilter_8fdatasync},
  {"filename", (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_11filename, METH_NOARGS, __pyx_doc_6_hydra_11BloomFilter_10filename},
  {"_maxBucketsPerElement", (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_13_maxBucketsPerElement, METH_O, 0},
  {"_bucketsFor", (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_15_bucketsFor, METH_VARARGS|METH_KEYWORDS, 0},
  {"getFilter", (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_17getFilter, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6_hydra_11BloomFilter_16getFilter},
  {"add", (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_25add, METH_O, __pyx_doc_6_hydra_11BloomFilter_24add},
  {"contains", (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_27contains, METH_O, __pyx_doc_6_hydra_11BloomFilter_26contains},
  {"buckets", (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_29buckets, METH_NOARGS, __pyx_doc_6_hydra_11BloomFilter_28buckets},
  {"getHashBuckets", (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_31getHashBuckets, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6_hydra_11BloomFilter_30getHashBuckets},
  {"bulkload_text", (PyCFunction)__pyx_pw_6_hydra_11BloomFilter_33bulkload_text, METH_O, 0},
  {0, 0, 0, 0}
};

static PySequenceMethods __pyx_tp_as_sequence_BloomFilter = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  __pyx_sq_item_6_hydra_BloomFilter, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  __pyx_pw_6_hydra_11BloomFilter_23__contains__, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_BloomFilter = {
  0, /*mp_length*/
  __pyx_pw_6_hydra_11BloomFilter_21__getitem__, /*mp_subscript*/
  __pyx_mp_ass_subscript_6_hydra_BloomFilter, /*mp_ass_subscript*/
};

static PyTypeObject __pyx_type_6_hydra_BloomFilter = {
  PyVarObject_HEAD_INIT(0, 0)
  "_hydra.BloomFilter", /*tp_name*/
  sizeof(struct __pyx_obj_6_hydra_BloomFilter), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_6_hydra_BloomFilter, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  &__pyx_tp_as_sequence_BloomFilter, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_BloomFilter, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_6_hydra_BloomFilter, /*tp_traverse*/
  __pyx_tp_clear_6_hydra_BloomFilter, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_6_hydra_BloomFilter, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_6_hydra_BloomFilter, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
  #if PY_VERSION_HEX < 0x03020000
    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
  #else
    PyModuleDef_HEAD_INIT,
  #endif
    "_hydra",
    0, /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_s_A_wrapper_class_that_holds_two, __pyx_k_A_wrapper_class_that_holds_two, sizeof(__pyx_k_A_wrapper_class_that_holds_two), 0, 0, 1, 0},
  {&__pyx_n_s_BloomSpecification, __pyx_k_BloomSpecification, sizeof(__pyx_k_BloomSpecification), 0, 0, 1, 1},
  {&__pyx_n_s_BloomSpecification___eq, __pyx_k_BloomSpecification___eq, sizeof(__pyx_k_BloomSpecification___eq), 0, 0, 1, 1},
  {&__pyx_n_s_BloomSpecification___init, __pyx_k_BloomSpecification___init, sizeof(__pyx_k_BloomSpecification___init), 0, 0, 1, 1},
  {&__pyx_kp_s_Cannot_compute_probabilities_for, __pyx_k_Cannot_compute_probabilities_for, sizeof(__pyx_k_Cannot_compute_probabilities_for), 0, 0, 1, 0},
  {&__pyx_n_s_EXCESS, __pyx_k_EXCESS, sizeof(__pyx_k_EXCESS), 0, 0, 1, 1},
  {&__pyx_n_s_Exception, __pyx_k_Exception, sizeof(__pyx_k_Exception), 0, 0, 1, 1},
  {&__pyx_kp_s_I_O_operation_on_closed_file, __pyx_k_I_O_operation_on_closed_file, sizeof(__pyx_k_I_O_operation_on_closed_file), 0, 0, 1, 0},
  {&__pyx_kp_s_Invalid_probability, __pyx_k_Invalid_probability, sizeof(__pyx_k_Invalid_probability), 0, 0, 1, 0},
  {&__pyx_n_s_K, __pyx_k_K, sizeof(__pyx_k_K), 0, 0, 1, 1},
  {&__pyx_n_s_NamedTemporaryFile, __pyx_k_NamedTemporaryFile, sizeof(__pyx_k_NamedTemporaryFile), 0, 0, 1, 1},
  {&__pyx_n_s_PROBS, __pyx_k_PROBS, sizeof(__pyx_k_PROBS), 0, 0, 1, 1},
  {&__pyx_n_s_RuntimeError, __pyx_k_RuntimeError, sizeof(__pyx_k_RuntimeError), 0, 0, 1, 1},
  {&__pyx_n_s_StopIteration, __pyx_k_StopIteration, sizeof(__pyx_k_StopIteration), 0, 0, 1, 1},
  {&__pyx_kp_s_Unable_to_satisfy_s_with_s_bucke, __pyx_k_Unable_to_satisfy_s_with_s_bucke, sizeof(__pyx_k_Unable_to_satisfy_s_with_s_bucke), 0, 0, 1, 0},
  {&__pyx_kp_s_Unexpected_kwargs_s, __pyx_k_Unexpected_kwargs_s, sizeof(__pyx_k_Unexpected_kwargs_s), 0, 0, 1, 0},
  {&__pyx_n_s_UnsupportedOperationException, __pyx_k_UnsupportedOperationException, sizeof(__pyx_k_UnsupportedOperationException), 0, 0, 1, 1},
  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
  {&__pyx_n_s_add, __pyx_k_add, sizeof(__pyx_k_add), 0, 0, 1, 1},
  {&__pyx_kp_s_bit_field_is_read_only, __pyx_k_bit_field_is_read_only, sizeof(__pyx_k_bit_field_is_read_only), 0, 0, 1, 0},
  {&__pyx_n_s_bitfield, __pyx_k_bitfield, sizeof(__pyx_k_bitfield), 0, 0, 1, 1},
  {&__pyx_n_s_bitmap, __pyx_k_bitmap, sizeof(__pyx_k_bitmap), 0, 0, 1, 1},
  {&__pyx_n_s_bitsize, __pyx_k_bitsize, sizeof(__pyx_k_bitsize), 0, 0, 1, 1},
  {&__pyx_n_s_buckets, __pyx_k_buckets, sizeof(__pyx_k_buckets), 0, 0, 1, 1},
  {&__pyx_n_s_bucketsFor, __pyx_k_bucketsFor, sizeof(__pyx_k_bucketsFor), 0, 0, 1, 1},
  {&__pyx_n_s_bucketsPer, __pyx_k_bucketsPer, sizeof(__pyx_k_bucketsPer), 0, 0, 1, 1},
  {&__pyx_n_s_bucketsPerElement, __pyx_k_bucketsPerElement, sizeof(__pyx_k_bucketsPerElement), 0, 0, 1, 1},
  {&__pyx_n_s_c1, __pyx_k_c1, sizeof(__pyx_k_c1), 0, 0, 1, 1},
  {&__pyx_n_s_c2, __pyx_k_c2, sizeof(__pyx_k_c2), 0, 0, 1, 1},
  {&__pyx_n_s_close, __pyx_k_close, sizeof(__pyx_k_close), 0, 0, 1, 1},
  {&__pyx_n_s_computeBloomSpec1, __pyx_k_computeBloomSpec1, sizeof(__pyx_k_computeBloomSpec1), 0, 0, 1, 1},
  {&__pyx_n_s_computeBloomSpec2, __pyx_k_computeBloomSpec2, sizeof(__pyx_k_computeBloomSpec2), 0, 0, 1, 1},
  {&__pyx_n_s_contains, __pyx_k_contains, sizeof(__pyx_k_contains), 0, 0, 1, 1},
  {&__pyx_n_s_delete, __pyx_k_delete, sizeof(__pyx_k_delete), 0, 0, 1, 1},
  {&__pyx_n_s_doc, __pyx_k_doc, sizeof(__pyx_k_doc), 0, 0, 1, 1},
  {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
  {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
  {&__pyx_n_s_eq, __pyx_k_eq, sizeof(__pyx_k_eq), 0, 0, 1, 1},
  {&__pyx_n_s_fdatasync, __pyx_k_fdatasync, sizeof(__pyx_k_fdatasync), 0, 0, 1, 1},
  {&__pyx_n_s_fdatasync_on_close, __pyx_k_fdatasync_on_close, sizeof(__pyx_k_fdatasync_on_close), 0, 0, 1, 1},
  {&__pyx_n_s_file, __pyx_k_file, sizeof(__pyx_k_file), 0, 0, 1, 1},
  {&__pyx_n_s_filename, __pyx_k_filename, sizeof(__pyx_k_filename), 0, 0, 1, 1},
  {&__pyx_n_s_get, __pyx_k_get, sizeof(__pyx_k_get), 0, 0, 1, 1},
  {&__pyx_n_s_getFilter, __pyx_k_getFilter, sizeof(__pyx_k_getFilter), 0, 0, 1, 1},
  {&__pyx_n_s_hash, __pyx_k_hash, sizeof(__pyx_k_hash), 0, 0, 1, 1},
  {&__pyx_n_s_hashCount, __pyx_k_hashCount, sizeof(__pyx_k_hashCount), 0, 0, 1, 1},
  {&__pyx_n_s_hashes, __pyx_k_hashes, sizeof(__pyx_k_hashes), 0, 0, 1, 1},
  {&__pyx_n_s_hydra, __pyx_k_hydra, sizeof(__pyx_k_hydra), 0, 0, 1, 1},
  {&__pyx_n_s_ignore_case, __pyx_k_ignore_case, sizeof(__pyx_k_ignore_case), 0, 0, 1, 1},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_n_s_init, __pyx_k_init, sizeof(__pyx_k_init), 0, 0, 1, 1},
  {&__pyx_n_s_itemgetter, __pyx_k_itemgetter, sizeof(__pyx_k_itemgetter), 0, 0, 1, 1},
  {&__pyx_n_s_k, __pyx_k_k, sizeof(__pyx_k_k), 0, 0, 1, 1},
  {&__pyx_n_s_key, __pyx_k_key, sizeof(__pyx_k_key), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_max, __pyx_k_max, sizeof(__pyx_k_max), 0, 0, 1, 1},
  {&__pyx_n_s_maxBucketsPerElement, __pyx_k_maxBucketsPerElement, sizeof(__pyx_k_maxBucketsPerElement), 0, 0, 1, 1},
  {&__pyx_n_s_maxBucketsPerElement_2, __pyx_k_maxBucketsPerElement_2, sizeof(__pyx_k_maxBucketsPerElement_2), 0, 0, 1, 1},
  {&__pyx_n_s_maxFalsePosProb, __pyx_k_maxFalsePosProb, sizeof(__pyx_k_maxFalsePosProb), 0, 0, 1, 1},
  {&__pyx_n_s_maxFalsePosProbability, __pyx_k_maxFalsePosProbability, sizeof(__pyx_k_maxFalsePosProbability), 0, 0, 1, 1},
  {&__pyx_n_s_maxsize, __pyx_k_maxsize, sizeof(__pyx_k_maxsize), 0, 0, 1, 1},
  {&__pyx_n_s_metaclass, __pyx_k_metaclass, sizeof(__pyx_k_metaclass), 0, 0, 1, 1},
  {&__pyx_n_s_min, __pyx_k_min, sizeof(__pyx_k_min), 0, 0, 1, 1},
  {&__pyx_n_s_minBuckets, __pyx_k_minBuckets, sizeof(__pyx_k_minBuckets), 0, 0, 1, 1},
  {&__pyx_n_s_minK, __pyx_k_minK, sizeof(__pyx_k_minK), 0, 0, 1, 1},
  {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
  {&__pyx_n_s_numElements, __pyx_k_numElements, sizeof(__pyx_k_numElements), 0, 0, 1, 1},
  {&__pyx_n_s_operator, __pyx_k_operator, sizeof(__pyx_k_operator), 0, 0, 1, 1},
  {&__pyx_n_s_optKPerBuckets, __pyx_k_optKPerBuckets, sizeof(__pyx_k_optKPerBuckets), 0, 0, 1, 1},
  {&__pyx_kp_s_opt_mozilla_hydra_src__hydra_py, __pyx_k_opt_mozilla_hydra_src__hydra_py, sizeof(__pyx_k_opt_mozilla_hydra_src__hydra_py), 0, 0, 1, 0},
  {&__pyx_n_s_os, __pyx_k_os, sizeof(__pyx_k_os), 0, 0, 1, 1},
  {&__pyx_n_s_other, __pyx_k_other, sizeof(__pyx_k_other), 0, 0, 1, 1},
  {&__pyx_n_s_prepare, __pyx_k_prepare, sizeof(__pyx_k_prepare), 0, 0, 1, 1},
  {&__pyx_n_s_probs, __pyx_k_probs, sizeof(__pyx_k_probs), 0, 0, 1, 1},
  {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
  {&__pyx_n_s_qualname, __pyx_k_qualname, sizeof(__pyx_k_qualname), 0, 0, 1, 1},
  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
  {&__pyx_n_s_read_only, __pyx_k_read_only, sizeof(__pyx_k_read_only), 0, 0, 1, 1},
  {&__pyx_n_s_result, __pyx_k_result, sizeof(__pyx_k_result), 0, 0, 1, 1},
  {&__pyx_n_s_seed, __pyx_k_seed, sizeof(__pyx_k_seed), 0, 0, 1, 1},
  {&__pyx_n_s_self, __pyx_k_self, sizeof(__pyx_k_self), 0, 0, 1, 1},
  {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
  {&__pyx_n_s_sys, __pyx_k_sys, sizeof(__pyx_k_sys), 0, 0, 1, 1},
  {&__pyx_n_s_tempfile, __pyx_k_tempfile, sizeof(__pyx_k_tempfile), 0, 0, 1, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_n_s_ustring, __pyx_k_ustring, sizeof(__pyx_k_ustring), 0, 0, 1, 1},
  {&__pyx_n_s_utf8, __pyx_k_utf8, sizeof(__pyx_k_utf8), 0, 0, 1, 1},
  {&__pyx_n_s_want_lock, __pyx_k_want_lock, sizeof(__pyx_k_want_lock), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_Exception = __Pyx_GetBuiltinName(__pyx_n_s_Exception); if (!__pyx_builtin_Exception) __PYX_ERR(0, 156, __pyx_L1_error)
  __pyx_builtin_min = __Pyx_GetBuiltinName(__pyx_n_s_min); if (!__pyx_builtin_min) __PYX_ERR(0, 204, __pyx_L1_error)
  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(0, 204, __pyx_L1_error)
  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 89, __pyx_L1_error)
  __pyx_builtin_StopIteration = __Pyx_GetBuiltinName(__pyx_n_s_StopIteration); if (!__pyx_builtin_StopIteration) __PYX_ERR(0, 153, __pyx_L1_error)
  __pyx_builtin_RuntimeError = __Pyx_GetBuiltinName(__pyx_n_s_RuntimeError); if (!__pyx_builtin_RuntimeError) __PYX_ERR(0, 345, __pyx_L1_error)
  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 385, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "_hydra.pyx":38
 *     cdef long result[2]
 *     if isinstance(key, unicode):
 *         key = key.encode('utf8')             # <<<<<<<<<<<<<<
 *     MurmurHash3_x64_128(<char*>key, len(key), seed, result)
 *     return long(result[0]) << 64 | (long(result[1]) & 0xFFFFFFFFFFFFFFFF)
 */
  __pyx_tuple_ = PyTuple_Pack(1, __pyx_n_s_utf8); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 38, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple_);
  __Pyx_GIVEREF(__pyx_tuple_);

  /* "_hydra.pyx":53
 *     def __cinit__(self, filename, long bitsize, int read_only, int want_lock=False, int fdatasync_on_close=True):
 *         if isinstance(filename, unicode):
 *             filename = filename.encode('utf8')             # <<<<<<<<<<<<<<
 *         self._filename = filename
 *         self._bitsize = bitsize
 */
  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_n_s_utf8); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 53, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__2);
  __Pyx_GIVEREF(__pyx_tuple__2);

  /* "_hydra.pyx":89
 *         """ Flush everything to disk """
 *         if self._fd < 0 or not self._buffer:
 *             raise ValueError('I/O operation on closed file')             # <<<<<<<<<<<<<<
 * 
 *         if self._read_only:
 */
  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 89, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__3);
  __Pyx_GIVEREF(__pyx_tuple__3);

  /* "_hydra.pyx":92
 * 
 *         if self._read_only:
 *             raise ValueError('bit field is read only')             # <<<<<<<<<<<<<<
 * 
 *         flush_to_disk(self._fd)
 */
  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_bit_field_is_read_only); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 92, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__4);
  __Pyx_GIVEREF(__pyx_tuple__4);

  /* "_hydra.pyx":102
 * 
 *         if self._fd < 0 or not self._buffer:
 *             raise ValueError('I/O operation on closed file')             # <<<<<<<<<<<<<<
 * 
 *         if self._read_only:
 */
  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 102, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__5);
  __Pyx_GIVEREF(__pyx_tuple__5);

  /* "_hydra.pyx":105
 * 
 *         if self._read_only:
 *             raise ValueError('bit field is read only')             # <<<<<<<<<<<<<<
 * 
 *         bitmask = 2 ** (key % 8)
 */
  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_bit_field_is_read_only); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 105, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__6);
  __Pyx_GIVEREF(__pyx_tuple__6);

  /* "_hydra.pyx":119
 * 
 *         if self._fd < 0 or not self._buffer:
 *             raise ValueError('I/O operation on closed file')             # <<<<<<<<<<<<<<
 * 
 *         cdef char old_bitmask = self._buffer[byte_offset]
 */
  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(0, 119, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__7);
  __Pyx_GIVEREF(__pyx_tuple__7);

  /* "_hydra.pyx":126
 *     def __iter__(self):
 *         if self._fd < 0 or not self._buffer:
 *             raise ValueError('I/O operation on closed file')             # <<<<<<<<<<<<<<
 * 
 *         return MMapIter(self)
 */
  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(0, 126, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__8);
  __Pyx_GIVEREF(__pyx_tuple__8);

  /* "_hydra.pyx":135
 *     cpdef size(self):
 *         if self._fd < 0 or not self._buffer:
 *             raise ValueError('I/O operation on closed file')             # <<<<<<<<<<<<<<
 * 
 *         return self._bitsize
 */
  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 135, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__9);
  __Pyx_GIVEREF(__pyx_tuple__9);

  /* "_hydra.pyx":341
 *         fdatasync_on_close = kwargs.get('fdatasync_on_close', True)
 * 
 *         for k in ['filename', 'ignore_case', 'read_only', 'want_lock', 'fdatasync_on_close']:             # <<<<<<<<<<<<<<
 *             if kwargs.has_key(k):
 *                 del kwargs[k]
 */
  __pyx_tuple__10 = PyTuple_Pack(5, __pyx_n_s_filename, __pyx_n_s_ignore_case, __pyx_n_s_read_only, __pyx_n_s_want_lock, __pyx_n_s_fdatasync_on_close); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 341, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__10);
  __Pyx_GIVEREF(__pyx_tuple__10);

  /* "_hydra.pyx":377
 * 
 *         if isinstance(ustring, unicode):
 *             key = ustring.encode('utf8')             # <<<<<<<<<<<<<<
 *         else:
 *             key = ustring
 */
  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_n_s_utf8); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 377, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__11);
  __Pyx_GIVEREF(__pyx_tuple__11);

  /* "_hydra.pyx":395
 * 
 *         if isinstance(ustring, unicode):
 *             key = ustring.encode('utf8')             # <<<<<<<<<<<<<<
 *         else:
 *             key = ustring
 */
  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_n_s_utf8); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(0, 395, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__12);
  __Pyx_GIVEREF(__pyx_tuple__12);

  /* "_hydra.pyx":416
 * 
 *         if isinstance(ustring, unicode):
 *             key = ustring.encode('utf8')             # <<<<<<<<<<<<<<
 *         else:
 *             key = ustring
 */
  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_n_s_utf8); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(0, 416, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__13);
  __Pyx_GIVEREF(__pyx_tuple__13);

  /* "_hydra.pyx":34
 *     void MurmurHash3_x64_128 (void * key, int len, unsigned int seed, void * out)
 * 
 * def hash(key, int seed=0):             # <<<<<<<<<<<<<<
 *     """ This function hashes a string using the Murmur3 hash algorithm"""
 *     cdef long result[2]
 */
  __pyx_tuple__14 = PyTuple_Pack(3, __pyx_n_s_key, __pyx_n_s_seed, __pyx_n_s_result); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(0, 34, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__14);
  __Pyx_GIVEREF(__pyx_tuple__14);
  __pyx_codeobj__15 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__14, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_opt_mozilla_hydra_src__hydra_py, __pyx_n_s_hash, 34, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__15)) __PYX_ERR(0, 34, __pyx_L1_error)

  /* "_hydra.pyx":164
 *     """
 * 
 *     def __init__(self, k, bucketsPerElement):             # <<<<<<<<<<<<<<
 *         self.K = k
 *         self.bucketsPerElement = bucketsPerElement
 */
  __pyx_tuple__16 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_k, __pyx_n_s_bucketsPerElement); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 164, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__16);
  __Pyx_GIVEREF(__pyx_tuple__16);
  __pyx_codeobj__17 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__16, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_opt_mozilla_hydra_src__hydra_py, __pyx_n_s_init, 164, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__17)) __PYX_ERR(0, 164, __pyx_L1_error)

  /* "_hydra.pyx":168
 *         self.bucketsPerElement = bucketsPerElement
 * 
 *     def __eq__(self, other):             # <<<<<<<<<<<<<<
 *         c1 = getattr(other, 'K', None) == self.K
 *         c2 = getattr(other, 'bucketsPerElement', None) == self.bucketsPerElement
 */
  __pyx_tuple__18 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_other, __pyx_n_s_c1, __pyx_n_s_c2); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 168, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__18);
  __Pyx_GIVEREF(__pyx_tuple__18);
  __pyx_codeobj__19 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__18, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_opt_mozilla_hydra_src__hydra_py, __pyx_n_s_eq, 168, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__19)) __PYX_ERR(0, 168, __pyx_L1_error)

  /* "_hydra.pyx":204
 *             ]
 * 
 *     optKPerBuckets = [max(1, min(enumerate(probs), key=operator.itemgetter(1))[0]) for probs in PROBS]             # <<<<<<<<<<<<<<
 * 
 *     @classmethod
 */
  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_int_1); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__20);
  __Pyx_GIVEREF(__pyx_tuple__20);
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  __pyx_float_1_0 = PyFloat_FromDouble(1.0); if (unlikely(!__pyx_float_1_0)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_08 = PyFloat_FromDouble(0.08); if (unlikely(!__pyx_float_0_08)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_001 = PyFloat_FromDouble(0.001); if (unlikely(!__pyx_float_0_001)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_003 = PyFloat_FromDouble(0.003); if (unlikely(!__pyx_float_0_003)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_005 = PyFloat_FromDouble(0.005); if (unlikely(!__pyx_float_0_005)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_024 = PyFloat_FromDouble(0.024); if (unlikely(!__pyx_float_0_024)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_054 = PyFloat_FromDouble(0.054); if (unlikely(!__pyx_float_0_054)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_074 = PyFloat_FromDouble(0.074); if (unlikely(!__pyx_float_0_074)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_092 = PyFloat_FromDouble(0.092); if (unlikely(!__pyx_float_0_092)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_101 = PyFloat_FromDouble(0.101); if (unlikely(!__pyx_float_0_101)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_105 = PyFloat_FromDouble(0.105); if (unlikely(!__pyx_float_0_105)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_109 = PyFloat_FromDouble(0.109); if (unlikely(!__pyx_float_0_109)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_118 = PyFloat_FromDouble(0.118); if (unlikely(!__pyx_float_0_118)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_133 = PyFloat_FromDouble(0.133); if (unlikely(!__pyx_float_0_133)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_147 = PyFloat_FromDouble(0.147); if (unlikely(!__pyx_float_0_147)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_154 = PyFloat_FromDouble(0.154); if (unlikely(!__pyx_float_0_154)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_155 = PyFloat_FromDouble(0.155); if (unlikely(!__pyx_float_0_155)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_160 = PyFloat_FromDouble(0.160); if (unlikely(!__pyx_float_0_160)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_181 = PyFloat_FromDouble(0.181); if (unlikely(!__pyx_float_0_181)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_221 = PyFloat_FromDouble(0.221); if (unlikely(!__pyx_float_0_221)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_237 = PyFloat_FromDouble(0.237); if (unlikely(!__pyx_float_0_237)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_253 = PyFloat_FromDouble(0.253); if (unlikely(!__pyx_float_0_253)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_283 = PyFloat_FromDouble(0.283); if (unlikely(!__pyx_float_0_283)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_393 = PyFloat_FromDouble(0.393); if (unlikely(!__pyx_float_0_393)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_400 = PyFloat_FromDouble(0.400); if (unlikely(!__pyx_float_0_400)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0012 = PyFloat_FromDouble(0.0012); if (unlikely(!__pyx_float_0_0012)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0013 = PyFloat_FromDouble(0.0013); if (unlikely(!__pyx_float_0_0013)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0027 = PyFloat_FromDouble(0.0027); if (unlikely(!__pyx_float_0_0027)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0065 = PyFloat_FromDouble(0.0065); if (unlikely(!__pyx_float_0_0065)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0108 = PyFloat_FromDouble(0.0108); if (unlikely(!__pyx_float_0_0108)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0111 = PyFloat_FromDouble(0.0111); if (unlikely(!__pyx_float_0_0111)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0118 = PyFloat_FromDouble(0.0118); if (unlikely(!__pyx_float_0_0118)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0123 = PyFloat_FromDouble(0.0123); if (unlikely(!__pyx_float_0_0123)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0133 = PyFloat_FromDouble(0.0133); if (unlikely(!__pyx_float_0_0133)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0135 = PyFloat_FromDouble(0.0135); if (unlikely(!__pyx_float_0_0135)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0136 = PyFloat_FromDouble(0.0136); if (unlikely(!__pyx_float_0_0136)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0138 = PyFloat_FromDouble(0.0138); if (unlikely(!__pyx_float_0_0138)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0141 = PyFloat_FromDouble(0.0141); if (unlikely(!__pyx_float_0_0141)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0145 = PyFloat_FromDouble(0.0145); if (unlikely(!__pyx_float_0_0145)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0156 = PyFloat_FromDouble(0.0156); if (unlikely(!__pyx_float_0_0156)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0166 = PyFloat_FromDouble(0.0166); if (unlikely(!__pyx_float_0_0166)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0174 = PyFloat_FromDouble(0.0174); if (unlikely(!__pyx_float_0_0174)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0177 = PyFloat_FromDouble(0.0177); if (unlikely(!__pyx_float_0_0177)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0203 = PyFloat_FromDouble(0.0203); if (unlikely(!__pyx_float_0_0203)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0216 = PyFloat_FromDouble(0.0216); if (unlikely(!__pyx_float_0_0216)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0217 = PyFloat_FromDouble(0.0217); if (unlikely(!__pyx_float_0_0217)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0228 = PyFloat_FromDouble(0.0228); if (unlikely(!__pyx_float_0_0228)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0229 = PyFloat_FromDouble(0.0229); if (unlikely(!__pyx_float_0_0229)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0236 = PyFloat_FromDouble(0.0236); if (unlikely(!__pyx_float_0_0236)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0276 = PyFloat_FromDouble(0.0276); if (unlikely(!__pyx_float_0_0276)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0306 = PyFloat_FromDouble(0.0306); if (unlikely(!__pyx_float_0_0306)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0329 = PyFloat_FromDouble(0.0329); if (unlikely(!__pyx_float_0_0329)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0347 = PyFloat_FromDouble(0.0347); if (unlikely(!__pyx_float_0_0347)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0359 = PyFloat_FromDouble(0.0359); if (unlikely(!__pyx_float_0_0359)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0364 = PyFloat_FromDouble(0.0364); if (unlikely(!__pyx_float_0_0364)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0397 = PyFloat_FromDouble(0.0397); if (unlikely(!__pyx_float_0_0397)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0423 = PyFloat_FromDouble(0.0423); if (unlikely(!__pyx_float_0_0423)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0488 = PyFloat_FromDouble(0.0488); if (unlikely(!__pyx_float_0_0488)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0489 = PyFloat_FromDouble(0.0489); if (unlikely(!__pyx_float_0_0489)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0513 = PyFloat_FromDouble(0.0513); if (unlikely(!__pyx_float_0_0513)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0561 = PyFloat_FromDouble(0.0561); if (unlikely(!__pyx_float_0_0561)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0571 = PyFloat_FromDouble(0.0571); if (unlikely(!__pyx_float_0_0571)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0578 = PyFloat_FromDouble(0.0578); if (unlikely(!__pyx_float_0_0578)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0606 = PyFloat_FromDouble(0.0606); if (unlikely(!__pyx_float_0_0606)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0609 = PyFloat_FromDouble(0.0609); if (unlikely(!__pyx_float_0_0609)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0618 = PyFloat_FromDouble(0.0618); if (unlikely(!__pyx_float_0_0618)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0638 = PyFloat_FromDouble(0.0638); if (unlikely(!__pyx_float_0_0638)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0645 = PyFloat_FromDouble(0.0645); if (unlikely(!__pyx_float_0_0645)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0689 = PyFloat_FromDouble(0.0689); if (unlikely(!__pyx_float_0_0689)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0804 = PyFloat_FromDouble(0.0804); if (unlikely(!__pyx_float_0_0804)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0869 = PyFloat_FromDouble(0.0869); if (unlikely(!__pyx_float_0_0869)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_0952 = PyFloat_FromDouble(0.0952); if (unlikely(!__pyx_float_0_0952)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00014 = PyFloat_FromDouble(0.00014); if (unlikely(!__pyx_float_0_00014)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00036 = PyFloat_FromDouble(0.00036); if (unlikely(!__pyx_float_0_00036)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00047 = PyFloat_FromDouble(0.00047); if (unlikely(!__pyx_float_0_00047)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00053 = PyFloat_FromDouble(0.00053); if (unlikely(!__pyx_float_0_00053)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00107 = PyFloat_FromDouble(0.00107); if (unlikely(!__pyx_float_0_00107)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00108 = PyFloat_FromDouble(0.00108); if (unlikely(!__pyx_float_0_00108)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00121 = PyFloat_FromDouble(0.00121); if (unlikely(!__pyx_float_0_00121)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00128 = PyFloat_FromDouble(0.00128); if (unlikely(!__pyx_float_0_00128)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00129 = PyFloat_FromDouble(0.00129); if (unlikely(!__pyx_float_0_00129)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00139 = PyFloat_FromDouble(0.00139); if (unlikely(!__pyx_float_0_00139)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00146 = PyFloat_FromDouble(0.00146); if (unlikely(!__pyx_float_0_00146)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00158 = PyFloat_FromDouble(0.00158); if (unlikely(!__pyx_float_0_00158)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00179 = PyFloat_FromDouble(0.00179); if (unlikely(!__pyx_float_0_00179)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00183 = PyFloat_FromDouble(0.00183); if (unlikely(!__pyx_float_0_00183)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00193 = PyFloat_FromDouble(0.00193); if (unlikely(!__pyx_float_0_00193)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00194 = PyFloat_FromDouble(0.00194); if (unlikely(!__pyx_float_0_00194)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00199 = PyFloat_FromDouble(0.00199); if (unlikely(!__pyx_float_0_00199)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00217 = PyFloat_FromDouble(0.00217); if (unlikely(!__pyx_float_0_00217)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00239 = PyFloat_FromDouble(0.00239); if (unlikely(!__pyx_float_0_00239)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00244 = PyFloat_FromDouble(0.00244); if (unlikely(!__pyx_float_0_00244)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00255 = PyFloat_FromDouble(0.00255); if (unlikely(!__pyx_float_0_00255)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00312 = PyFloat_FromDouble(0.00312); if (unlikely(!__pyx_float_0_00312)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00314 = PyFloat_FromDouble(0.00314); if (unlikely(!__pyx_float_0_00314)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00329 = PyFloat_FromDouble(0.00329); if (unlikely(!__pyx_float_0_00329)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00332 = PyFloat_FromDouble(0.00332); if (unlikely(!__pyx_float_0_00332)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00362 = PyFloat_FromDouble(0.00362); if (unlikely(!__pyx_float_0_00362)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00371 = PyFloat_FromDouble(0.00371); if (unlikely(!__pyx_float_0_00371)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00381 = PyFloat_FromDouble(0.00381); if (unlikely(!__pyx_float_0_00381)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00423 = PyFloat_FromDouble(0.00423); if (unlikely(!__pyx_float_0_00423)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00459 = PyFloat_FromDouble(0.00459); if (unlikely(!__pyx_float_0_00459)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00492 = PyFloat_FromDouble(0.00492); if (unlikely(!__pyx_float_0_00492)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00509 = PyFloat_FromDouble(0.00509); if (unlikely(!__pyx_float_0_00509)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00513 = PyFloat_FromDouble(0.00513); if (unlikely(!__pyx_float_0_00513)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00552 = PyFloat_FromDouble(0.00552); if (unlikely(!__pyx_float_0_00552)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00596 = PyFloat_FromDouble(0.00596); if (unlikely(!__pyx_float_0_00596)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00646 = PyFloat_FromDouble(0.00646); if (unlikely(!__pyx_float_0_00646)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00718 = PyFloat_FromDouble(0.00718); if (unlikely(!__pyx_float_0_00718)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00819 = PyFloat_FromDouble(0.00819); if (unlikely(!__pyx_float_0_00819)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00844 = PyFloat_FromDouble(0.00844); if (unlikely(!__pyx_float_0_00844)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00846 = PyFloat_FromDouble(0.00846); if (unlikely(!__pyx_float_0_00846)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00864 = PyFloat_FromDouble(0.00864); if (unlikely(!__pyx_float_0_00864)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00875 = PyFloat_FromDouble(0.00875); if (unlikely(!__pyx_float_0_00875)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00906 = PyFloat_FromDouble(0.00906); if (unlikely(!__pyx_float_0_00906)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00943 = PyFloat_FromDouble(0.00943); if (unlikely(!__pyx_float_0_00943)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_00998 = PyFloat_FromDouble(0.00998); if (unlikely(!__pyx_float_0_00998)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000108 = PyFloat_FromDouble(0.000108); if (unlikely(!__pyx_float_0_000108)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000109 = PyFloat_FromDouble(0.000109); if (unlikely(!__pyx_float_0_000109)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000111 = PyFloat_FromDouble(0.000111); if (unlikely(!__pyx_float_0_000111)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000118 = PyFloat_FromDouble(0.000118); if (unlikely(!__pyx_float_0_000118)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000132 = PyFloat_FromDouble(0.000132); if (unlikely(!__pyx_float_0_000132)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000155 = PyFloat_FromDouble(0.000155); if (unlikely(!__pyx_float_0_000155)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000176 = PyFloat_FromDouble(0.000176); if (unlikely(!__pyx_float_0_000176)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000183 = PyFloat_FromDouble(0.000183); if (unlikely(!__pyx_float_0_000183)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000194 = PyFloat_FromDouble(0.000194); if (unlikely(!__pyx_float_0_000194)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000196 = PyFloat_FromDouble(0.000196); if (unlikely(!__pyx_float_0_000196)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000198 = PyFloat_FromDouble(0.000198); if (unlikely(!__pyx_float_0_000198)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000226 = PyFloat_FromDouble(0.000226); if (unlikely(!__pyx_float_0_000226)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000264 = PyFloat_FromDouble(0.000264); if (unlikely(!__pyx_float_0_000264)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000275 = PyFloat_FromDouble(0.000275); if (unlikely(!__pyx_float_0_000275)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000284 = PyFloat_FromDouble(0.000284); if (unlikely(!__pyx_float_0_000284)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000287 = PyFloat_FromDouble(0.000287); if (unlikely(!__pyx_float_0_000287)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000302 = PyFloat_FromDouble(0.000302); if (unlikely(!__pyx_float_0_000302)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000303 = PyFloat_FromDouble(0.000303); if (unlikely(!__pyx_float_0_000303)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000335 = PyFloat_FromDouble(0.000335); if (unlikely(!__pyx_float_0_000335)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000394 = PyFloat_FromDouble(0.000394); if (unlikely(!__pyx_float_0_000394)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000459 = PyFloat_FromDouble(0.000459); if (unlikely(!__pyx_float_0_000459)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000499 = PyFloat_FromDouble(0.000499); if (unlikely(!__pyx_float_0_000499)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000505 = PyFloat_FromDouble(0.000505); if (unlikely(!__pyx_float_0_000505)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000519 = PyFloat_FromDouble(0.000519); if (unlikely(!__pyx_float_0_000519)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000574 = PyFloat_FromDouble(0.000574); if (unlikely(!__pyx_float_0_000574)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000663 = PyFloat_FromDouble(0.000663); if (unlikely(!__pyx_float_0_000663)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000692 = PyFloat_FromDouble(0.000692); if (unlikely(!__pyx_float_0_000692)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000702 = PyFloat_FromDouble(0.000702); if (unlikely(!__pyx_float_0_000702)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000744 = PyFloat_FromDouble(0.000744); if (unlikely(!__pyx_float_0_000744)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000775 = PyFloat_FromDouble(0.000775); if (unlikely(!__pyx_float_0_000775)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000839 = PyFloat_FromDouble(0.000839); if (unlikely(!__pyx_float_0_000839)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000852 = PyFloat_FromDouble(0.000852); if (unlikely(!__pyx_float_0_000852)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_000935 = PyFloat_FromDouble(0.000935); if (unlikely(!__pyx_float_0_000935)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_6_71eneg_05 = PyFloat_FromDouble(6.71e-05); if (unlikely(!__pyx_float_6_71eneg_05)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_6_79eneg_05 = PyFloat_FromDouble(6.79e-05); if (unlikely(!__pyx_float_6_79eneg_05)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_7_12eneg_05 = PyFloat_FromDouble(7.12e-05); if (unlikely(!__pyx_float_7_12eneg_05)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_7_77eneg_05 = PyFloat_FromDouble(7.77e-05); if (unlikely(!__pyx_float_7_77eneg_05)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_8_89eneg_05 = PyFloat_FromDouble(8.89e-05); if (unlikely(!__pyx_float_8_89eneg_05)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_20 = PyInt_FromLong(20); if (unlikely(!__pyx_int_20)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_64 = PyInt_FromLong(64); if (unlikely(!__pyx_int_64)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_4294967295 = PyInt_FromString((char *)"4294967295", 0, 0); if (unlikely(!__pyx_int_4294967295)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_18446744073709551615 = PyInt_FromString((char *)"18446744073709551615", 0, 0); if (unlikely(!__pyx_int_18446744073709551615)) __PYX_ERR(0, 1, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC init_hydra(void); /*proto*/
PyMODINIT_FUNC init_hydra(void)
#else
PyMODINIT_FUNC PyInit__hydra(void); /*proto*/
PyMODINIT_FUNC PyInit__hydra(void)
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  PyObject *__pyx_t_16 = NULL;
  PyObject *__pyx_t_17 = NULL;
  PyObject *__pyx_t_18 = NULL;
  PyObject *__pyx_t_19 = NULL;
  PyObject *__pyx_t_20 = NULL;
  PyObject *__pyx_t_21 = NULL;
  PyObject *__pyx_t_22 = NULL;
  Py_ssize_t __pyx_t_23;
  PyObject *(*__pyx_t_24)(PyObject *);
  long __pyx_t_25;
  int __pyx_t_26;
  __Pyx_RefNannyDeclarations
  #if CYTHON_REFNANNY
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  #endif
  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit__hydra(void)", 0);
  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pyx_CyFunction_USED
  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Coroutine_USED
  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_StopAsyncIteration_USED
  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("_hydra", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
  #if CYTHON_COMPILING_IN_PYPY
  Py_INCREF(__pyx_b);
  #endif
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  /*--- Initialize various global constants etc. ---*/
  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  if (__pyx_module_is_main__hydra) {
    if (PyObject_SetAttrString(__pyx_m, "__name__", __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
    if (!PyDict_GetItemString(modules, "_hydra")) {
      if (unlikely(PyDict_SetItemString(modules, "_hydra", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Constants init code ---*/
  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Global init code ---*/
  /*--- Variable export code ---*/
  /*--- Function export code ---*/
  /*--- Type init code ---*/
  __pyx_vtabptr_6_hydra_MMapBitField = &__pyx_vtable_6_hydra_MMapBitField;
  __pyx_vtable_6_hydra_MMapBitField.open_rw_buffer = (void (*)(struct __pyx_obj_6_hydra_MMapBitField *, struct __pyx_opt_args_6_hydra_12MMapBitField_open_rw_buffer *__pyx_optional_args))__pyx_f_6_hydra_12MMapBitField_open_rw_buffer;
  __pyx_vtable_6_hydra_MMapBitField.open_ro_buffer = (void (*)(struct __pyx_obj_6_hydra_MMapBitField *, struct __pyx_opt_args_6_hydra_12MMapBitField_open_ro_buffer *__pyx_optional_args))__pyx_f_6_hydra_12MMapBitField_open_ro_buffer;
  __pyx_vtable_6_hydra_MMapBitField.close = (PyObject *(*)(struct __pyx_obj_6_hydra_MMapBitField *, int __pyx_skip_dispatch))__pyx_f_6_hydra_12MMapBitField_close;
  __pyx_vtable_6_hydra_MMapBitField.fdatasync = (PyObject *(*)(struct __pyx_obj_6_hydra_MMapBitField *, int __pyx_skip_dispatch))__pyx_f_6_hydra_12MMapBitField_fdatasync;
  __pyx_vtable_6_hydra_MMapBitField.size = (PyObject *(*)(struct __pyx_obj_6_hydra_MMapBitField *, int __pyx_skip_dispatch))__pyx_f_6_hydra_12MMapBitField_size;
  if (PyType_Ready(&__pyx_type_6_hydra_MMapBitField) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
  __pyx_type_6_hydra_MMapBitField.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_6_hydra_MMapBitField.tp_dict, __pyx_vtabptr_6_hydra_MMapBitField) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "MMapBitField", (PyObject *)&__pyx_type_6_hydra_MMapBitField) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
  __pyx_ptype_6_hydra_MMapBitField = &__pyx_type_6_hydra_MMapBitField;
  if (PyType_Ready(&__pyx_type_6_hydra_MMapIter) < 0) __PYX_ERR(0, 140, __pyx_L1_error)
  __pyx_type_6_hydra_MMapIter.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "MMapIter", (PyObject *)&__pyx_type_6_hydra_MMapIter) < 0) __PYX_ERR(0, 140, __pyx_L1_error)
  __pyx_ptype_6_hydra_MMapIter = &__pyx_type_6_hydra_MMapIter;
  if (PyType_Ready(&__pyx_type_6_hydra_BloomCalculations) < 0) __PYX_ERR(0, 173, __pyx_L1_error)
  __pyx_type_6_hydra_BloomCalculations.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "BloomCalculations", (PyObject *)&__pyx_type_6_hydra_BloomCalculations) < 0) __PYX_ERR(0, 173, __pyx_L1_error)
  __pyx_ptype_6_hydra_BloomCalculations = &__pyx_type_6_hydra_BloomCalculations;
  __pyx_vtabptr_6_hydra_BloomFilter = &__pyx_vtable_6_hydra_BloomFilter;
  __pyx_vtable_6_hydra_BloomFilter.close = (PyObject *(*)(struct __pyx_obj_6_hydra_BloomFilter *, int __pyx_skip_dispatch))__pyx_f_6_hydra_11BloomFilter_close;
  __pyx_vtable_6_hydra_BloomFilter.fdatasync = (PyObject *(*)(struct __pyx_obj_6_hydra_BloomFilter *, int __pyx_skip_dispatch))__pyx_f_6_hydra_11BloomFilter_fdatasync;
  __pyx_vtable_6_hydra_BloomFilter.add = (PyObject *(*)(struct __pyx_obj_6_hydra_BloomFilter *, PyObject *, int __pyx_skip_dispatch))__pyx_f_6_hydra_11BloomFilter_add;
  __pyx_vtable_6_hydra_BloomFilter.contains = (PyObject *(*)(struct __pyx_obj_6_hydra_BloomFilter *, PyObject *, int __pyx_skip_dispatch))__pyx_f_6_hydra_11BloomFilter_contains;
  __pyx_vtable_6_hydra_BloomFilter.buckets = (PyObject *(*)(struct __pyx_obj_6_hydra_BloomFilter *, int __pyx_skip_dispatch))__pyx_f_6_hydra_11BloomFilter_buckets;
  __pyx_vtable_6_hydra_BloomFilter._get_hash_buckets = (void (*)(struct __pyx_obj_6_hydra_BloomFilter *, PyObject *, unsigned PY_LONG_LONG *, unsigned int, unsigned long))__pyx_f_6_hydra_11BloomFilter__get_hash_buckets;
  __pyx_vtable_6_hydra_BloomFilter._strip_newline = (void (*)(struct __pyx_obj_6_hydra_BloomFilter *, char *, unsigned int))__pyx_f_6_hydra_11BloomFilter__strip_newline;
  if (PyType_Ready(&__pyx_type_6_hydra_BloomFilter) < 0) __PYX_ERR(0, 261, __pyx_L1_error)
  __pyx_type_6_hydra_BloomFilter.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_6_hydra_BloomFilter.tp_dict, __pyx_vtabptr_6_hydra_BloomFilter) < 0) __PYX_ERR(0, 261, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "BloomFilter", (PyObject *)&__pyx_type_6_hydra_BloomFilter) < 0) __PYX_ERR(0, 261, __pyx_L1_error)
  __pyx_ptype_6_hydra_BloomFilter = &__pyx_type_6_hydra_BloomFilter;
  /*--- Type import code ---*/
  /*--- Variable import code ---*/
  /*--- Function import code ---*/
  /*--- Execution code ---*/
  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif

  /* "_hydra.pyx":2
 * cimport cython
 * import operator             # <<<<<<<<<<<<<<
 * import os
 * import sys
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_operator, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_operator, __pyx_t_1) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_hydra.pyx":3
 * cimport cython
 * import operator
 * import os             # <<<<<<<<<<<<<<
 * import sys
 * import tempfile
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_os, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_os, __pyx_t_1) < 0) __PYX_ERR(0, 3, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_hydra.pyx":4
 * import operator
 * import os
 * import sys             # <<<<<<<<<<<<<<
 * import tempfile
 * 
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_sys, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sys, __pyx_t_1) < 0) __PYX_ERR(0, 4, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_hydra.pyx":5
 * import os
 * import sys
 * import tempfile             # <<<<<<<<<<<<<<
 * 
 * cdef extern from "ctype.h" nogil:
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_tempfile, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_tempfile, __pyx_t_1) < 0) __PYX_ERR(0, 5, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_hydra.pyx":34
 *     void MurmurHash3_x64_128 (void * key, int len, unsigned int seed, void * out)
 * 
 * def hash(key, int seed=0):             # <<<<<<<<<<<<<<
 *     """ This function hashes a string using the Murmur3 hash algorithm"""
 *     cdef long result[2]
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_6_hydra_1hash, NULL, __pyx_n_s_hydra); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 34, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_hash, __pyx_t_1) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_hydra.pyx":156
 * 
 * 
 * class UnsupportedOperationException(Exception): pass             # <<<<<<<<<<<<<<
 * 
 * class BloomSpecification:
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 156, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_builtin_Exception);
  __Pyx_GIVEREF(__pyx_builtin_Exception);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_builtin_Exception);
  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 156, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_1, __pyx_n_s_UnsupportedOperationException, __pyx_n_s_UnsupportedOperationException, (PyObject *) NULL, __pyx_n_s_hydra, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 156, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_UnsupportedOperationException, __pyx_t_1, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 156, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_UnsupportedOperationException, __pyx_t_4) < 0) __PYX_ERR(0, 156, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_hydra.pyx":158
 * class UnsupportedOperationException(Exception): pass
 * 
 * class BloomSpecification:             # <<<<<<<<<<<<<<
 *     """
 *     A wrapper class that holds two key parameters for a Bloom Filter: the
 */
  __pyx_t_1 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_BloomSpecification, __pyx_n_s_BloomSpecification, (PyObject *) NULL, __pyx_n_s_hydra, __pyx_kp_s_A_wrapper_class_that_holds_two); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 158, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);

  /* "_hydra.pyx":164
 *     """
 * 
 *     def __init__(self, k, bucketsPerElement):             # <<<<<<<<<<<<<<
 *         self.K = k
 *         self.bucketsPerElement = bucketsPerElement
 */
  __pyx_t_2 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6_hydra_18BloomSpecification_1__init__, 0, __pyx_n_s_BloomSpecification___init, NULL, __pyx_n_s_hydra, __pyx_d, ((PyObject *)__pyx_codeobj__17)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 164, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_init, __pyx_t_2) < 0) __PYX_ERR(0, 164, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "_hydra.pyx":168
 *         self.bucketsPerElement = bucketsPerElement
 * 
 *     def __eq__(self, other):             # <<<<<<<<<<<<<<
 *         c1 = getattr(other, 'K', None) == self.K
 *         c2 = getattr(other, 'bucketsPerElement', None) == self.bucketsPerElement
 */
  __pyx_t_2 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6_hydra_18BloomSpecification_3__eq__, 0, __pyx_n_s_BloomSpecification___eq, NULL, __pyx_n_s_hydra, __pyx_d, ((PyObject *)__pyx_codeobj__19)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 168, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_eq, __pyx_t_2) < 0) __PYX_ERR(0, 168, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "_hydra.pyx":158
 * class UnsupportedOperationException(Exception): pass
 * 
 * class BloomSpecification:             # <<<<<<<<<<<<<<
 *     """
 *     A wrapper class that holds two key parameters for a Bloom Filter: the
 */
  __pyx_t_2 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_BloomSpecification, __pyx_empty_tuple, __pyx_t_1, NULL, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 158, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_BloomSpecification, __pyx_t_2) < 0) __PYX_ERR(0, 158, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_hydra.pyx":177
 *     This calculation class is ported straight from Cassandra.
 *     """
 *     minBuckets = 2             # <<<<<<<<<<<<<<
 *     minK = 1
 * 
 */
  if (PyDict_SetItem((PyObject *)__pyx_ptype_6_hydra_BloomCalculations->tp_dict, __pyx_n_s_minBuckets, __pyx_int_2) < 0) __PYX_ERR(0, 177, __pyx_L1_error)
  PyType_Modified(__pyx_ptype_6_hydra_BloomCalculations);

  /* "_hydra.pyx":178
 *     """
 *     minBuckets = 2
 *     minK = 1             # <<<<<<<<<<<<<<
 * 
 *     PROBS = [
 */
  if (PyDict_SetItem((PyObject *)__pyx_ptype_6_hydra_BloomCalculations->tp_dict, __pyx_n_s_minK, __pyx_int_1) < 0) __PYX_ERR(0, 178, __pyx_L1_error)
  PyType_Modified(__pyx_ptype_6_hydra_BloomCalculations);

  /* "_hydra.pyx":181
 * 
 *     PROBS = [
 *             [1.0], #  dummy row representing 0 buckets per element             # <<<<<<<<<<<<<<
 *             [1.0, 1.0], #  dummy row representing 1 buckets per element
 *             [1.0, 0.393,  0.400],
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 181, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_float_1_0);

  /* "_hydra.pyx":182
 *     PROBS = [
 *             [1.0], #  dummy row representing 0 buckets per element
 *             [1.0, 1.0], #  dummy row representing 1 buckets per element             # <<<<<<<<<<<<<<
 *             [1.0, 0.393,  0.400],
 *             [1.0, 0.283,  0.237,   0.253],
 */
  __pyx_t_2 = PyList_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 182, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_2, 1, __pyx_float_1_0);

  /* "_hydra.pyx":183
 *             [1.0], #  dummy row representing 0 buckets per element
 *             [1.0, 1.0], #  dummy row representing 1 buckets per element
 *             [1.0, 0.393,  0.400],             # <<<<<<<<<<<<<<
 *             [1.0, 0.283,  0.237,   0.253],
 *             [1.0, 0.221,  0.155,   0.147,   0.160],
 */
  __pyx_t_3 = PyList_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 183, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_3, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_393);
  __Pyx_GIVEREF(__pyx_float_0_393);
  PyList_SET_ITEM(__pyx_t_3, 1, __pyx_float_0_393);
  __Pyx_INCREF(__pyx_float_0_400);
  __Pyx_GIVEREF(__pyx_float_0_400);
  PyList_SET_ITEM(__pyx_t_3, 2, __pyx_float_0_400);

  /* "_hydra.pyx":184
 *             [1.0, 1.0], #  dummy row representing 1 buckets per element
 *             [1.0, 0.393,  0.400],
 *             [1.0, 0.283,  0.237,   0.253],             # <<<<<<<<<<<<<<
 *             [1.0, 0.221,  0.155,   0.147,   0.160],
 *             [1.0, 0.181,  0.109,   0.092,   0.092,   0.101], # 5
 */
  __pyx_t_4 = PyList_New(4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 184, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_4, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_283);
  __Pyx_GIVEREF(__pyx_float_0_283);
  PyList_SET_ITEM(__pyx_t_4, 1, __pyx_float_0_283);
  __Pyx_INCREF(__pyx_float_0_237);
  __Pyx_GIVEREF(__pyx_float_0_237);
  PyList_SET_ITEM(__pyx_t_4, 2, __pyx_float_0_237);
  __Pyx_INCREF(__pyx_float_0_253);
  __Pyx_GIVEREF(__pyx_float_0_253);
  PyList_SET_ITEM(__pyx_t_4, 3, __pyx_float_0_253);

  /* "_hydra.pyx":185
 *             [1.0, 0.393,  0.400],
 *             [1.0, 0.283,  0.237,   0.253],
 *             [1.0, 0.221,  0.155,   0.147,   0.160],             # <<<<<<<<<<<<<<
 *             [1.0, 0.181,  0.109,   0.092,   0.092,   0.101], # 5
 *             [1.0, 0.154,  0.0804,  0.0609,  0.0561,  0.0578,   0.0638],
 */
  __pyx_t_5 = PyList_New(5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_5, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_221);
  __Pyx_GIVEREF(__pyx_float_0_221);
  PyList_SET_ITEM(__pyx_t_5, 1, __pyx_float_0_221);
  __Pyx_INCREF(__pyx_float_0_155);
  __Pyx_GIVEREF(__pyx_float_0_155);
  PyList_SET_ITEM(__pyx_t_5, 2, __pyx_float_0_155);
  __Pyx_INCREF(__pyx_float_0_147);
  __Pyx_GIVEREF(__pyx_float_0_147);
  PyList_SET_ITEM(__pyx_t_5, 3, __pyx_float_0_147);
  __Pyx_INCREF(__pyx_float_0_160);
  __Pyx_GIVEREF(__pyx_float_0_160);
  PyList_SET_ITEM(__pyx_t_5, 4, __pyx_float_0_160);

  /* "_hydra.pyx":186
 *             [1.0, 0.283,  0.237,   0.253],
 *             [1.0, 0.221,  0.155,   0.147,   0.160],
 *             [1.0, 0.181,  0.109,   0.092,   0.092,   0.101], # 5             # <<<<<<<<<<<<<<
 *             [1.0, 0.154,  0.0804,  0.0609,  0.0561,  0.0578,   0.0638],
 *             [1.0, 0.133,  0.0618,  0.0423,  0.0359,  0.0347,   0.0364],
 */
  __pyx_t_6 = PyList_New(6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_6, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_181);
  __Pyx_GIVEREF(__pyx_float_0_181);
  PyList_SET_ITEM(__pyx_t_6, 1, __pyx_float_0_181);
  __Pyx_INCREF(__pyx_float_0_109);
  __Pyx_GIVEREF(__pyx_float_0_109);
  PyList_SET_ITEM(__pyx_t_6, 2, __pyx_float_0_109);
  __Pyx_INCREF(__pyx_float_0_092);
  __Pyx_GIVEREF(__pyx_float_0_092);
  PyList_SET_ITEM(__pyx_t_6, 3, __pyx_float_0_092);
  __Pyx_INCREF(__pyx_float_0_092);
  __Pyx_GIVEREF(__pyx_float_0_092);
  PyList_SET_ITEM(__pyx_t_6, 4, __pyx_float_0_092);
  __Pyx_INCREF(__pyx_float_0_101);
  __Pyx_GIVEREF(__pyx_float_0_101);
  PyList_SET_ITEM(__pyx_t_6, 5, __pyx_float_0_101);

  /* "_hydra.pyx":187
 *             [1.0, 0.221,  0.155,   0.147,   0.160],
 *             [1.0, 0.181,  0.109,   0.092,   0.092,   0.101], # 5
 *             [1.0, 0.154,  0.0804,  0.0609,  0.0561,  0.0578,   0.0638],             # <<<<<<<<<<<<<<
 *             [1.0, 0.133,  0.0618,  0.0423,  0.0359,  0.0347,   0.0364],
 *             [1.0, 0.118,  0.0489,  0.0306,  0.024,   0.0217,   0.0216,   0.0229],
 */
  __pyx_t_7 = PyList_New(7); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 187, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_7, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_154);
  __Pyx_GIVEREF(__pyx_float_0_154);
  PyList_SET_ITEM(__pyx_t_7, 1, __pyx_float_0_154);
  __Pyx_INCREF(__pyx_float_0_0804);
  __Pyx_GIVEREF(__pyx_float_0_0804);
  PyList_SET_ITEM(__pyx_t_7, 2, __pyx_float_0_0804);
  __Pyx_INCREF(__pyx_float_0_0609);
  __Pyx_GIVEREF(__pyx_float_0_0609);
  PyList_SET_ITEM(__pyx_t_7, 3, __pyx_float_0_0609);
  __Pyx_INCREF(__pyx_float_0_0561);
  __Pyx_GIVEREF(__pyx_float_0_0561);
  PyList_SET_ITEM(__pyx_t_7, 4, __pyx_float_0_0561);
  __Pyx_INCREF(__pyx_float_0_0578);
  __Pyx_GIVEREF(__pyx_float_0_0578);
  PyList_SET_ITEM(__pyx_t_7, 5, __pyx_float_0_0578);
  __Pyx_INCREF(__pyx_float_0_0638);
  __Pyx_GIVEREF(__pyx_float_0_0638);
  PyList_SET_ITEM(__pyx_t_7, 6, __pyx_float_0_0638);

  /* "_hydra.pyx":188
 *             [1.0, 0.181,  0.109,   0.092,   0.092,   0.101], # 5
 *             [1.0, 0.154,  0.0804,  0.0609,  0.0561,  0.0578,   0.0638],
 *             [1.0, 0.133,  0.0618,  0.0423,  0.0359,  0.0347,   0.0364],             # <<<<<<<<<<<<<<
 *             [1.0, 0.118,  0.0489,  0.0306,  0.024,   0.0217,   0.0216,   0.0229],
 *             [1.0, 0.105,  0.0397,  0.0228,  0.0166,  0.0141,   0.0133,   0.0135,   0.0145],
 */
  __pyx_t_8 = PyList_New(7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 188, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_8, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_133);
  __Pyx_GIVEREF(__pyx_float_0_133);
  PyList_SET_ITEM(__pyx_t_8, 1, __pyx_float_0_133);
  __Pyx_INCREF(__pyx_float_0_0618);
  __Pyx_GIVEREF(__pyx_float_0_0618);
  PyList_SET_ITEM(__pyx_t_8, 2, __pyx_float_0_0618);
  __Pyx_INCREF(__pyx_float_0_0423);
  __Pyx_GIVEREF(__pyx_float_0_0423);
  PyList_SET_ITEM(__pyx_t_8, 3, __pyx_float_0_0423);
  __Pyx_INCREF(__pyx_float_0_0359);
  __Pyx_GIVEREF(__pyx_float_0_0359);
  PyList_SET_ITEM(__pyx_t_8, 4, __pyx_float_0_0359);
  __Pyx_INCREF(__pyx_float_0_0347);
  __Pyx_GIVEREF(__pyx_float_0_0347);
  PyList_SET_ITEM(__pyx_t_8, 5, __pyx_float_0_0347);
  __Pyx_INCREF(__pyx_float_0_0364);
  __Pyx_GIVEREF(__pyx_float_0_0364);
  PyList_SET_ITEM(__pyx_t_8, 6, __pyx_float_0_0364);

  /* "_hydra.pyx":189
 *             [1.0, 0.154,  0.0804,  0.0609,  0.0561,  0.0578,   0.0638],
 *             [1.0, 0.133,  0.0618,  0.0423,  0.0359,  0.0347,   0.0364],
 *             [1.0, 0.118,  0.0489,  0.0306,  0.024,   0.0217,   0.0216,   0.0229],             # <<<<<<<<<<<<<<
 *             [1.0, 0.105,  0.0397,  0.0228,  0.0166,  0.0141,   0.0133,   0.0135,   0.0145],
 *             [1.0, 0.0952, 0.0329,  0.0174,  0.0118,  0.00943,  0.00844,  0.00819,  0.00846], # 10
 */
  __pyx_t_9 = PyList_New(8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 189, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_9, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_118);
  __Pyx_GIVEREF(__pyx_float_0_118);
  PyList_SET_ITEM(__pyx_t_9, 1, __pyx_float_0_118);
  __Pyx_INCREF(__pyx_float_0_0489);
  __Pyx_GIVEREF(__pyx_float_0_0489);
  PyList_SET_ITEM(__pyx_t_9, 2, __pyx_float_0_0489);
  __Pyx_INCREF(__pyx_float_0_0306);
  __Pyx_GIVEREF(__pyx_float_0_0306);
  PyList_SET_ITEM(__pyx_t_9, 3, __pyx_float_0_0306);
  __Pyx_INCREF(__pyx_float_0_024);
  __Pyx_GIVEREF(__pyx_float_0_024);
  PyList_SET_ITEM(__pyx_t_9, 4, __pyx_float_0_024);
  __Pyx_INCREF(__pyx_float_0_0217);
  __Pyx_GIVEREF(__pyx_float_0_0217);
  PyList_SET_ITEM(__pyx_t_9, 5, __pyx_float_0_0217);
  __Pyx_INCREF(__pyx_float_0_0216);
  __Pyx_GIVEREF(__pyx_float_0_0216);
  PyList_SET_ITEM(__pyx_t_9, 6, __pyx_float_0_0216);
  __Pyx_INCREF(__pyx_float_0_0229);
  __Pyx_GIVEREF(__pyx_float_0_0229);
  PyList_SET_ITEM(__pyx_t_9, 7, __pyx_float_0_0229);

  /* "_hydra.pyx":190
 *             [1.0, 0.133,  0.0618,  0.0423,  0.0359,  0.0347,   0.0364],
 *             [1.0, 0.118,  0.0489,  0.0306,  0.024,   0.0217,   0.0216,   0.0229],
 *             [1.0, 0.105,  0.0397,  0.0228,  0.0166,  0.0141,   0.0133,   0.0135,   0.0145],             # <<<<<<<<<<<<<<
 *             [1.0, 0.0952, 0.0329,  0.0174,  0.0118,  0.00943,  0.00844,  0.00819,  0.00846], # 10
 *             [1.0, 0.0869, 0.0276,  0.0136,  0.00864, 0.0065,   0.00552,  0.00513,  0.00509],
 */
  __pyx_t_10 = PyList_New(9); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_10);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_10, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_105);
  __Pyx_GIVEREF(__pyx_float_0_105);
  PyList_SET_ITEM(__pyx_t_10, 1, __pyx_float_0_105);
  __Pyx_INCREF(__pyx_float_0_0397);
  __Pyx_GIVEREF(__pyx_float_0_0397);
  PyList_SET_ITEM(__pyx_t_10, 2, __pyx_float_0_0397);
  __Pyx_INCREF(__pyx_float_0_0228);
  __Pyx_GIVEREF(__pyx_float_0_0228);
  PyList_SET_ITEM(__pyx_t_10, 3, __pyx_float_0_0228);
  __Pyx_INCREF(__pyx_float_0_0166);
  __Pyx_GIVEREF(__pyx_float_0_0166);
  PyList_SET_ITEM(__pyx_t_10, 4, __pyx_float_0_0166);
  __Pyx_INCREF(__pyx_float_0_0141);
  __Pyx_GIVEREF(__pyx_float_0_0141);
  PyList_SET_ITEM(__pyx_t_10, 5, __pyx_float_0_0141);
  __Pyx_INCREF(__pyx_float_0_0133);
  __Pyx_GIVEREF(__pyx_float_0_0133);
  PyList_SET_ITEM(__pyx_t_10, 6, __pyx_float_0_0133);
  __Pyx_INCREF(__pyx_float_0_0135);
  __Pyx_GIVEREF(__pyx_float_0_0135);
  PyList_SET_ITEM(__pyx_t_10, 7, __pyx_float_0_0135);
  __Pyx_INCREF(__pyx_float_0_0145);
  __Pyx_GIVEREF(__pyx_float_0_0145);
  PyList_SET_ITEM(__pyx_t_10, 8, __pyx_float_0_0145);

  /* "_hydra.pyx":191
 *             [1.0, 0.118,  0.0489,  0.0306,  0.024,   0.0217,   0.0216,   0.0229],
 *             [1.0, 0.105,  0.0397,  0.0228,  0.0166,  0.0141,   0.0133,   0.0135,   0.0145],
 *             [1.0, 0.0952, 0.0329,  0.0174,  0.0118,  0.00943,  0.00844,  0.00819,  0.00846], # 10             # <<<<<<<<<<<<<<
 *             [1.0, 0.0869, 0.0276,  0.0136,  0.00864, 0.0065,   0.00552,  0.00513,  0.00509],
 *             [1.0, 0.08,   0.0236,  0.0108,  0.00646, 0.00459,  0.00371,  0.00329,  0.00314],
 */
  __pyx_t_11 = PyList_New(9); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 191, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_11);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_11, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_0952);
  __Pyx_GIVEREF(__pyx_float_0_0952);
  PyList_SET_ITEM(__pyx_t_11, 1, __pyx_float_0_0952);
  __Pyx_INCREF(__pyx_float_0_0329);
  __Pyx_GIVEREF(__pyx_float_0_0329);
  PyList_SET_ITEM(__pyx_t_11, 2, __pyx_float_0_0329);
  __Pyx_INCREF(__pyx_float_0_0174);
  __Pyx_GIVEREF(__pyx_float_0_0174);
  PyList_SET_ITEM(__pyx_t_11, 3, __pyx_float_0_0174);
  __Pyx_INCREF(__pyx_float_0_0118);
  __Pyx_GIVEREF(__pyx_float_0_0118);
  PyList_SET_ITEM(__pyx_t_11, 4, __pyx_float_0_0118);
  __Pyx_INCREF(__pyx_float_0_00943);
  __Pyx_GIVEREF(__pyx_float_0_00943);
  PyList_SET_ITEM(__pyx_t_11, 5, __pyx_float_0_00943);
  __Pyx_INCREF(__pyx_float_0_00844);
  __Pyx_GIVEREF(__pyx_float_0_00844);
  PyList_SET_ITEM(__pyx_t_11, 6, __pyx_float_0_00844);
  __Pyx_INCREF(__pyx_float_0_00819);
  __Pyx_GIVEREF(__pyx_float_0_00819);
  PyList_SET_ITEM(__pyx_t_11, 7, __pyx_float_0_00819);
  __Pyx_INCREF(__pyx_float_0_00846);
  __Pyx_GIVEREF(__pyx_float_0_00846);
  PyList_SET_ITEM(__pyx_t_11, 8, __pyx_float_0_00846);

  /* "_hydra.pyx":192
 *             [1.0, 0.105,  0.0397,  0.0228,  0.0166,  0.0141,   0.0133,   0.0135,   0.0145],
 *             [1.0, 0.0952, 0.0329,  0.0174,  0.0118,  0.00943,  0.00844,  0.00819,  0.00846], # 10
 *             [1.0, 0.0869, 0.0276,  0.0136,  0.00864, 0.0065,   0.00552,  0.00513,  0.00509],             # <<<<<<<<<<<<<<
 *             [1.0, 0.08,   0.0236,  0.0108,  0.00646, 0.00459,  0.00371,  0.00329,  0.00314],
 *             [1.0, 0.074,  0.0203,  0.00875, 0.00492, 0.00332,  0.00255,  0.00217,  0.00199,  0.00194],
 */
  __pyx_t_12 = PyList_New(9); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 192, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_12);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_12, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_0869);
  __Pyx_GIVEREF(__pyx_float_0_0869);
  PyList_SET_ITEM(__pyx_t_12, 1, __pyx_float_0_0869);
  __Pyx_INCREF(__pyx_float_0_0276);
  __Pyx_GIVEREF(__pyx_float_0_0276);
  PyList_SET_ITEM(__pyx_t_12, 2, __pyx_float_0_0276);
  __Pyx_INCREF(__pyx_float_0_0136);
  __Pyx_GIVEREF(__pyx_float_0_0136);
  PyList_SET_ITEM(__pyx_t_12, 3, __pyx_float_0_0136);
  __Pyx_INCREF(__pyx_float_0_00864);
  __Pyx_GIVEREF(__pyx_float_0_00864);
  PyList_SET_ITEM(__pyx_t_12, 4, __pyx_float_0_00864);
  __Pyx_INCREF(__pyx_float_0_0065);
  __Pyx_GIVEREF(__pyx_float_0_0065);
  PyList_SET_ITEM(__pyx_t_12, 5, __pyx_float_0_0065);
  __Pyx_INCREF(__pyx_float_0_00552);
  __Pyx_GIVEREF(__pyx_float_0_00552);
  PyList_SET_ITEM(__pyx_t_12, 6, __pyx_float_0_00552);
  __Pyx_INCREF(__pyx_float_0_00513);
  __Pyx_GIVEREF(__pyx_float_0_00513);
  PyList_SET_ITEM(__pyx_t_12, 7, __pyx_float_0_00513);
  __Pyx_INCREF(__pyx_float_0_00509);
  __Pyx_GIVEREF(__pyx_float_0_00509);
  PyList_SET_ITEM(__pyx_t_12, 8, __pyx_float_0_00509);

  /* "_hydra.pyx":193
 *             [1.0, 0.0952, 0.0329,  0.0174,  0.0118,  0.00943,  0.00844,  0.00819,  0.00846], # 10
 *             [1.0, 0.0869, 0.0276,  0.0136,  0.00864, 0.0065,   0.00552,  0.00513,  0.00509],
 *             [1.0, 0.08,   0.0236,  0.0108,  0.00646, 0.00459,  0.00371,  0.00329,  0.00314],             # <<<<<<<<<<<<<<
 *             [1.0, 0.074,  0.0203,  0.00875, 0.00492, 0.00332,  0.00255,  0.00217,  0.00199,  0.00194],
 *             [1.0, 0.0689, 0.0177,  0.00718, 0.00381, 0.00244,  0.00179,  0.00146,  0.00129,  0.00121,  0.0012],
 */
  __pyx_t_13 = PyList_New(9); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 193, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_13);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_13, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_08);
  __Pyx_GIVEREF(__pyx_float_0_08);
  PyList_SET_ITEM(__pyx_t_13, 1, __pyx_float_0_08);
  __Pyx_INCREF(__pyx_float_0_0236);
  __Pyx_GIVEREF(__pyx_float_0_0236);
  PyList_SET_ITEM(__pyx_t_13, 2, __pyx_float_0_0236);
  __Pyx_INCREF(__pyx_float_0_0108);
  __Pyx_GIVEREF(__pyx_float_0_0108);
  PyList_SET_ITEM(__pyx_t_13, 3, __pyx_float_0_0108);
  __Pyx_INCREF(__pyx_float_0_00646);
  __Pyx_GIVEREF(__pyx_float_0_00646);
  PyList_SET_ITEM(__pyx_t_13, 4, __pyx_float_0_00646);
  __Pyx_INCREF(__pyx_float_0_00459);
  __Pyx_GIVEREF(__pyx_float_0_00459);
  PyList_SET_ITEM(__pyx_t_13, 5, __pyx_float_0_00459);
  __Pyx_INCREF(__pyx_float_0_00371);
  __Pyx_GIVEREF(__pyx_float_0_00371);
  PyList_SET_ITEM(__pyx_t_13, 6, __pyx_float_0_00371);
  __Pyx_INCREF(__pyx_float_0_00329);
  __Pyx_GIVEREF(__pyx_float_0_00329);
  PyList_SET_ITEM(__pyx_t_13, 7, __pyx_float_0_00329);
  __Pyx_INCREF(__pyx_float_0_00314);
  __Pyx_GIVEREF(__pyx_float_0_00314);
  PyList_SET_ITEM(__pyx_t_13, 8, __pyx_float_0_00314);

  /* "_hydra.pyx":194
 *             [1.0, 0.0869, 0.0276,  0.0136,  0.00864, 0.0065,   0.00552,  0.00513,  0.00509],
 *             [1.0, 0.08,   0.0236,  0.0108,  0.00646, 0.00459,  0.00371,  0.00329,  0.00314],
 *             [1.0, 0.074,  0.0203,  0.00875, 0.00492, 0.00332,  0.00255,  0.00217,  0.00199,  0.00194],             # <<<<<<<<<<<<<<
 *             [1.0, 0.0689, 0.0177,  0.00718, 0.00381, 0.00244,  0.00179,  0.00146,  0.00129,  0.00121,  0.0012],
 *             [1.0, 0.0645, 0.0156,  0.00596, 0.003,   0.00183,  0.00128,  0.001,    0.000852, 0.000775, 0.000744], # 15
 */
  __pyx_t_14 = PyList_New(10); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 194, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_14);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_14, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_074);
  __Pyx_GIVEREF(__pyx_float_0_074);
  PyList_SET_ITEM(__pyx_t_14, 1, __pyx_float_0_074);
  __Pyx_INCREF(__pyx_float_0_0203);
  __Pyx_GIVEREF(__pyx_float_0_0203);
  PyList_SET_ITEM(__pyx_t_14, 2, __pyx_float_0_0203);
  __Pyx_INCREF(__pyx_float_0_00875);
  __Pyx_GIVEREF(__pyx_float_0_00875);
  PyList_SET_ITEM(__pyx_t_14, 3, __pyx_float_0_00875);
  __Pyx_INCREF(__pyx_float_0_00492);
  __Pyx_GIVEREF(__pyx_float_0_00492);
  PyList_SET_ITEM(__pyx_t_14, 4, __pyx_float_0_00492);
  __Pyx_INCREF(__pyx_float_0_00332);
  __Pyx_GIVEREF(__pyx_float_0_00332);
  PyList_SET_ITEM(__pyx_t_14, 5, __pyx_float_0_00332);
  __Pyx_INCREF(__pyx_float_0_00255);
  __Pyx_GIVEREF(__pyx_float_0_00255);
  PyList_SET_ITEM(__pyx_t_14, 6, __pyx_float_0_00255);
  __Pyx_INCREF(__pyx_float_0_00217);
  __Pyx_GIVEREF(__pyx_float_0_00217);
  PyList_SET_ITEM(__pyx_t_14, 7, __pyx_float_0_00217);
  __Pyx_INCREF(__pyx_float_0_00199);
  __Pyx_GIVEREF(__pyx_float_0_00199);
  PyList_SET_ITEM(__pyx_t_14, 8, __pyx_float_0_00199);
  __Pyx_INCREF(__pyx_float_0_00194);
  __Pyx_GIVEREF(__pyx_float_0_00194);
  PyList_SET_ITEM(__pyx_t_14, 9, __pyx_float_0_00194);

  /* "_hydra.pyx":195
 *             [1.0, 0.08,   0.0236,  0.0108,  0.00646, 0.00459,  0.00371,  0.00329,  0.00314],
 *             [1.0, 0.074,  0.0203,  0.00875, 0.00492, 0.00332,  0.00255,  0.00217,  0.00199,  0.00194],
 *             [1.0, 0.0689, 0.0177,  0.00718, 0.00381, 0.00244,  0.00179,  0.00146,  0.00129,  0.00121,  0.0012],             # <<<<<<<<<<<<<<
 *             [1.0, 0.0645, 0.0156,  0.00596, 0.003,   0.00183,  0.00128,  0.001,    0.000852, 0.000775, 0.000744], # 15
 *             [1.0, 0.0606, 0.0138,  0.005,   0.00239, 0.00139,  0.000935, 0.000702, 0.000574, 0.000505, 0.00047,  0.000459],
 */
  __pyx_t_15 = PyList_New(11); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 195, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_15);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_15, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_0689);
  __Pyx_GIVEREF(__pyx_float_0_0689);
  PyList_SET_ITEM(__pyx_t_15, 1, __pyx_float_0_0689);
  __Pyx_INCREF(__pyx_float_0_0177);
  __Pyx_GIVEREF(__pyx_float_0_0177);
  PyList_SET_ITEM(__pyx_t_15, 2, __pyx_float_0_0177);
  __Pyx_INCREF(__pyx_float_0_00718);
  __Pyx_GIVEREF(__pyx_float_0_00718);
  PyList_SET_ITEM(__pyx_t_15, 3, __pyx_float_0_00718);
  __Pyx_INCREF(__pyx_float_0_00381);
  __Pyx_GIVEREF(__pyx_float_0_00381);
  PyList_SET_ITEM(__pyx_t_15, 4, __pyx_float_0_00381);
  __Pyx_INCREF(__pyx_float_0_00244);
  __Pyx_GIVEREF(__pyx_float_0_00244);
  PyList_SET_ITEM(__pyx_t_15, 5, __pyx_float_0_00244);
  __Pyx_INCREF(__pyx_float_0_00179);
  __Pyx_GIVEREF(__pyx_float_0_00179);
  PyList_SET_ITEM(__pyx_t_15, 6, __pyx_float_0_00179);
  __Pyx_INCREF(__pyx_float_0_00146);
  __Pyx_GIVEREF(__pyx_float_0_00146);
  PyList_SET_ITEM(__pyx_t_15, 7, __pyx_float_0_00146);
  __Pyx_INCREF(__pyx_float_0_00129);
  __Pyx_GIVEREF(__pyx_float_0_00129);
  PyList_SET_ITEM(__pyx_t_15, 8, __pyx_float_0_00129);
  __Pyx_INCREF(__pyx_float_0_00121);
  __Pyx_GIVEREF(__pyx_float_0_00121);
  PyList_SET_ITEM(__pyx_t_15, 9, __pyx_float_0_00121);
  __Pyx_INCREF(__pyx_float_0_0012);
  __Pyx_GIVEREF(__pyx_float_0_0012);
  PyList_SET_ITEM(__pyx_t_15, 10, __pyx_float_0_0012);

  /* "_hydra.pyx":196
 *             [1.0, 0.074,  0.0203,  0.00875, 0.00492, 0.00332,  0.00255,  0.00217,  0.00199,  0.00194],
 *             [1.0, 0.0689, 0.0177,  0.00718, 0.00381, 0.00244,  0.00179,  0.00146,  0.00129,  0.00121,  0.0012],
 *             [1.0, 0.0645, 0.0156,  0.00596, 0.003,   0.00183,  0.00128,  0.001,    0.000852, 0.000775, 0.000744], # 15             # <<<<<<<<<<<<<<
 *             [1.0, 0.0606, 0.0138,  0.005,   0.00239, 0.00139,  0.000935, 0.000702, 0.000574, 0.000505, 0.00047,  0.000459],
 *             [1.0, 0.0571, 0.0123,  0.00423, 0.00193, 0.00107,  0.000692, 0.000499, 0.000394, 0.000335, 0.000302, 0.000287, 0.000284],
 */
  __pyx_t_16 = PyList_New(11); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 196, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_16);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_16, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_0645);
  __Pyx_GIVEREF(__pyx_float_0_0645);
  PyList_SET_ITEM(__pyx_t_16, 1, __pyx_float_0_0645);
  __Pyx_INCREF(__pyx_float_0_0156);
  __Pyx_GIVEREF(__pyx_float_0_0156);
  PyList_SET_ITEM(__pyx_t_16, 2, __pyx_float_0_0156);
  __Pyx_INCREF(__pyx_float_0_00596);
  __Pyx_GIVEREF(__pyx_float_0_00596);
  PyList_SET_ITEM(__pyx_t_16, 3, __pyx_float_0_00596);
  __Pyx_INCREF(__pyx_float_0_003);
  __Pyx_GIVEREF(__pyx_float_0_003);
  PyList_SET_ITEM(__pyx_t_16, 4, __pyx_float_0_003);
  __Pyx_INCREF(__pyx_float_0_00183);
  __Pyx_GIVEREF(__pyx_float_0_00183);
  PyList_SET_ITEM(__pyx_t_16, 5, __pyx_float_0_00183);
  __Pyx_INCREF(__pyx_float_0_00128);
  __Pyx_GIVEREF(__pyx_float_0_00128);
  PyList_SET_ITEM(__pyx_t_16, 6, __pyx_float_0_00128);
  __Pyx_INCREF(__pyx_float_0_001);
  __Pyx_GIVEREF(__pyx_float_0_001);
  PyList_SET_ITEM(__pyx_t_16, 7, __pyx_float_0_001);
  __Pyx_INCREF(__pyx_float_0_000852);
  __Pyx_GIVEREF(__pyx_float_0_000852);
  PyList_SET_ITEM(__pyx_t_16, 8, __pyx_float_0_000852);
  __Pyx_INCREF(__pyx_float_0_000775);
  __Pyx_GIVEREF(__pyx_float_0_000775);
  PyList_SET_ITEM(__pyx_t_16, 9, __pyx_float_0_000775);
  __Pyx_INCREF(__pyx_float_0_000744);
  __Pyx_GIVEREF(__pyx_float_0_000744);
  PyList_SET_ITEM(__pyx_t_16, 10, __pyx_float_0_000744);

  /* "_hydra.pyx":197
 *             [1.0, 0.0689, 0.0177,  0.00718, 0.00381, 0.00244,  0.00179,  0.00146,  0.00129,  0.00121,  0.0012],
 *             [1.0, 0.0645, 0.0156,  0.00596, 0.003,   0.00183,  0.00128,  0.001,    0.000852, 0.000775, 0.000744], # 15
 *             [1.0, 0.0606, 0.0138,  0.005,   0.00239, 0.00139,  0.000935, 0.000702, 0.000574, 0.000505, 0.00047,  0.000459],             # <<<<<<<<<<<<<<
 *             [1.0, 0.0571, 0.0123,  0.00423, 0.00193, 0.00107,  0.000692, 0.000499, 0.000394, 0.000335, 0.000302, 0.000287, 0.000284],
 *             [1.0, 0.054,  0.0111,  0.00362, 0.00158, 0.000839, 0.000519, 0.00036,  0.000275, 0.000226, 0.000198, 0.000183, 0.000176],
 */
  __pyx_t_17 = PyList_New(12); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 197, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_17);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_17, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_0606);
  __Pyx_GIVEREF(__pyx_float_0_0606);
  PyList_SET_ITEM(__pyx_t_17, 1, __pyx_float_0_0606);
  __Pyx_INCREF(__pyx_float_0_0138);
  __Pyx_GIVEREF(__pyx_float_0_0138);
  PyList_SET_ITEM(__pyx_t_17, 2, __pyx_float_0_0138);
  __Pyx_INCREF(__pyx_float_0_005);
  __Pyx_GIVEREF(__pyx_float_0_005);
  PyList_SET_ITEM(__pyx_t_17, 3, __pyx_float_0_005);
  __Pyx_INCREF(__pyx_float_0_00239);
  __Pyx_GIVEREF(__pyx_float_0_00239);
  PyList_SET_ITEM(__pyx_t_17, 4, __pyx_float_0_00239);
  __Pyx_INCREF(__pyx_float_0_00139);
  __Pyx_GIVEREF(__pyx_float_0_00139);
  PyList_SET_ITEM(__pyx_t_17, 5, __pyx_float_0_00139);
  __Pyx_INCREF(__pyx_float_0_000935);
  __Pyx_GIVEREF(__pyx_float_0_000935);
  PyList_SET_ITEM(__pyx_t_17, 6, __pyx_float_0_000935);
  __Pyx_INCREF(__pyx_float_0_000702);
  __Pyx_GIVEREF(__pyx_float_0_000702);
  PyList_SET_ITEM(__pyx_t_17, 7, __pyx_float_0_000702);
  __Pyx_INCREF(__pyx_float_0_000574);
  __Pyx_GIVEREF(__pyx_float_0_000574);
  PyList_SET_ITEM(__pyx_t_17, 8, __pyx_float_0_000574);
  __Pyx_INCREF(__pyx_float_0_000505);
  __Pyx_GIVEREF(__pyx_float_0_000505);
  PyList_SET_ITEM(__pyx_t_17, 9, __pyx_float_0_000505);
  __Pyx_INCREF(__pyx_float_0_00047);
  __Pyx_GIVEREF(__pyx_float_0_00047);
  PyList_SET_ITEM(__pyx_t_17, 10, __pyx_float_0_00047);
  __Pyx_INCREF(__pyx_float_0_000459);
  __Pyx_GIVEREF(__pyx_float_0_000459);
  PyList_SET_ITEM(__pyx_t_17, 11, __pyx_float_0_000459);

  /* "_hydra.pyx":198
 *             [1.0, 0.0645, 0.0156,  0.00596, 0.003,   0.00183,  0.00128,  0.001,    0.000852, 0.000775, 0.000744], # 15
 *             [1.0, 0.0606, 0.0138,  0.005,   0.00239, 0.00139,  0.000935, 0.000702, 0.000574, 0.000505, 0.00047,  0.000459],
 *             [1.0, 0.0571, 0.0123,  0.00423, 0.00193, 0.00107,  0.000692, 0.000499, 0.000394, 0.000335, 0.000302, 0.000287, 0.000284],             # <<<<<<<<<<<<<<
 *             [1.0, 0.054,  0.0111,  0.00362, 0.00158, 0.000839, 0.000519, 0.00036,  0.000275, 0.000226, 0.000198, 0.000183, 0.000176],
 *             [1.0, 0.0513, 0.00998, 0.00312, 0.0013,  0.000663, 0.000394, 0.000264, 0.000194, 0.000155, 0.000132, 0.000118, 0.000111, 0.000109],
 */
  __pyx_t_18 = PyList_New(13); if (unlikely(!__pyx_t_18)) __PYX_ERR(0, 198, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_18);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_18, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_0571);
  __Pyx_GIVEREF(__pyx_float_0_0571);
  PyList_SET_ITEM(__pyx_t_18, 1, __pyx_float_0_0571);
  __Pyx_INCREF(__pyx_float_0_0123);
  __Pyx_GIVEREF(__pyx_float_0_0123);
  PyList_SET_ITEM(__pyx_t_18, 2, __pyx_float_0_0123);
  __Pyx_INCREF(__pyx_float_0_00423);
  __Pyx_GIVEREF(__pyx_float_0_00423);
  PyList_SET_ITEM(__pyx_t_18, 3, __pyx_float_0_00423);
  __Pyx_INCREF(__pyx_float_0_00193);
  __Pyx_GIVEREF(__pyx_float_0_00193);
  PyList_SET_ITEM(__pyx_t_18, 4, __pyx_float_0_00193);
  __Pyx_INCREF(__pyx_float_0_00107);
  __Pyx_GIVEREF(__pyx_float_0_00107);
  PyList_SET_ITEM(__pyx_t_18, 5, __pyx_float_0_00107);
  __Pyx_INCREF(__pyx_float_0_000692);
  __Pyx_GIVEREF(__pyx_float_0_000692);
  PyList_SET_ITEM(__pyx_t_18, 6, __pyx_float_0_000692);
  __Pyx_INCREF(__pyx_float_0_000499);
  __Pyx_GIVEREF(__pyx_float_0_000499);
  PyList_SET_ITEM(__pyx_t_18, 7, __pyx_float_0_000499);
  __Pyx_INCREF(__pyx_float_0_000394);
  __Pyx_GIVEREF(__pyx_float_0_000394);
  PyList_SET_ITEM(__pyx_t_18, 8, __pyx_float_0_000394);
  __Pyx_INCREF(__pyx_float_0_000335);
  __Pyx_GIVEREF(__pyx_float_0_000335);
  PyList_SET_ITEM(__pyx_t_18, 9, __pyx_float_0_000335);
  __Pyx_INCREF(__pyx_float_0_000302);
  __Pyx_GIVEREF(__pyx_float_0_000302);
  PyList_SET_ITEM(__pyx_t_18, 10, __pyx_float_0_000302);
  __Pyx_INCREF(__pyx_float_0_000287);
  __Pyx_GIVEREF(__pyx_float_0_000287);
  PyList_SET_ITEM(__pyx_t_18, 11, __pyx_float_0_000287);
  __Pyx_INCREF(__pyx_float_0_000284);
  __Pyx_GIVEREF(__pyx_float_0_000284);
  PyList_SET_ITEM(__pyx_t_18, 12, __pyx_float_0_000284);

  /* "_hydra.pyx":199
 *             [1.0, 0.0606, 0.0138,  0.005,   0.00239, 0.00139,  0.000935, 0.000702, 0.000574, 0.000505, 0.00047,  0.000459],
 *             [1.0, 0.0571, 0.0123,  0.00423, 0.00193, 0.00107,  0.000692, 0.000499, 0.000394, 0.000335, 0.000302, 0.000287, 0.000284],
 *             [1.0, 0.054,  0.0111,  0.00362, 0.00158, 0.000839, 0.000519, 0.00036,  0.000275, 0.000226, 0.000198, 0.000183, 0.000176],             # <<<<<<<<<<<<<<
 *             [1.0, 0.0513, 0.00998, 0.00312, 0.0013,  0.000663, 0.000394, 0.000264, 0.000194, 0.000155, 0.000132, 0.000118, 0.000111, 0.000109],
 *             [1.0, 0.0488, 0.00906, 0.0027,  0.00108, 0.00053,  0.000303, 0.000196, 0.00014,  0.000108, 8.89e-05, 7.77e-05, 7.12e-05, 6.79e-05, 6.71e-05] # 20
 */
  __pyx_t_19 = PyList_New(13); if (unlikely(!__pyx_t_19)) __PYX_ERR(0, 199, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_19);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_19, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_054);
  __Pyx_GIVEREF(__pyx_float_0_054);
  PyList_SET_ITEM(__pyx_t_19, 1, __pyx_float_0_054);
  __Pyx_INCREF(__pyx_float_0_0111);
  __Pyx_GIVEREF(__pyx_float_0_0111);
  PyList_SET_ITEM(__pyx_t_19, 2, __pyx_float_0_0111);
  __Pyx_INCREF(__pyx_float_0_00362);
  __Pyx_GIVEREF(__pyx_float_0_00362);
  PyList_SET_ITEM(__pyx_t_19, 3, __pyx_float_0_00362);
  __Pyx_INCREF(__pyx_float_0_00158);
  __Pyx_GIVEREF(__pyx_float_0_00158);
  PyList_SET_ITEM(__pyx_t_19, 4, __pyx_float_0_00158);
  __Pyx_INCREF(__pyx_float_0_000839);
  __Pyx_GIVEREF(__pyx_float_0_000839);
  PyList_SET_ITEM(__pyx_t_19, 5, __pyx_float_0_000839);
  __Pyx_INCREF(__pyx_float_0_000519);
  __Pyx_GIVEREF(__pyx_float_0_000519);
  PyList_SET_ITEM(__pyx_t_19, 6, __pyx_float_0_000519);
  __Pyx_INCREF(__pyx_float_0_00036);
  __Pyx_GIVEREF(__pyx_float_0_00036);
  PyList_SET_ITEM(__pyx_t_19, 7, __pyx_float_0_00036);
  __Pyx_INCREF(__pyx_float_0_000275);
  __Pyx_GIVEREF(__pyx_float_0_000275);
  PyList_SET_ITEM(__pyx_t_19, 8, __pyx_float_0_000275);
  __Pyx_INCREF(__pyx_float_0_000226);
  __Pyx_GIVEREF(__pyx_float_0_000226);
  PyList_SET_ITEM(__pyx_t_19, 9, __pyx_float_0_000226);
  __Pyx_INCREF(__pyx_float_0_000198);
  __Pyx_GIVEREF(__pyx_float_0_000198);
  PyList_SET_ITEM(__pyx_t_19, 10, __pyx_float_0_000198);
  __Pyx_INCREF(__pyx_float_0_000183);
  __Pyx_GIVEREF(__pyx_float_0_000183);
  PyList_SET_ITEM(__pyx_t_19, 11, __pyx_float_0_000183);
  __Pyx_INCREF(__pyx_float_0_000176);
  __Pyx_GIVEREF(__pyx_float_0_000176);
  PyList_SET_ITEM(__pyx_t_19, 12, __pyx_float_0_000176);

  /* "_hydra.pyx":200
 *             [1.0, 0.0571, 0.0123,  0.00423, 0.00193, 0.00107,  0.000692, 0.000499, 0.000394, 0.000335, 0.000302, 0.000287, 0.000284],
 *             [1.0, 0.054,  0.0111,  0.00362, 0.00158, 0.000839, 0.000519, 0.00036,  0.000275, 0.000226, 0.000198, 0.000183, 0.000176],
 *             [1.0, 0.0513, 0.00998, 0.00312, 0.0013,  0.000663, 0.000394, 0.000264, 0.000194, 0.000155, 0.000132, 0.000118, 0.000111, 0.000109],             # <<<<<<<<<<<<<<
 *             [1.0, 0.0488, 0.00906, 0.0027,  0.00108, 0.00053,  0.000303, 0.000196, 0.00014,  0.000108, 8.89e-05, 7.77e-05, 7.12e-05, 6.79e-05, 6.71e-05] # 20
 *             ]
 */
  __pyx_t_20 = PyList_New(14); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 200, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_20);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_20, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_0513);
  __Pyx_GIVEREF(__pyx_float_0_0513);
  PyList_SET_ITEM(__pyx_t_20, 1, __pyx_float_0_0513);
  __Pyx_INCREF(__pyx_float_0_00998);
  __Pyx_GIVEREF(__pyx_float_0_00998);
  PyList_SET_ITEM(__pyx_t_20, 2, __pyx_float_0_00998);
  __Pyx_INCREF(__pyx_float_0_00312);
  __Pyx_GIVEREF(__pyx_float_0_00312);
  PyList_SET_ITEM(__pyx_t_20, 3, __pyx_float_0_00312);
  __Pyx_INCREF(__pyx_float_0_0013);
  __Pyx_GIVEREF(__pyx_float_0_0013);
  PyList_SET_ITEM(__pyx_t_20, 4, __pyx_float_0_0013);
  __Pyx_INCREF(__pyx_float_0_000663);
  __Pyx_GIVEREF(__pyx_float_0_000663);
  PyList_SET_ITEM(__pyx_t_20, 5, __pyx_float_0_000663);
  __Pyx_INCREF(__pyx_float_0_000394);
  __Pyx_GIVEREF(__pyx_float_0_000394);
  PyList_SET_ITEM(__pyx_t_20, 6, __pyx_float_0_000394);
  __Pyx_INCREF(__pyx_float_0_000264);
  __Pyx_GIVEREF(__pyx_float_0_000264);
  PyList_SET_ITEM(__pyx_t_20, 7, __pyx_float_0_000264);
  __Pyx_INCREF(__pyx_float_0_000194);
  __Pyx_GIVEREF(__pyx_float_0_000194);
  PyList_SET_ITEM(__pyx_t_20, 8, __pyx_float_0_000194);
  __Pyx_INCREF(__pyx_float_0_000155);
  __Pyx_GIVEREF(__pyx_float_0_000155);
  PyList_SET_ITEM(__pyx_t_20, 9, __pyx_float_0_000155);
  __Pyx_INCREF(__pyx_float_0_000132);
  __Pyx_GIVEREF(__pyx_float_0_000132);
  PyList_SET_ITEM(__pyx_t_20, 10, __pyx_float_0_000132);
  __Pyx_INCREF(__pyx_float_0_000118);
  __Pyx_GIVEREF(__pyx_float_0_000118);
  PyList_SET_ITEM(__pyx_t_20, 11, __pyx_float_0_000118);
  __Pyx_INCREF(__pyx_float_0_000111);
  __Pyx_GIVEREF(__pyx_float_0_000111);
  PyList_SET_ITEM(__pyx_t_20, 12, __pyx_float_0_000111);
  __Pyx_INCREF(__pyx_float_0_000109);
  __Pyx_GIVEREF(__pyx_float_0_000109);
  PyList_SET_ITEM(__pyx_t_20, 13, __pyx_float_0_000109);

  /* "_hydra.pyx":201
 *             [1.0, 0.054,  0.0111,  0.00362, 0.00158, 0.000839, 0.000519, 0.00036,  0.000275, 0.000226, 0.000198, 0.000183, 0.000176],
 *             [1.0, 0.0513, 0.00998, 0.00312, 0.0013,  0.000663, 0.000394, 0.000264, 0.000194, 0.000155, 0.000132, 0.000118, 0.000111, 0.000109],
 *             [1.0, 0.0488, 0.00906, 0.0027,  0.00108, 0.00053,  0.000303, 0.000196, 0.00014,  0.000108, 8.89e-05, 7.77e-05, 7.12e-05, 6.79e-05, 6.71e-05] # 20             # <<<<<<<<<<<<<<
 *             ]
 * 
 */
  __pyx_t_21 = PyList_New(15); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 201, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_21);
  __Pyx_INCREF(__pyx_float_1_0);
  __Pyx_GIVEREF(__pyx_float_1_0);
  PyList_SET_ITEM(__pyx_t_21, 0, __pyx_float_1_0);
  __Pyx_INCREF(__pyx_float_0_0488);
  __Pyx_GIVEREF(__pyx_float_0_0488);
  PyList_SET_ITEM(__pyx_t_21, 1, __pyx_float_0_0488);
  __Pyx_INCREF(__pyx_float_0_00906);
  __Pyx_GIVEREF(__pyx_float_0_00906);
  PyList_SET_ITEM(__pyx_t_21, 2, __pyx_float_0_00906);
  __Pyx_INCREF(__pyx_float_0_0027);
  __Pyx_GIVEREF(__pyx_float_0_0027);
  PyList_SET_ITEM(__pyx_t_21, 3, __pyx_float_0_0027);
  __Pyx_INCREF(__pyx_float_0_00108);
  __Pyx_GIVEREF(__pyx_float_0_00108);
  PyList_SET_ITEM(__pyx_t_21, 4, __pyx_float_0_00108);
  __Pyx_INCREF(__pyx_float_0_00053);
  __Pyx_GIVEREF(__pyx_float_0_00053);
  PyList_SET_ITEM(__pyx_t_21, 5, __pyx_float_0_00053);
  __Pyx_INCREF(__pyx_float_0_000303);
  __Pyx_GIVEREF(__pyx_float_0_000303);
  PyList_SET_ITEM(__pyx_t_21, 6, __pyx_float_0_000303);
  __Pyx_INCREF(__pyx_float_0_000196);
  __Pyx_GIVEREF(__pyx_float_0_000196);
  PyList_SET_ITEM(__pyx_t_21, 7, __pyx_float_0_000196);
  __Pyx_INCREF(__pyx_float_0_00014);
  __Pyx_GIVEREF(__pyx_float_0_00014);
  PyList_SET_ITEM(__pyx_t_21, 8, __pyx_float_0_00014);
  __Pyx_INCREF(__pyx_float_0_000108);
  __Pyx_GIVEREF(__pyx_float_0_000108);
  PyList_SET_ITEM(__pyx_t_21, 9, __pyx_float_0_000108);
  __Pyx_INCREF(__pyx_float_8_89eneg_05);
  __Pyx_GIVEREF(__pyx_float_8_89eneg_05);
  PyList_SET_ITEM(__pyx_t_21, 10, __pyx_float_8_89eneg_05);
  __Pyx_INCREF(__pyx_float_7_77eneg_05);
  __Pyx_GIVEREF(__pyx_float_7_77eneg_05);
  PyList_SET_ITEM(__pyx_t_21, 11, __pyx_float_7_77eneg_05);
  __Pyx_INCREF(__pyx_float_7_12eneg_05);
  __Pyx_GIVEREF(__pyx_float_7_12eneg_05);
  PyList_SET_ITEM(__pyx_t_21, 12, __pyx_float_7_12eneg_05);
  __Pyx_INCREF(__pyx_float_6_79eneg_05);
  __Pyx_GIVEREF(__pyx_float_6_79eneg_05);
  PyList_SET_ITEM(__pyx_t_21, 13, __pyx_float_6_79eneg_05);
  __Pyx_INCREF(__pyx_float_6_71eneg_05);
  __Pyx_GIVEREF(__pyx_float_6_71eneg_05);
  PyList_SET_ITEM(__pyx_t_21, 14, __pyx_float_6_71eneg_05);

  /* "_hydra.pyx":180
 *     minK = 1
 * 
 *     PROBS = [             # <<<<<<<<<<<<<<
 *             [1.0], #  dummy row representing 0 buckets per element
 *             [1.0, 1.0], #  dummy row representing 1 buckets per element
 */
  __pyx_t_22 = PyList_New(21); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 180, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_22);
  __Pyx_GIVEREF(__pyx_t_1);
  PyList_SET_ITEM(__pyx_t_22, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyList_SET_ITEM(__pyx_t_22, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_3);
  PyList_SET_ITEM(__pyx_t_22, 2, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_4);
  PyList_SET_ITEM(__pyx_t_22, 3, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_5);
  PyList_SET_ITEM(__pyx_t_22, 4, __pyx_t_5);
  __Pyx_GIVEREF(__pyx_t_6);
  PyList_SET_ITEM(__pyx_t_22, 5, __pyx_t_6);
  __Pyx_GIVEREF(__pyx_t_7);
  PyList_SET_ITEM(__pyx_t_22, 6, __pyx_t_7);
  __Pyx_GIVEREF(__pyx_t_8);
  PyList_SET_ITEM(__pyx_t_22, 7, __pyx_t_8);
  __Pyx_GIVEREF(__pyx_t_9);
  PyList_SET_ITEM(__pyx_t_22, 8, __pyx_t_9);
  __Pyx_GIVEREF(__pyx_t_10);
  PyList_SET_ITEM(__pyx_t_22, 9, __pyx_t_10);
  __Pyx_GIVEREF(__pyx_t_11);
  PyList_SET_ITEM(__pyx_t_22, 10, __pyx_t_11);
  __Pyx_GIVEREF(__pyx_t_12);
  PyList_SET_ITEM(__pyx_t_22, 11, __pyx_t_12);
  __Pyx_GIVEREF(__pyx_t_13);
  PyList_SET_ITEM(__pyx_t_22, 12, __pyx_t_13);
  __Pyx_GIVEREF(__pyx_t_14);
  PyList_SET_ITEM(__pyx_t_22, 13, __pyx_t_14);
  __Pyx_GIVEREF(__pyx_t_15);
  PyList_SET_ITEM(__pyx_t_22, 14, __pyx_t_15);
  __Pyx_GIVEREF(__pyx_t_16);
  PyList_SET_ITEM(__pyx_t_22, 15, __pyx_t_16);
  __Pyx_GIVEREF(__pyx_t_17);
  PyList_SET_ITEM(__pyx_t_22, 16, __pyx_t_17);
  __Pyx_GIVEREF(__pyx_t_18);
  PyList_SET_ITEM(__pyx_t_22, 17, __pyx_t_18);
  __Pyx_GIVEREF(__pyx_t_19);
  PyList_SET_ITEM(__pyx_t_22, 18, __pyx_t_19);
  __Pyx_GIVEREF(__pyx_t_20);
  PyList_SET_ITEM(__pyx_t_22, 19, __pyx_t_20);
  __Pyx_GIVEREF(__pyx_t_21);
  PyList_SET_ITEM(__pyx_t_22, 20, __pyx_t_21);
  __pyx_t_1 = 0;
  __pyx_t_2 = 0;
  __pyx_t_3 = 0;
  __pyx_t_4 = 0;
  __pyx_t_5 = 0;
  __pyx_t_6 = 0;
  __pyx_t_7 = 0;
  __pyx_t_8 = 0;
  __pyx_t_9 = 0;
  __pyx_t_10 = 0;
  __pyx_t_11 = 0;
  __pyx_t_12 = 0;
  __pyx_t_13 = 0;
  __pyx_t_14 = 0;
  __pyx_t_15 = 0;
  __pyx_t_16 = 0;
  __pyx_t_17 = 0;
  __pyx_t_18 = 0;
  __pyx_t_19 = 0;
  __pyx_t_20 = 0;
  __pyx_t_21 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_6_hydra_BloomCalculations->tp_dict, __pyx_n_s_PROBS, __pyx_t_22) < 0) __PYX_ERR(0, 180, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
  PyType_Modified(__pyx_ptype_6_hydra_BloomCalculations);

  /* "_hydra.pyx":204
 *             ]
 * 
 *     optKPerBuckets = [max(1, min(enumerate(probs), key=operator.itemgetter(1))[0]) for probs in PROBS]             # <<<<<<<<<<<<<<
 * 
 *     @classmethod
 */
  __pyx_t_22 = PyList_New(0); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_22);
  __pyx_t_21 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_6_hydra_BloomCalculations, __pyx_n_s_PROBS); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_21);
  if (likely(PyList_CheckExact(__pyx_t_21)) || PyTuple_CheckExact(__pyx_t_21)) {
    __pyx_t_20 = __pyx_t_21; __Pyx_INCREF(__pyx_t_20); __pyx_t_23 = 0;
    __pyx_t_24 = NULL;
  } else {
    __pyx_t_23 = -1; __pyx_t_20 = PyObject_GetIter(__pyx_t_21); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_20);
    __pyx_t_24 = Py_TYPE(__pyx_t_20)->tp_iternext; if (unlikely(!__pyx_t_24)) __PYX_ERR(0, 204, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
  for (;;) {
    if (likely(!__pyx_t_24)) {
      if (likely(PyList_CheckExact(__pyx_t_20))) {
        if (__pyx_t_23 >= PyList_GET_SIZE(__pyx_t_20)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_21 = PyList_GET_ITEM(__pyx_t_20, __pyx_t_23); __Pyx_INCREF(__pyx_t_21); __pyx_t_23++; if (unlikely(0 < 0)) __PYX_ERR(0, 204, __pyx_L1_error)
        #else
        __pyx_t_21 = PySequence_ITEM(__pyx_t_20, __pyx_t_23); __pyx_t_23++; if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 204, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_21);
        #endif
      } else {
        if (__pyx_t_23 >= PyTuple_GET_SIZE(__pyx_t_20)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_21 = PyTuple_GET_ITEM(__pyx_t_20, __pyx_t_23); __Pyx_INCREF(__pyx_t_21); __pyx_t_23++; if (unlikely(0 < 0)) __PYX_ERR(0, 204, __pyx_L1_error)
        #else
        __pyx_t_21 = PySequence_ITEM(__pyx_t_20, __pyx_t_23); __pyx_t_23++; if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 204, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_21);
        #endif
      }
    } else {
      __pyx_t_21 = __pyx_t_24(__pyx_t_20);
      if (unlikely(!__pyx_t_21)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 204, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_21);
    }
    if (PyDict_SetItem((PyObject *)__pyx_ptype_6_hydra_BloomCalculations->tp_dict, __pyx_n_s_probs, __pyx_t_21) < 0) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
    PyType_Modified(__pyx_ptype_6_hydra_BloomCalculations);
    __pyx_t_21 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_6_hydra_BloomCalculations, __pyx_n_s_probs); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_21);
    __pyx_t_19 = PyTuple_New(1); if (unlikely(!__pyx_t_19)) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_19);
    __Pyx_GIVEREF(__pyx_t_21);
    PyTuple_SET_ITEM(__pyx_t_19, 0, __pyx_t_21);
    __pyx_t_21 = 0;
    __pyx_t_21 = __Pyx_PyObject_Call(__pyx_builtin_enumerate, __pyx_t_19, NULL); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_21);
    __Pyx_DECREF(__pyx_t_19); __pyx_t_19 = 0;
    __pyx_t_19 = PyTuple_New(1); if (unlikely(!__pyx_t_19)) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_19);
    __Pyx_GIVEREF(__pyx_t_21);
    PyTuple_SET_ITEM(__pyx_t_19, 0, __pyx_t_21);
    __pyx_t_21 = 0;
    __pyx_t_21 = PyDict_New(); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_21);
    __pyx_t_18 = __Pyx_GetModuleGlobalName(__pyx_n_s_operator); if (unlikely(!__pyx_t_18)) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_18);
    __pyx_t_17 = __Pyx_PyObject_GetAttrStr(__pyx_t_18, __pyx_n_s_itemgetter); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_17);
    __Pyx_DECREF(__pyx_t_18); __pyx_t_18 = 0;
    __pyx_t_18 = __Pyx_PyObject_Call(__pyx_t_17, __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_18)) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_18);
    __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
    if (PyDict_SetItem(__pyx_t_21, __pyx_n_s_key, __pyx_t_18) < 0) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_18); __pyx_t_18 = 0;
    __pyx_t_18 = __Pyx_PyObject_Call(__pyx_builtin_min, __pyx_t_19, __pyx_t_21); if (unlikely(!__pyx_t_18)) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_18);
    __Pyx_DECREF(__pyx_t_19); __pyx_t_19 = 0;
    __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
    __pyx_t_21 = __Pyx_GetItemInt(__pyx_t_18, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_21);
    __Pyx_DECREF(__pyx_t_18); __pyx_t_18 = 0;
    __pyx_t_25 = 1;
    __pyx_t_19 = __Pyx_PyInt_From_long(__pyx_t_25); if (unlikely(!__pyx_t_19)) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_19);
    __pyx_t_17 = PyObject_RichCompare(__pyx_t_21, __pyx_t_19, Py_GT); __Pyx_XGOTREF(__pyx_t_17); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_19); __pyx_t_19 = 0;
    __pyx_t_26 = __Pyx_PyObject_IsTrue(__pyx_t_17); if (unlikely(__pyx_t_26 < 0)) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
    if (__pyx_t_26) {
      __Pyx_INCREF(__pyx_t_21);
      __pyx_t_18 = __pyx_t_21;
    } else {
      __pyx_t_17 = __Pyx_PyInt_From_long(__pyx_t_25); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 204, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_17);
      __pyx_t_18 = __pyx_t_17;
      __pyx_t_17 = 0;
    }
    __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
    if (unlikely(__Pyx_ListComp_Append(__pyx_t_22, (PyObject*)__pyx_t_18))) __PYX_ERR(0, 204, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_18); __pyx_t_18 = 0;
  }
  __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_6_hydra_BloomCalculations->tp_dict, __pyx_n_s_optKPerBuckets, __pyx_t_22) < 0) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
  PyType_Modified(__pyx_ptype_6_hydra_BloomCalculations);

  /* "_hydra.pyx":207
 * 
 *     @classmethod
 *     def computeBloomSpec1(cls, bucketsPerElement):             # <<<<<<<<<<<<<<
 *         """
 *         Given the number of buckets that can be used per element, return a
 */
  __pyx_t_22 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_6_hydra_BloomCalculations, __pyx_n_s_computeBloomSpec1); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 207, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_22);

  /* "_hydra.pyx":206
 *     optKPerBuckets = [max(1, min(enumerate(probs), key=operator.itemgetter(1))[0]) for probs in PROBS]
 * 
 *     @classmethod             # <<<<<<<<<<<<<<
 *     def computeBloomSpec1(cls, bucketsPerElement):
 *         """
 */
  __pyx_t_20 = __Pyx_Method_ClassMethod(__pyx_t_22); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 206, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_20);
  __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_6_hydra_BloomCalculations->tp_dict, __pyx_n_s_computeBloomSpec1, __pyx_t_20) < 0) __PYX_ERR(0, 207, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
  PyType_Modified(__pyx_ptype_6_hydra_BloomCalculations);

  /* "_hydra.pyx":221
 * 
 *     @classmethod
 *     def computeBloomSpec2(cls, maxBucketsPerElement, maxFalsePosProb):             # <<<<<<<<<<<<<<
 *         """
 *         Given a maximum tolerable false positive probability, compute a Bloom
 */
  __pyx_t_20 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_6_hydra_BloomCalculations, __pyx_n_s_computeBloomSpec2); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 221, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_20);

  /* "_hydra.pyx":220
 * 
 * 
 *     @classmethod             # <<<<<<<<<<<<<<
 *     def computeBloomSpec2(cls, maxBucketsPerElement, maxFalsePosProb):
 *         """
 */
  __pyx_t_22 = __Pyx_Method_ClassMethod(__pyx_t_20); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 220, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_22);
  __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_6_hydra_BloomCalculations->tp_dict, __pyx_n_s_computeBloomSpec2, __pyx_t_22) < 0) __PYX_ERR(0, 221, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
  PyType_Modified(__pyx_ptype_6_hydra_BloomCalculations);

  /* "_hydra.pyx":262
 * 
 * cdef class BloomFilter:
 *     EXCESS = 20             # <<<<<<<<<<<<<<
 *     cdef unsigned int _hashCount
 *     cdef MMapBitField _bitmap
 */
  if (PyDict_SetItem((PyObject *)__pyx_ptype_6_hydra_BloomFilter->tp_dict, __pyx_n_s_EXCESS, __pyx_int_20) < 0) __PYX_ERR(0, 262, __pyx_L1_error)
  PyType_Modified(__pyx_ptype_6_hydra_BloomFilter);

  /* "_hydra.pyx":296
 * 
 *     @classmethod
 *     def _maxBucketsPerElement(cls, numElements):             # <<<<<<<<<<<<<<
 *         numElements = max(1, numElements)
 *         v = (sys.maxsize - cls.EXCESS) / float(numElements)
 */
  __pyx_t_22 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_6_hydra_BloomFilter, __pyx_n_s_maxBucketsPerElement_2); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 296, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_22);

  /* "_hydra.pyx":295
 *         return self._bitmap._filename
 * 
 *     @classmethod             # <<<<<<<<<<<<<<
 *     def _maxBucketsPerElement(cls, numElements):
 *         numElements = max(1, numElements)
 */
  __pyx_t_20 = __Pyx_Method_ClassMethod(__pyx_t_22); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 295, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_20);
  __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_6_hydra_BloomFilter->tp_dict, __pyx_n_s_maxBucketsPerElement_2, __pyx_t_20) < 0) __PYX_ERR(0, 296, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
  PyType_Modified(__pyx_ptype_6_hydra_BloomFilter);

  /* "_hydra.pyx":305
 * 
 *     @classmethod
 *     def _bucketsFor(cls, numElements, bucketsPer, filename, read_only, want_lock=False, fdatasync_on_close=True):             # <<<<<<<<<<<<<<
 *         numBits = numElements * bucketsPer + cls.EXCESS
 *         bf_size = min(sys.maxsize, numBits)
 */
  __pyx_t_20 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_6_hydra_BloomFilter, __pyx_n_s_bucketsFor); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 305, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_20);

  /* "_hydra.pyx":304
 *         return min(len(BloomCalculations.PROBS) - 1, int(v))
 * 
 *     @classmethod             # <<<<<<<<<<<<<<
 *     def _bucketsFor(cls, numElements, bucketsPer, filename, read_only, want_lock=False, fdatasync_on_close=True):
 *         numBits = numElements * bucketsPer + cls.EXCESS
 */
  __pyx_t_22 = __Pyx_Method_ClassMethod(__pyx_t_20); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 304, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_22);
  __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_6_hydra_BloomFilter->tp_dict, __pyx_n_s_bucketsFor, __pyx_t_22) < 0) __PYX_ERR(0, 305, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
  PyType_Modified(__pyx_ptype_6_hydra_BloomFilter);

  /* "_hydra.pyx":313
 * 
 *     @classmethod
 *     def getFilter(cls, numElements, maxFalsePosProbability, **kwargs):             # <<<<<<<<<<<<<<
 *         """
 *         Create a bloom filter.
 */
  __pyx_t_22 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_6_hydra_BloomFilter, __pyx_n_s_getFilter); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 313, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_22);

  /* "_hydra.pyx":312
 *                             fdatasync_on_close=fdatasync_on_close)
 * 
 *     @classmethod             # <<<<<<<<<<<<<<
 *     def getFilter(cls, numElements, maxFalsePosProbability, **kwargs):
 *         """
 */
  __pyx_t_20 = __Pyx_Method_ClassMethod(__pyx_t_22); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 312, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_20);
  __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_6_hydra_BloomFilter->tp_dict, __pyx_n_s_getFilter, __pyx_t_20) < 0) __PYX_ERR(0, 313, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
  PyType_Modified(__pyx_ptype_6_hydra_BloomFilter);

  /* "_hydra.pyx":1
 * cimport cython             # <<<<<<<<<<<<<<
 * import operator
 * import os
 */
  __pyx_t_20 = PyDict_New(); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_20);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_20) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_XDECREF(__pyx_t_12);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_XDECREF(__pyx_t_14);
  __Pyx_XDECREF(__pyx_t_15);
  __Pyx_XDECREF(__pyx_t_16);
  __Pyx_XDECREF(__pyx_t_17);
  __Pyx_XDECREF(__pyx_t_18);
  __Pyx_XDECREF(__pyx_t_19);
  __Pyx_XDECREF(__pyx_t_20);
  __Pyx_XDECREF(__pyx_t_21);
  __Pyx_XDECREF(__pyx_t_22);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init _hydra", __pyx_clineno, __pyx_lineno, __pyx_filename);
    }
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init _hydra");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

/* --- Runtime support code --- */
/* Refnanny */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

/* GetBuiltinName */
static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

/* RaiseDoubleKeywords */
static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

/* ParseKeywords */
static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

/* RaiseArgTupleInvalid */
static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

/* PyObjectCall */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = func->ob_type->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* None */
static CYTHON_INLINE long __Pyx_div_long(long a, long b) {
    long q = a / b;
    long r = a - q*b;
    q -= ((r != 0) & ((r ^ b) < 0));
    return q;
}

/* PyErrFetchRestore */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
}
#endif

/* WriteUnraisableException */
static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
                                  int full_traceback, CYTHON_UNUSED int nogil) {
    PyObject *old_exc, *old_val, *old_tb;
    PyObject *ctx;
    __Pyx_PyThreadState_declare
#ifdef WITH_THREAD
    PyGILState_STATE state;
    if (nogil)
        state = PyGILState_Ensure();
#ifdef _MSC_VER
    else state = (PyGILState_STATE)-1;
#endif
#endif
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
    if (full_traceback) {
        Py_XINCREF(old_exc);
        Py_XINCREF(old_val);
        Py_XINCREF(old_tb);
        __Pyx_ErrRestore(old_exc, old_val, old_tb);
        PyErr_PrintEx(1);
    }
    #if PY_MAJOR_VERSION < 3
    ctx = PyString_FromString(name);
    #else
    ctx = PyUnicode_FromString(name);
    #endif
    __Pyx_ErrRestore(old_exc, old_val, old_tb);
    if (!ctx) {
        PyErr_WriteUnraisable(Py_None);
    } else {
        PyErr_WriteUnraisable(ctx);
        Py_DECREF(ctx);
    }
#ifdef WITH_THREAD
    if (nogil)
        PyGILState_Release(state);
#endif
}

/* PyObjectCallMethO */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
    PyObject *self, *result;
    PyCFunction cfunc;
    cfunc = PyCFunction_GET_FUNCTION(func);
    self = PyCFunction_GET_SELF(func);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = cfunc(self, arg);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyObjectCallOneArg */
#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_New(1);
    if (unlikely(!args)) return NULL;
    Py_INCREF(arg);
    PyTuple_SET_ITEM(args, 0, arg);
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
            return __Pyx_PyObject_CallMethO(func, arg);
        }
    }
    return __Pyx__PyObject_CallOneArg(func, arg);
}
#else
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_Pack(1, arg);
    if (unlikely(!args)) return NULL;
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
#endif

/* PyObjectCallNoArg */
  #if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
            return __Pyx_PyObject_CallMethO(func, NULL);
        }
    }
    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
}
#endif

/* RaiseException */
    #if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    __Pyx_PyThreadState_declare
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    if (PyType_Check(type)) {
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
    }
    __Pyx_PyThreadState_assign
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *instance_class = NULL;
        if (value && PyExceptionInstance_Check(value)) {
            instance_class = (PyObject*) Py_TYPE(value);
            if (instance_class != type) {
                int is_subclass = PyObject_IsSubclass(instance_class, type);
                if (!is_subclass) {
                    instance_class = NULL;
                } else if (unlikely(is_subclass == -1)) {
                    goto bad;
                } else {
                    type = instance_class;
                }
            }
        }
        if (!instance_class) {
            PyObject *args;
            if (!value)
                args = PyTuple_New(0);
            else if (PyTuple_Check(value)) {
                Py_INCREF(value);
                args = value;
            } else
                args = PyTuple_Pack(1, value);
            if (!args)
                goto bad;
            owned_instance = PyObject_Call(type, args, NULL);
            Py_DECREF(args);
            if (!owned_instance)
                goto bad;
            value = owned_instance;
            if (!PyExceptionInstance_Check(value)) {
                PyErr_Format(PyExc_TypeError,
                             "calling %R should have returned an instance of "
                             "BaseException, not %R",
                             type, Py_TYPE(value));
                goto bad;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
#if PY_VERSION_HEX >= 0x03030000
    if (cause) {
#else
    if (cause && cause != Py_None) {
#endif
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
#if CYTHON_COMPILING_IN_PYPY
        PyObject *tmp_type, *tmp_value, *tmp_tb;
        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
        Py_INCREF(tb);
        PyErr_Restore(tmp_type, tmp_value, tb);
        Py_XDECREF(tmp_tb);
#else
        PyThreadState *tstate = PyThreadState_GET();
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
#endif
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

/* ExtTypeTest */
      static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(PyObject_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

/* GetItemInt */
      static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
    PyObject *r;
    if (!j) return NULL;
    r = PyObject_GetItem(o, j);
    Py_DECREF(j);
    return r;
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              CYTHON_NCP_UNUSED int wraparound,
                                                              CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (wraparound & unlikely(i < 0)) i += PyList_GET_SIZE(o);
    if ((!boundscheck) || likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
        PyObject *r = PyList_GET_ITEM(o, i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              CYTHON_NCP_UNUSED int wraparound,
                                                              CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (wraparound & unlikely(i < 0)) i += PyTuple_GET_SIZE(o);
    if ((!boundscheck) || likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
        PyObject *r = PyTuple_GET_ITEM(o, i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
                                                     CYTHON_NCP_UNUSED int wraparound,
                                                     CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (is_list || PyList_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
        if ((!boundscheck) || (likely((n >= 0) & (n < PyList_GET_SIZE(o))))) {
            PyObject *r = PyList_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    }
    else if (PyTuple_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
        if ((!boundscheck) || likely((n >= 0) & (n < PyTuple_GET_SIZE(o)))) {
            PyObject *r = PyTuple_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    } else {
        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
        if (likely(m && m->sq_item)) {
            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
                Py_ssize_t l = m->sq_length(o);
                if (likely(l >= 0)) {
                    i += l;
                } else {
                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
                        return NULL;
                    PyErr_Clear();
                }
            }
            return m->sq_item(o, i);
        }
    }
#else
    if (is_list || PySequence_Check(o)) {
        return PySequence_GetItem(o, i);
    }
#endif
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
}

/* GetAttr */
      static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *o, PyObject *n) {
#if CYTHON_COMPILING_IN_CPYTHON
#if PY_MAJOR_VERSION >= 3
    if (likely(PyUnicode_Check(n)))
#else
    if (likely(PyString_Check(n)))
#endif
        return __Pyx_PyObject_GetAttrStr(o, n);
#endif
    return PyObject_GetAttr(o, n);
}

/* GetAttr3 */
      static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *o, PyObject *n, PyObject *d) {
    PyObject *r = __Pyx_GetAttr(o, n);
    if (unlikely(!r)) {
        if (!PyErr_ExceptionMatches(PyExc_AttributeError))
            goto bad;
        PyErr_Clear();
        r = d;
        Py_INCREF(d);
    }
    return r;
bad:
    return NULL;
}

/* GetModuleGlobalName */
      static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
    PyObject *result;
#if CYTHON_COMPILING_IN_CPYTHON
    result = PyDict_GetItem(__pyx_d, name);
    if (likely(result)) {
        Py_INCREF(result);
    } else {
#else
    result = PyObject_GetItem(__pyx_d, name);
    if (!result) {
        PyErr_Clear();
#endif
        result = __Pyx_GetBuiltinName(name);
    }
    return result;
}

/* PyIntBinop */
        #if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED int inplace) {
    #if PY_MAJOR_VERSION < 3
    if (likely(PyInt_CheckExact(op1))) {
        const long b = intval;
        long x;
        long a = PyInt_AS_LONG(op1);
            x = (long)((unsigned long)a + b);
            if (likely((x^a) >= 0 || (x^b) >= 0))
                return PyInt_FromLong(x);
            return PyLong_Type.tp_as_number->nb_add(op1, op2);
    }
    #endif
    #if CYTHON_USE_PYLONG_INTERNALS && PY_MAJOR_VERSION >= 3
    if (likely(PyLong_CheckExact(op1))) {
        const long b = intval;
        long a, x;
        const PY_LONG_LONG llb = intval;
        PY_LONG_LONG lla, llx;
        const digit* digits = ((PyLongObject*)op1)->ob_digit;
        const Py_ssize_t size = Py_SIZE(op1);
        if (likely(__Pyx_sst_abs(size) <= 1)) {
            a = likely(size) ? digits[0] : 0;
            if (size == -1) a = -a;
        } else {
            switch (size) {
                case -2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = (long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case -3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = (long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case -4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = (long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                default: return PyLong_Type.tp_as_number->nb_add(op1, op2);
            }
        }
                x = a + b;
            return PyLong_FromLong(x);
        long_long:
                llx = lla + llb;
            return PyLong_FromLongLong(llx);
    }
    #endif
    if (PyFloat_CheckExact(op1)) {
        const long b = intval;
        double a = PyFloat_AS_DOUBLE(op1);
            double result;
            PyFPE_START_PROTECT("add", return NULL)
            result = ((double)a) + (double)b;
            PyFPE_END_PROTECT(result)
            return PyFloat_FromDouble(result);
    }
    return (inplace ? PyNumber_InPlaceAdd : PyNumber_Add)(op1, op2);
}
#endif

/* PyIntBinop */
        #if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx_PyInt_SubtractObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED int inplace) {
    #if PY_MAJOR_VERSION < 3
    if (likely(PyInt_CheckExact(op1))) {
        const long b = intval;
        long x;
        long a = PyInt_AS_LONG(op1);
            x = (long)((unsigned long)a - b);
            if (likely((x^a) >= 0 || (x^~b) >= 0))
                return PyInt_FromLong(x);
            return PyLong_Type.tp_as_number->nb_subtract(op1, op2);
    }
    #endif
    #if CYTHON_USE_PYLONG_INTERNALS && PY_MAJOR_VERSION >= 3
    if (likely(PyLong_CheckExact(op1))) {
        const long b = intval;
        long a, x;
        const PY_LONG_LONG llb = intval;
        PY_LONG_LONG lla, llx;
        const digit* digits = ((PyLongObject*)op1)->ob_digit;
        const Py_ssize_t size = Py_SIZE(op1);
        if (likely(__Pyx_sst_abs(size) <= 1)) {
            a = likely(size) ? digits[0] : 0;
            if (size == -1) a = -a;
        } else {
            switch (size) {
                case -2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = (long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case -3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = (long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case -4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = (long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                default: return PyLong_Type.tp_as_number->nb_subtract(op1, op2);
            }
        }
                x = a - b;
            return PyLong_FromLong(x);
        long_long:
                llx = lla - llb;
            return PyLong_FromLongLong(llx);
    }
    #endif
    if (PyFloat_CheckExact(op1)) {
        const long b = intval;
        double a = PyFloat_AS_DOUBLE(op1);
            double result;
            PyFPE_START_PROTECT("subtract", return NULL)
            result = ((double)a) - (double)b;
            PyFPE_END_PROTECT(result)
            return PyFloat_FromDouble(result);
    }
    return (inplace ? PyNumber_InPlaceSubtract : PyNumber_Subtract)(op1, op2);
}
#endif

/* ArgTypeTest */
        static void __Pyx_RaiseArgumentTypeInvalid(const char* name, PyObject *obj, PyTypeObject *type) {
    PyErr_Format(PyExc_TypeError,
        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
        name, type->tp_name, Py_TYPE(obj)->tp_name);
}
static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact)
{
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (none_allowed && obj == Py_None) return 1;
    else if (exact) {
        if (likely(Py_TYPE(obj) == type)) return 1;
        #if PY_MAJOR_VERSION == 2
        else if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
        #endif
    }
    else {
        if (likely(PyObject_TypeCheck(obj, type))) return 1;
    }
    __Pyx_RaiseArgumentTypeInvalid(name, obj, type);
    return 0;
}

/* KeywordStringCheck */
        static CYTHON_INLINE int __Pyx_CheckKeywordStrings(
    PyObject *kwdict,
    const char* function_name,
    int kw_allowed)
{
    PyObject* key = 0;
    Py_ssize_t pos = 0;
#if CYTHON_COMPILING_IN_PYPY
    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
        goto invalid_keyword;
    return 1;
#else
    while (PyDict_Next(kwdict, &pos, &key, 0)) {
        #if PY_MAJOR_VERSION < 3
        if (unlikely(!PyString_CheckExact(key)) && unlikely(!PyString_Check(key)))
        #endif
            if (unlikely(!PyUnicode_Check(key)))
                goto invalid_keyword_type;
    }
    if ((!kw_allowed) && unlikely(key))
        goto invalid_keyword;
    return 1;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    return 0;
#endif
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
    return 0;
}

/* dict_getitem_default */
        static PyObject* __Pyx_PyDict_GetItemDefault(PyObject* d, PyObject* key, PyObject* default_value) {
    PyObject* value;
#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
    value = PyDict_GetItemWithError(d, key);
    if (unlikely(!value)) {
        if (unlikely(PyErr_Occurred()))
            return NULL;
        value = default_value;
    }
    Py_INCREF(value);
#else
    if (PyString_CheckExact(key) || PyUnicode_CheckExact(key) || PyInt_CheckExact(key)) {
        value = PyDict_GetItem(d, key);
        if (unlikely(!value)) {
            value = default_value;
        }
        Py_INCREF(value);
    } else {
        if (default_value == Py_None)
            default_value = NULL;
        value = PyObject_CallMethodObjArgs(
            d, __pyx_n_s_get, key, default_value, NULL);
    }
#endif
    return value;
}

/* None */
        static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname) {
    PyErr_Format(PyExc_UnboundLocalError, "local variable '%s' referenced before assignment", varname);
}

/* SetItemInt */
        static CYTHON_INLINE int __Pyx_SetItemInt_Generic(PyObject *o, PyObject *j, PyObject *v) {
    int r;
    if (!j) return -1;
    r = PyObject_SetItem(o, j, v);
    Py_DECREF(j);
    return r;
}
static CYTHON_INLINE int __Pyx_SetItemInt_Fast(PyObject *o, Py_ssize_t i, PyObject *v, int is_list,
                                               CYTHON_NCP_UNUSED int wraparound, CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (is_list || PyList_CheckExact(o)) {
        Py_ssize_t n = (!wraparound) ? i : ((likely(i >= 0)) ? i : i + PyList_GET_SIZE(o));
        if ((!boundscheck) || likely((n >= 0) & (n < PyList_GET_SIZE(o)))) {
            PyObject* old = PyList_GET_ITEM(o, n);
            Py_INCREF(v);
            PyList_SET_ITEM(o, n, v);
            Py_DECREF(old);
            return 1;
        }
    } else {
        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
        if (likely(m && m->sq_ass_item)) {
            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
                Py_ssize_t l = m->sq_length(o);
                if (likely(l >= 0)) {
                    i += l;
                } else {
                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
                        return -1;
                    PyErr_Clear();
                }
            }
            return m->sq_ass_item(o, i, v);
        }
    }
#else
#if CYTHON_COMPILING_IN_PYPY
    if (is_list || (PySequence_Check(o) && !PyDict_Check(o))) {
#else
    if (is_list || PySequence_Check(o)) {
#endif
        return PySequence_SetItem(o, i, v);
    }
#endif
    return __Pyx_SetItemInt_Generic(o, PyInt_FromSsize_t(i), v);
}

/* SetVTable */
          static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
#if PY_VERSION_HEX >= 0x02070000
    PyObject *ob = PyCapsule_New(vtable, 0, 0);
#else
    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
#endif
    if (!ob)
        goto bad;
    if (PyDict_SetItem(dict, __pyx_n_s_pyx_vtable, ob) < 0)
        goto bad;
    Py_DECREF(ob);
    return 0;
bad:
    Py_XDECREF(ob);
    return -1;
}

/* Import */
          static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_VERSION_HEX < 0x03030000
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                #if PY_VERSION_HEX < 0x03030000
                PyObject *py_level = PyInt_FromLong(1);
                if (!py_level)
                    goto bad;
                module = PyObject_CallFunctionObjArgs(py_import,
                    name, global_dict, empty_dict, list, py_level, NULL);
                Py_DECREF(py_level);
                #else
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                #endif
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0;
        }
        #endif
        if (!module) {
            #if PY_VERSION_HEX < 0x03030000
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
bad:
    #if PY_VERSION_HEX < 0x03030000
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

/* CalculateMetaclass */
          static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases) {
    Py_ssize_t i, nbases = PyTuple_GET_SIZE(bases);
    for (i=0; i < nbases; i++) {
        PyTypeObject *tmptype;
        PyObject *tmp = PyTuple_GET_ITEM(bases, i);
        tmptype = Py_TYPE(tmp);
#if PY_MAJOR_VERSION < 3
        if (tmptype == &PyClass_Type)
            continue;
#endif
        if (!metaclass) {
            metaclass = tmptype;
            continue;
        }
        if (PyType_IsSubtype(metaclass, tmptype))
            continue;
        if (PyType_IsSubtype(tmptype, metaclass)) {
            metaclass = tmptype;
            continue;
        }
        PyErr_SetString(PyExc_TypeError,
                        "metaclass conflict: "
                        "the metaclass of a derived class "
                        "must be a (non-strict) subclass "
                        "of the metaclasses of all its bases");
        return NULL;
    }
    if (!metaclass) {
#if PY_MAJOR_VERSION < 3
        metaclass = &PyClass_Type;
#else
        metaclass = &PyType_Type;
#endif
    }
    Py_INCREF((PyObject*) metaclass);
    return (PyObject*) metaclass;
}

/* Py3ClassCreate */
          static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name,
                                           PyObject *qualname, PyObject *mkw, PyObject *modname, PyObject *doc) {
    PyObject *ns;
    if (metaclass) {
        PyObject *prep = __Pyx_PyObject_GetAttrStr(metaclass, __pyx_n_s_prepare);
        if (prep) {
            PyObject *pargs = PyTuple_Pack(2, name, bases);
            if (unlikely(!pargs)) {
                Py_DECREF(prep);
                return NULL;
            }
            ns = PyObject_Call(prep, pargs, mkw);
            Py_DECREF(prep);
            Py_DECREF(pargs);
        } else {
            if (unlikely(!PyErr_ExceptionMatches(PyExc_AttributeError)))
                return NULL;
            PyErr_Clear();
            ns = PyDict_New();
        }
    } else {
        ns = PyDict_New();
    }
    if (unlikely(!ns))
        return NULL;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_module, modname) < 0)) goto bad;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_qualname, qualname) < 0)) goto bad;
    if (unlikely(doc && PyObject_SetItem(ns, __pyx_n_s_doc, doc) < 0)) goto bad;
    return ns;
bad:
    Py_DECREF(ns);
    return NULL;
}
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases,
                                      PyObject *dict, PyObject *mkw,
                                      int calculate_metaclass, int allow_py2_metaclass) {
    PyObject *result, *margs;
    PyObject *owned_metaclass = NULL;
    if (allow_py2_metaclass) {
        owned_metaclass = PyObject_GetItem(dict, __pyx_n_s_metaclass);
        if (owned_metaclass) {
            metaclass = owned_metaclass;
        } else if (likely(PyErr_ExceptionMatches(PyExc_KeyError))) {
            PyErr_Clear();
        } else {
            return NULL;
        }
    }
    if (calculate_metaclass && (!metaclass || PyType_Check(metaclass))) {
        metaclass = __Pyx_CalculateMetaclass((PyTypeObject*) metaclass, bases);
        Py_XDECREF(owned_metaclass);
        if (unlikely(!metaclass))
            return NULL;
        owned_metaclass = metaclass;
    }
    margs = PyTuple_Pack(3, name, bases, dict);
    if (unlikely(!margs)) {
        result = NULL;
    } else {
        result = PyObject_Call(metaclass, margs, mkw);
        Py_DECREF(margs);
    }
    Py_XDECREF(owned_metaclass);
    return result;
}

/* FetchCommonType */
          static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
    PyObject* fake_module;
    PyTypeObject* cached_type = NULL;
    fake_module = PyImport_AddModule((char*) "_cython_" CYTHON_ABI);
    if (!fake_module) return NULL;
    Py_INCREF(fake_module);
    cached_type = (PyTypeObject*) PyObject_GetAttrString(fake_module, type->tp_name);
    if (cached_type) {
        if (!PyType_Check((PyObject*)cached_type)) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s is not a type object",
                type->tp_name);
            goto bad;
        }
        if (cached_type->tp_basicsize != type->tp_basicsize) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s has the wrong size, try recompiling",
                type->tp_name);
            goto bad;
        }
    } else {
        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
        PyErr_Clear();
        if (PyType_Ready(type) < 0) goto bad;
        if (PyObject_SetAttrString(fake_module, type->tp_name, (PyObject*) type) < 0)
            goto bad;
        Py_INCREF(type);
        cached_type = type;
    }
done:
    Py_DECREF(fake_module);
    return cached_type;
bad:
    Py_XDECREF(cached_type);
    cached_type = NULL;
    goto done;
}

/* CythonFunction */
          static PyObject *
__Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *closure)
{
    if (unlikely(op->func_doc == NULL)) {
        if (op->func.m_ml->ml_doc) {
#if PY_MAJOR_VERSION >= 3
            op->func_doc = PyUnicode_FromString(op->func.m_ml->ml_doc);
#else
            op->func_doc = PyString_FromString(op->func.m_ml->ml_doc);
#endif
            if (unlikely(op->func_doc == NULL))
                return NULL;
        } else {
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    Py_INCREF(op->func_doc);
    return op->func_doc;
}
static int
__Pyx_CyFunction_set_doc(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp = op->func_doc;
    if (value == NULL) {
        value = Py_None;
    }
    Py_INCREF(value);
    op->func_doc = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_name(__pyx_CyFunctionObject *op)
{
    if (unlikely(op->func_name == NULL)) {
#if PY_MAJOR_VERSION >= 3
        op->func_name = PyUnicode_InternFromString(op->func.m_ml->ml_name);
#else
        op->func_name = PyString_InternFromString(op->func.m_ml->ml_name);
#endif
        if (unlikely(op->func_name == NULL))
            return NULL;
    }
    Py_INCREF(op->func_name);
    return op->func_name;
}
static int
__Pyx_CyFunction_set_name(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__name__ must be set to a string object");
        return -1;
    }
    tmp = op->func_name;
    Py_INCREF(value);
    op->func_name = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_qualname(__pyx_CyFunctionObject *op)
{
    Py_INCREF(op->func_qualname);
    return op->func_qualname;
}
static int
__Pyx_CyFunction_set_qualname(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__qualname__ must be set to a string object");
        return -1;
    }
    tmp = op->func_qualname;
    Py_INCREF(value);
    op->func_qualname = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_self(__pyx_CyFunctionObject *m, CYTHON_UNUSED void *closure)
{
    PyObject *self;
    self = m->func_closure;
    if (self == NULL)
        self = Py_None;
    Py_INCREF(self);
    return self;
}
static PyObject *
__Pyx_CyFunction_get_dict(__pyx_CyFunctionObject *op)
{
    if (unlikely(op->func_dict == NULL)) {
        op->func_dict = PyDict_New();
        if (unlikely(op->func_dict == NULL))
            return NULL;
    }
    Py_INCREF(op->func_dict);
    return op->func_dict;
}
static int
__Pyx_CyFunction_set_dict(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
    if (unlikely(value == NULL)) {
        PyErr_SetString(PyExc_TypeError,
               "function's dictionary may not be deleted");
        return -1;
    }
    if (unlikely(!PyDict_Check(value))) {
        PyErr_SetString(PyExc_TypeError,
               "setting function's dictionary to a non-dict");
        return -1;
    }
    tmp = op->func_dict;
    Py_INCREF(value);
    op->func_dict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_globals(__pyx_CyFunctionObject *op)
{
    Py_INCREF(op->func_globals);
    return op->func_globals;
}
static PyObject *
__Pyx_CyFunction_get_closure(CYTHON_UNUSED __pyx_CyFunctionObject *op)
{
    Py_INCREF(Py_None);
    return Py_None;
}
static PyObject *
__Pyx_CyFunction_get_code(__pyx_CyFunctionObject *op)
{
    PyObject* result = (op->func_code) ? op->func_code : Py_None;
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_init_defaults(__pyx_CyFunctionObject *op) {
    int result = 0;
    PyObject *res = op->defaults_getter((PyObject *) op);
    if (unlikely(!res))
        return -1;
    #if CYTHON_COMPILING_IN_CPYTHON
    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
    Py_INCREF(op->defaults_tuple);
    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
    Py_INCREF(op->defaults_kwdict);
    #else
    op->defaults_tuple = PySequence_ITEM(res, 0);
    if (unlikely(!op->defaults_tuple)) result = -1;
    else {
        op->defaults_kwdict = PySequence_ITEM(res, 1);
        if (unlikely(!op->defaults_kwdict)) result = -1;
    }
    #endif
    Py_DECREF(res);
    return result;
}
static int
__Pyx_CyFunction_set_defaults(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyTuple_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__defaults__ must be set to a tuple object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_tuple;
    op->defaults_tuple = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_defaults(__pyx_CyFunctionObject *op) {
    PyObject* result = op->defaults_tuple;
    if (unlikely(!result)) {
        if (op->defaults_getter) {
            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_tuple;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_set_kwdefaults(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__kwdefaults__ must be set to a dict object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_kwdict;
    op->defaults_kwdict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_kwdefaults(__pyx_CyFunctionObject *op) {
    PyObject* result = op->defaults_kwdict;
    if (unlikely(!result)) {
        if (op->defaults_getter) {
            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_kwdict;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_set_annotations(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value || value == Py_None) {
        value = NULL;
    } else if (!PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__annotations__ must be set to a dict object");
        return -1;
    }
    Py_XINCREF(value);
    tmp = op->func_annotations;
    op->func_annotations = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_annotations(__pyx_CyFunctionObject *op) {
    PyObject* result = op->func_annotations;
    if (unlikely(!result)) {
        result = PyDict_New();
        if (unlikely(!result)) return NULL;
        op->func_annotations = result;
    }
    Py_INCREF(result);
    return result;
}
static PyGetSetDef __pyx_CyFunction_getsets[] = {
    {(char *) "func_doc", (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
    {(char *) "__doc__",  (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
    {(char *) "func_name", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
    {(char *) "__name__", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
    {(char *) "__qualname__", (getter)__Pyx_CyFunction_get_qualname, (setter)__Pyx_CyFunction_set_qualname, 0, 0},
    {(char *) "__self__", (getter)__Pyx_CyFunction_get_self, 0, 0, 0},
    {(char *) "func_dict", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
    {(char *) "__dict__", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
    {(char *) "func_globals", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
    {(char *) "__globals__", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
    {(char *) "func_closure", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
    {(char *) "__closure__", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
    {(char *) "func_code", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
    {(char *) "__code__", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
    {(char *) "func_defaults", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
    {(char *) "__defaults__", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
    {(char *) "__kwdefaults__", (getter)__Pyx_CyFunction_get_kwdefaults, (setter)__Pyx_CyFunction_set_kwdefaults, 0, 0},
    {(char *) "__annotations__", (getter)__Pyx_CyFunction_get_annotations, (setter)__Pyx_CyFunction_set_annotations, 0, 0},
    {0, 0, 0, 0, 0}
};
static PyMemberDef __pyx_CyFunction_members[] = {
    {(char *) "__module__", T_OBJECT, offsetof(__pyx_CyFunctionObject, func.m_module), PY_WRITE_RESTRICTED, 0},
    {0, 0, 0,  0, 0}
};
static PyObject *
__Pyx_CyFunction_reduce(__pyx_CyFunctionObject *m, CYTHON_UNUSED PyObject *args)
{
#if PY_MAJOR_VERSION >= 3
    return PyUnicode_FromString(m->func.m_ml->ml_name);
#else
    return PyString_FromString(m->func.m_ml->ml_name);
#endif
}
static PyMethodDef __pyx_CyFunction_methods[] = {
    {"__reduce__", (PyCFunction)__Pyx_CyFunction_reduce, METH_VARARGS, 0},
    {0, 0, 0, 0}
};
#if PY_VERSION_HEX < 0x030500A0
#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
#else
#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func.m_weakreflist)
#endif
static PyObject *__Pyx_CyFunction_New(PyTypeObject *type, PyMethodDef *ml, int flags, PyObject* qualname,
                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
    __pyx_CyFunctionObject *op = PyObject_GC_New(__pyx_CyFunctionObject, type);
    if (op == NULL)
        return NULL;
    op->flags = flags;
    __Pyx_CyFunction_weakreflist(op) = NULL;
    op->func.m_ml = ml;
    op->func.m_self = (PyObject *) op;
    Py_XINCREF(closure);
    op->func_closure = closure;
    Py_XINCREF(module);
    op->func.m_module = module;
    op->func_dict = NULL;
    op->func_name = NULL;
    Py_INCREF(qualname);
    op->func_qualname = qualname;
    op->func_doc = NULL;
    op->func_classobj = NULL;
    op->func_globals = globals;
    Py_INCREF(op->func_globals);
    Py_XINCREF(code);
    op->func_code = code;
    op->defaults_pyobjects = 0;
    op->defaults = NULL;
    op->defaults_tuple = NULL;
    op->defaults_kwdict = NULL;
    op->defaults_getter = NULL;
    op->func_annotations = NULL;
    PyObject_GC_Track(op);
    return (PyObject *) op;
}
static int
__Pyx_CyFunction_clear(__pyx_CyFunctionObject *m)
{
    Py_CLEAR(m->func_closure);
    Py_CLEAR(m->func.m_module);
    Py_CLEAR(m->func_dict);
    Py_CLEAR(m->func_name);
    Py_CLEAR(m->func_qualname);
    Py_CLEAR(m->func_doc);
    Py_CLEAR(m->func_globals);
    Py_CLEAR(m->func_code);
    Py_CLEAR(m->func_classobj);
    Py_CLEAR(m->defaults_tuple);
    Py_CLEAR(m->defaults_kwdict);
    Py_CLEAR(m->func_annotations);
    if (m->defaults) {
        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_XDECREF(pydefaults[i]);
        PyObject_Free(m->defaults);
        m->defaults = NULL;
    }
    return 0;
}
static void __Pyx_CyFunction_dealloc(__pyx_CyFunctionObject *m)
{
    PyObject_GC_UnTrack(m);
    if (__Pyx_CyFunction_weakreflist(m) != NULL)
        PyObject_ClearWeakRefs((PyObject *) m);
    __Pyx_CyFunction_clear(m);
    PyObject_GC_Del(m);
}
static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)
{
    Py_VISIT(m->func_closure);
    Py_VISIT(m->func.m_module);
    Py_VISIT(m->func_dict);
    Py_VISIT(m->func_name);
    Py_VISIT(m->func_qualname);
    Py_VISIT(m->func_doc);
    Py_VISIT(m->func_globals);
    Py_VISIT(m->func_code);
    Py_VISIT(m->func_classobj);
    Py_VISIT(m->defaults_tuple);
    Py_VISIT(m->defaults_kwdict);
    if (m->defaults) {
        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_VISIT(pydefaults[i]);
    }
    return 0;
}
static PyObject *__Pyx_CyFunction_descr_get(PyObject *func, PyObject *obj, PyObject *type)
{
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    if (m->flags & __Pyx_CYFUNCTION_STATICMETHOD) {
        Py_INCREF(func);
        return func;
    }
    if (m->flags & __Pyx_CYFUNCTION_CLASSMETHOD) {
        if (type == NULL)
            type = (PyObject *)(Py_TYPE(obj));
        return __Pyx_PyMethod_New(func, type, (PyObject *)(Py_TYPE(type)));
    }
    if (obj == Py_None)
        obj = NULL;
    return __Pyx_PyMethod_New(func, obj, type);
}
static PyObject*
__Pyx_CyFunction_repr(__pyx_CyFunctionObject *op)
{
#if PY_MAJOR_VERSION >= 3
    return PyUnicode_FromFormat("<cyfunction %U at %p>",
                                op->func_qualname, (void *)op);
#else
    return PyString_FromFormat("<cyfunction %s at %p>",
                               PyString_AsString(op->func_qualname), (void *)op);
#endif
}
#if CYTHON_COMPILING_IN_PYPY
static PyObject * __Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyCFunctionObject* f = (PyCFunctionObject*)func;
    PyCFunction meth = f->m_ml->ml_meth;
    PyObject *self = f->m_self;
    Py_ssize_t size;
    switch (f->m_ml->ml_flags & (METH_VARARGS | METH_KEYWORDS | METH_NOARGS | METH_O)) {
    case METH_VARARGS:
        if (likely(kw == NULL || PyDict_Size(kw) == 0))
            return (*meth)(self, arg);
        break;
    case METH_VARARGS | METH_KEYWORDS:
        return (*(PyCFunctionWithKeywords)meth)(self, arg, kw);
    case METH_NOARGS:
        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
            size = PyTuple_GET_SIZE(arg);
            if (likely(size == 0))
                return (*meth)(self, NULL);
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
                f->m_ml->ml_name, size);
            return NULL;
        }
        break;
    case METH_O:
        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
            size = PyTuple_GET_SIZE(arg);
            if (likely(size == 1)) {
                PyObject *result, *arg0 = PySequence_ITEM(arg, 0);
                if (unlikely(!arg0)) return NULL;
                result = (*meth)(self, arg0);
                Py_DECREF(arg0);
                return result;
            }
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
                f->m_ml->ml_name, size);
            return NULL;
        }
        break;
    default:
        PyErr_SetString(PyExc_SystemError, "Bad call flags in "
                        "__Pyx_CyFunction_Call. METH_OLDARGS is no "
                        "longer supported!");
        return NULL;
    }
    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
                 f->m_ml->ml_name);
    return NULL;
}
#else
static PyObject * __Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
	return PyCFunction_Call(func, arg, kw);
}
#endif
static PyTypeObject __pyx_CyFunctionType_type = {
    PyVarObject_HEAD_INIT(0, 0)
    "cython_function_or_method",
    sizeof(__pyx_CyFunctionObject),
    0,
    (destructor) __Pyx_CyFunction_dealloc,
    0,
    0,
    0,
#if PY_MAJOR_VERSION < 3
    0,
#else
    0,
#endif
    (reprfunc) __Pyx_CyFunction_repr,
    0,
    0,
    0,
    0,
    __Pyx_CyFunction_Call,
    0,
    0,
    0,
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
    0,
    (traverseproc) __Pyx_CyFunction_traverse,
    (inquiry) __Pyx_CyFunction_clear,
    0,
#if PY_VERSION_HEX < 0x030500A0
    offsetof(__pyx_CyFunctionObject, func_weakreflist),
#else
    offsetof(PyCFunctionObject, m_weakreflist),
#endif
    0,
    0,
    __pyx_CyFunction_methods,
    __pyx_CyFunction_members,
    __pyx_CyFunction_getsets,
    0,
    0,
    __Pyx_CyFunction_descr_get,
    0,
    offsetof(__pyx_CyFunctionObject, func_dict),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
#if PY_VERSION_HEX >= 0x030400a1
    0,
#endif
};
static int __pyx_CyFunction_init(void) {
#if !CYTHON_COMPILING_IN_PYPY
    __pyx_CyFunctionType_type.tp_call = PyCFunction_Call;
#endif
    __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
    if (__pyx_CyFunctionType == NULL) {
        return -1;
    }
    return 0;
}
static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *func, size_t size, int pyobjects) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults = PyObject_Malloc(size);
    if (!m->defaults)
        return PyErr_NoMemory();
    memset(m->defaults, 0, size);
    m->defaults_pyobjects = pyobjects;
    return m->defaults;
}
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *func, PyObject *tuple) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults_tuple = tuple;
    Py_INCREF(tuple);
}
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *func, PyObject *dict) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults_kwdict = dict;
    Py_INCREF(dict);
}
static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->func_annotations = dict;
    Py_INCREF(dict);
}

/* GetNameInClass */
              static PyObject *__Pyx_GetNameInClass(PyObject *nmspace, PyObject *name) {
    PyObject *result;
    result = __Pyx_PyObject_GetAttrStr(nmspace, name);
    if (!result)
        result = __Pyx_GetModuleGlobalName(name);
    return result;
}

/* CodeObjectCache */
              static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = start + (end - start) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, (size_t)new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

/* AddTraceback */
              #include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        __pyx_d,      /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = py_line;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

/* CIntFromPyVerify */
              #define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
#define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
#define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
    {\
        func_type value = func_value;\
        if (sizeof(target_type) < sizeof(func_type)) {\
            if (unlikely(value != (func_type) (target_type) value)) {\
                func_type zero = 0;\
                if (exc && unlikely(value == (func_type)-1 && PyErr_Occurred()))\
                    return (target_type) -1;\
                if (is_unsigned && unlikely(value < zero))\
                    goto raise_neg_overflow;\
                else\
                    goto raise_overflow;\
            }\
        }\
        return (target_type) value;\
    }

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
    const long neg_one = (long) -1, const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
    const int neg_one = (int) -1, const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(int) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int),
                                     little, !is_unsigned);
    }
}

/* None */
              static CYTHON_INLINE size_t __Pyx_pow_size_t(size_t b, size_t e) {
    size_t t = b;
    switch (e) {
        case 3:
            t *= b;
        case 2:
            t *= b;
        case 1:
            return t;
        case 0:
            return 1;
    }
    #if 0
    if (unlikely(e<0)) return 0;
    #endif
    t = 1;
    while (likely(e)) {
        t *= (b * (e&1)) | ((~e)&1);
        b *= b;
        e >>= 1;
    }
    return t;
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_int(unsigned int value) {
    const unsigned int neg_one = (unsigned int) -1, const_zero = (unsigned int) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(unsigned int) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(unsigned int) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(unsigned int) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(unsigned int) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(unsigned int) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(unsigned int),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_PY_LONG_LONG(unsigned PY_LONG_LONG value) {
    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG) -1, const_zero = (unsigned PY_LONG_LONG) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(unsigned PY_LONG_LONG) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(unsigned PY_LONG_LONG) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(unsigned PY_LONG_LONG) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(unsigned PY_LONG_LONG) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(unsigned PY_LONG_LONG) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(unsigned PY_LONG_LONG),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_long(unsigned long value) {
    const unsigned long neg_one = (unsigned long) -1, const_zero = (unsigned long) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(unsigned long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(unsigned long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(unsigned long) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(unsigned long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(unsigned long) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(unsigned long),
                                     little, !is_unsigned);
    }
}

/* ClassMethod */
              static PyObject* __Pyx_Method_ClassMethod(PyObject *method) {
#if CYTHON_COMPILING_IN_PYPY
    if (PyObject_TypeCheck(method, &PyWrapperDescr_Type)) {
        return PyClassMethod_New(method);
    }
#else
    static PyTypeObject *methoddescr_type = NULL;
    if (methoddescr_type == NULL) {
       PyObject *meth = PyObject_GetAttrString((PyObject*)&PyList_Type, "append");
       if (!meth) return NULL;
       methoddescr_type = Py_TYPE(meth);
       Py_DECREF(meth);
    }
    if (PyObject_TypeCheck(method, methoddescr_type)) {
        PyMethodDescrObject *descr = (PyMethodDescrObject *)method;
        #if PY_VERSION_HEX < 0x03020000
        PyTypeObject *d_type = descr->d_type;
        #else
        PyTypeObject *d_type = descr->d_common.d_type;
        #endif
        return PyDescr_NewClassMethod(d_type, descr->d_method);
    }
#endif
    else if (PyMethod_Check(method)) {
        return PyClassMethod_New(PyMethod_GET_FUNCTION(method));
    }
    else if (PyCFunction_Check(method)) {
        return PyClassMethod_New(method);
    }
#ifdef __Pyx_CyFunction_USED
    else if (PyObject_TypeCheck(method, __pyx_CyFunctionType)) {
        return PyClassMethod_New(method);
    }
#endif
    PyErr_SetString(PyExc_TypeError,
                   "Class-level classmethod() can only be called on "
                   "a method_descriptor or instance method.");
    return NULL;
}

/* CIntFromPy */
              static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
    const int neg_one = (int) -1, const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

/* CIntFromPy */
              static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
    const long neg_one = (long) -1, const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (long) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

/* CIntFromPy */
              static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *x) {
    const size_t neg_one = (size_t) -1, const_zero = (size_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(size_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(size_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (size_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (size_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(size_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(size_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) >= 2 * PyLong_SHIFT) {
                            return (size_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(size_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) >= 3 * PyLong_SHIFT) {
                            return (size_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(size_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) >= 4 * PyLong_SHIFT) {
                            return (size_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (size_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(size_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(size_t, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(size_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(size_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (size_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(size_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(size_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(size_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
                            return (size_t) (((size_t)-1)*(((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(size_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
                            return (size_t) ((((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
                            return (size_t) (((size_t)-1)*(((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(size_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
                            return (size_t) ((((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 4 * PyLong_SHIFT) {
                            return (size_t) (((size_t)-1)*(((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(size_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 4 * PyLong_SHIFT) {
                            return (size_t) ((((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(size_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(size_t, long, PyLong_AsLong(x))
            } else if (sizeof(size_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(size_t, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            size_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (size_t) -1;
        }
    } else {
        size_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (size_t) -1;
        val = __Pyx_PyInt_As_size_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to size_t");
    return (size_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to size_t");
    return (size_t) -1;
}

/* CIntFromPy */
              static CYTHON_INLINE unsigned int __Pyx_PyInt_As_unsigned_int(PyObject *x) {
    const unsigned int neg_one = (unsigned int) -1, const_zero = (unsigned int) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(unsigned int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(unsigned int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (unsigned int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (unsigned int) 0;
                case  1: __PYX_VERIFY_RETURN_INT(unsigned int, digit, digits[0])
                case 2:
                    if (8 * sizeof(unsigned int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) >= 2 * PyLong_SHIFT) {
                            return (unsigned int) (((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(unsigned int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) >= 3 * PyLong_SHIFT) {
                            return (unsigned int) (((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(unsigned int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) >= 4 * PyLong_SHIFT) {
                            return (unsigned int) (((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (unsigned int) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(unsigned int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(unsigned int) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (unsigned int) 0;
                case -1: __PYX_VERIFY_RETURN_INT(unsigned int, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(unsigned int,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(unsigned int) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
                            return (unsigned int) (((unsigned int)-1)*(((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(unsigned int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
                            return (unsigned int) ((((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
                            return (unsigned int) (((unsigned int)-1)*(((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(unsigned int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
                            return (unsigned int) ((((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) - 1 > 4 * PyLong_SHIFT) {
                            return (unsigned int) (((unsigned int)-1)*(((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(unsigned int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) - 1 > 4 * PyLong_SHIFT) {
                            return (unsigned int) ((((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(unsigned int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, long, PyLong_AsLong(x))
            } else if (sizeof(unsigned int) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            unsigned int val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (unsigned int) -1;
        }
    } else {
        unsigned int val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (unsigned int) -1;
        val = __Pyx_PyInt_As_unsigned_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to unsigned int");
    return (unsigned int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to unsigned int");
    return (unsigned int) -1;
}

/* CIntFromPy */
              static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_As_unsigned_PY_LONG_LONG(PyObject *x) {
    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG) -1, const_zero = (unsigned PY_LONG_LONG) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(unsigned PY_LONG_LONG) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (unsigned PY_LONG_LONG) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (unsigned PY_LONG_LONG) 0;
                case  1: __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, digit, digits[0])
                case 2:
                    if (8 * sizeof(unsigned PY_LONG_LONG) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned PY_LONG_LONG) >= 2 * PyLong_SHIFT) {
                            return (unsigned PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(unsigned PY_LONG_LONG) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned PY_LONG_LONG) >= 3 * PyLong_SHIFT) {
                            return (unsigned PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(unsigned PY_LONG_LONG) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned PY_LONG_LONG) >= 4 * PyLong_SHIFT) {
                            return (unsigned PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (unsigned PY_LONG_LONG) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(unsigned PY_LONG_LONG) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned PY_LONG_LONG, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(unsigned PY_LONG_LONG) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned PY_LONG_LONG, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (unsigned PY_LONG_LONG) 0;
                case -1: __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                            return (unsigned PY_LONG_LONG) (((unsigned PY_LONG_LONG)-1)*(((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(unsigned PY_LONG_LONG) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                            return (unsigned PY_LONG_LONG) ((((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                            return (unsigned PY_LONG_LONG) (((unsigned PY_LONG_LONG)-1)*(((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(unsigned PY_LONG_LONG) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                            return (unsigned PY_LONG_LONG) ((((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                            return (unsigned PY_LONG_LONG) (((unsigned PY_LONG_LONG)-1)*(((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(unsigned PY_LONG_LONG) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned PY_LONG_LONG, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                            return (unsigned PY_LONG_LONG) ((((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(unsigned PY_LONG_LONG) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned PY_LONG_LONG, long, PyLong_AsLong(x))
            } else if (sizeof(unsigned PY_LONG_LONG) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned PY_LONG_LONG, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            unsigned PY_LONG_LONG val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (unsigned PY_LONG_LONG) -1;
        }
    } else {
        unsigned PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (unsigned PY_LONG_LONG) -1;
        val = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to unsigned PY_LONG_LONG");
    return (unsigned PY_LONG_LONG) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to unsigned PY_LONG_LONG");
    return (unsigned PY_LONG_LONG) -1;
}

/* CIntFromPy */
              static CYTHON_INLINE unsigned long __Pyx_PyInt_As_unsigned_long(PyObject *x) {
    const unsigned long neg_one = (unsigned long) -1, const_zero = (unsigned long) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(unsigned long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(unsigned long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (unsigned long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (unsigned long) 0;
                case  1: __PYX_VERIFY_RETURN_INT(unsigned long, digit, digits[0])
                case 2:
                    if (8 * sizeof(unsigned long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned long) >= 2 * PyLong_SHIFT) {
                            return (unsigned long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned long) >= 3 * PyLong_SHIFT) {
                            return (unsigned long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned long) >= 4 * PyLong_SHIFT) {
                            return (unsigned long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (unsigned long) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(unsigned long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned long, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(unsigned long) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (unsigned long) 0;
                case -1: __PYX_VERIFY_RETURN_INT(unsigned long, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(unsigned long,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(unsigned long) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned long) - 1 > 2 * PyLong_SHIFT) {
                            return (unsigned long) (((unsigned long)-1)*(((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(unsigned long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned long) - 1 > 2 * PyLong_SHIFT) {
                            return (unsigned long) ((((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(unsigned long) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned long) - 1 > 3 * PyLong_SHIFT) {
                            return (unsigned long) (((unsigned long)-1)*(((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned long) - 1 > 3 * PyLong_SHIFT) {
                            return (unsigned long) ((((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(unsigned long) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned long) - 1 > 4 * PyLong_SHIFT) {
                            return (unsigned long) (((unsigned long)-1)*(((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned long) - 1 > 4 * PyLong_SHIFT) {
                            return (unsigned long) ((((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(unsigned long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned long, long, PyLong_AsLong(x))
            } else if (sizeof(unsigned long) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned long, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            unsigned long val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (unsigned long) -1;
        }
    } else {
        unsigned long val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (unsigned long) -1;
        val = __Pyx_PyInt_As_unsigned_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to unsigned long");
    return (unsigned long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to unsigned long");
    return (unsigned long) -1;
}

/* CheckBinaryVersion */
              static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

/* InitStrings */
              static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if CYTHON_COMPILING_IN_CPYTHON && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
#if PY_VERSION_HEX < 0x03030000
        char* defenc_c;
        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
        if (!defenc) return NULL;
        defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        {
            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
            char* c;
            for (c = defenc_c; c < end; c++) {
                if ((unsigned char) (*c) >= 128) {
                    PyUnicode_AsASCIIString(o);
                    return NULL;
                }
            }
        }
#endif
        *length = PyBytes_GET_SIZE(defenc);
        return defenc_c;
#else
        if (__Pyx_PyUnicode_READY(o) == -1) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        if (PyUnicode_IS_ASCII(o)) {
            *length = PyUnicode_GET_LENGTH(o);
            return PyUnicode_AsUTF8(o);
        } else {
            PyUnicode_AsASCIIString(o);
            return NULL;
        }
#else
        return PyUnicode_AsUTF8AndSize(o, length);
#endif
#endif
    } else
#endif
#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
  PyNumberMethods *m;
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return __Pyx_NewRef(x);
  m = Py_TYPE(x)->tp_as_number;
#if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
#else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
#endif
  if (res) {
#if PY_MAJOR_VERSION < 3
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%.4s__ returned non-%.4s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b))) {
    if (sizeof(Py_ssize_t) >= sizeof(long))
        return PyInt_AS_LONG(b);
    else
        return PyInt_AsSsize_t(x);
  }
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_USE_PYLONG_INTERNALS
    const digit* digits = ((PyLongObject*)b)->ob_digit;
    const Py_ssize_t size = Py_SIZE(b);
    if (likely(__Pyx_sst_abs(size) <= 1)) {
        ival = likely(size) ? digits[0] : 0;
        if (size == -1) ival = -ival;
        return ival;
    } else {
      switch (size) {
         case 2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
      }
    }
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
